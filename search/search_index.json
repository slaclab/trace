{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trace","text":"<p>Trace is a PyDM-based application developed at SLAC National Accelerator Laboratory.</p> <p>The motivation behind trace is as a replacement for the StripTool and Java Archive Viewer applications used to plot EPICS data. It is a flexible, modern application for plotting live data (Channel Access or PV Access), and historical data from the EPICS Archive Appliance.</p> <p>With built in conveniences like an archived PV search, and designed to be easily launched from PyDM widgets, files, or the command line, Trace will provide an improved user experience for accelerator staff.</p> <p>Trace is open-source and in active development, so don't hesitate to request features or report bugs.</p>"},{"location":"arguments/","title":"Input Arguments &amp; Macros","text":"<p>Trace supports several optional startup arguments and macros that allow users to customize its behavior at launch. These arguments let you specify input files, define process variables (PVs) to display, apply macro replacements, and access help or version information.</p> <p>Below, you'll find a detailed overview of each available argument and example usage to help you configure Trace to fit your workflow.</p>"},{"location":"arguments/#config-file","title":"Config File","text":"<p><code>-i INPUT_FILE</code> or <code>--input_file INPUT_FILE</code></p> <p>This argument allows users to import Trace config files, providing a way to recover a previous state of Trace. To make use of it, users should provide a filepath for the config file they want to use. The path can be either relative or absolute.</p> <pre><code>pydm trace/main.py -i trace/examples/FormulaExample.trc\n</code></pre>"},{"location":"arguments/#startup-pvs","title":"Startup PVs","text":"<p><code>-p PV1 PV2 ...</code> or <code>--pvs PV1 PV2 ...</code></p> <p>Users are able to provide a list of PVs to show traces for on startup. Each PV passed here will be represented by a curve on the plot.</p> <pre><code>pydm trace/main.py -p FOO:BAR:CHANNEL SOME:OTHER:CHANNEL\n</code></pre>"},{"location":"arguments/#macros","title":"Macros","text":"<p><code>-m MACRO</code> or <code>--macro MACRO</code></p> <p>Use PyDM's macro substitution system as another way of adding PVs or startup files to Trace. Adding PVs via macros is equivalent to adding them as an argument. This setup allows users to add traces from other PyDM widgets, such as the PyDMRelatedDisplayButton.</p> <pre><code>pydm trace/main.py -m '{\"PVS\": [\"FOO:BAR:CHANNEL\", \"SOME:OTHER:CHANNEL\"]}'\npydm trace/main.py -m \"INPUT_FILE = trace/examples/FormulaExample.trc\"\n</code></pre>"},{"location":"arguments/#help-message","title":"Help Message","text":"<p><code>-h</code> or <code>--help</code></p> <p>Shows Trace's help message, which outlines the available arguments for users.</p>"},{"location":"arguments/#version-number","title":"Version Number","text":"<p><code>-v</code> or <code>--version</code></p> <p>Show Trace's current version/release number.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or newer</li> <li>pip (Python package manager)</li> <li>(Optional) conda for environment management</li> </ul>"},{"location":"installation/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/slaclab/trace.git\n</code></pre>"},{"location":"installation/#create-and-activate-a-virtual-environment-recommended","title":"Create and Activate a Virtual Environment (Recommended)","text":"<p>Using <code>venv</code>: <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\n</code></pre></p> <p>Or using <code>conda</code>: <pre><code>conda env create -f environment.yml\nconda activate trace\n</code></pre></p>"},{"location":"installation/#install-dependencies","title":"Install Dependencies","text":"<p>If using pip: <pre><code>pip install -r requirements.txt\n</code></pre></p> <p>Or with <code>conda</code> (if you created the environment above, dependencies are already installed): <pre><code>conda env update -f environment.yml\n</code></pre></p>"},{"location":"installation/#environment-setup","title":"Environment Setup","text":"<p>Trace references a couple of environment variables that can be used for configuring some interactions.</p> <p>Below is a table describing the environment variables that need to be set.</p> Variable What is it used for? PYDM_ARCHIVER_URL The base URL for the Archiver Appliance Data Plugin SWAPPS_TRACE_ELOG_API_URL The base URL for the E-Log API SWAPPS_TRACE_ELOG_API_KEY Your API key for authenticating with the E-Log system"},{"location":"installation/#running-trace","title":"Running Trace","text":"<p>The main startup file for trace is located at <code>trace/main.py</code>.</p> <p>Trace can be launched using PyDM, and users can pass in additional arguments and macros.</p> <pre><code>pydm trace/main.py\n</code></pre>"},{"location":"io/","title":"Import &amp; Export","text":"<p>Trace allows users to save their current configuration and import it later. This includes the archiver URL, plot configuration, time range, Y-axes, and all traces.</p>"},{"location":"io/#quick-access","title":"Quick Access","text":"<ul> <li>Save: <code>Ctrl+S</code> or Trace menu \u2192 Save</li> <li>Save As: <code>Ctrl+Shift+S</code> or Trace menu \u2192 Save As...</li> <li>Open: <code>Ctrl+O</code> or Trace menu \u2192 Open Trace Config...</li> <li>Command Line: Use the <code>-i</code> flag to import files on startup</li> </ul> <p>For more information on command-line arguments, see Application Arguments.</p>"},{"location":"io/#supported-file-formats","title":"Supported File Formats","text":"<p>Trace supports three file formats for importing:</p> Format Extension Import Export Notes Trace <code>.trc</code> \u2705 \u2705 Native JSON format Java Archive Viewer <code>.xml</code> \u2705 \u274c Converts to <code>.trc</code> on save StripTool <code>.stp</code> \u2705 \u274c Converts to <code>.trc</code> on save"},{"location":"io/#converting-legacy-files","title":"Converting Legacy Files","text":"<p>For bulk conversion of Java Archive Viewer and StripTool files to Trace format, use the CLI file converter tool.</p>"},{"location":"io/#file-format-details","title":"File Format Details","text":""},{"location":"io/#trace-files-trc","title":"Trace Files (<code>.trc</code>)","text":"<p>Trace's native format uses JSON for human readability and editability. These files contain only Trace-specific properties and can be used to:</p> <ul> <li>Configure Trace's appearance</li> <li>Define data to load on startup</li> <li>Share configurations between users</li> </ul>"},{"location":"io/#java-archive-viewer-files-xml","title":"Java Archive Viewer Files (<code>.xml</code>)","text":"<p>Legacy files from the Java-based Archive Viewer can be imported directly. When saving changes, they are automatically converted to Trace format.</p> <p>To import: Use the file dialog and select \"Java Archive Viewer files (*.xml)\" from the format filter.</p>"},{"location":"io/#striptool-files-stp","title":"StripTool Files (<code>.stp</code>)","text":"<p>StripTool configuration files can be imported or converted using the CLI tool. When saving changes, they are automatically converted to Trace format.</p> <p>To import: Use the file dialog and select \"StripTool files (*.stp)\" from the format filter.</p>"},{"location":"io/#color-format","title":"Color Format","text":"<p>Colors in save files are represented as:</p> <ul> <li>Hexadecimal RGB: <code>#FF0000</code> (red)</li> <li>Color names: <code>\"red\"</code>, <code>\"blue\"</code>, <code>\"white\"</code>, etc.</li> </ul> <p>Both formats are supported when loading files into Trace.</p>"},{"location":"overview/","title":"Interface Layout &amp; Sections","text":"<p>Trace is a PyDM application used to plot value data for given PVs. The application is capable of plotting both live and archived data, as well as formulas containing PVs as variables.</p> <p>The application consists of two main parts:</p> <ul> <li>Plot Section on the left</li> <li>Configuration Section on the right</li> <li>Footer at the bottom</li> </ul> <p>Users are able to control the size of these two sections by clicking and dragging the vertical white splitter in the center of the application. The configuration section can be completely collapsed so that the application only shows the plot.</p>"},{"location":"plot_config/","title":"Plot Configuration","text":"<p>The Plot Settings modal allows you to customize the appearance and behavior of your plot. These settings are saved with Trace configuration files (<code>.trc</code>) and can be shared between users.</p> <p>Access the Plot Settings by clicking the gear icon () in the top-right corner of the plot area.</p> <p>The Plot Settings modal showing all available configuration options</p>"},{"location":"plot_config/#basic-settings","title":"Basic Settings","text":""},{"location":"plot_config/#plot-title","title":"Plot Title","text":"<ul> <li>Purpose: Set a custom title for your plot</li> <li>Default: No title</li> <li>Usage: Enter text in the \"Title\" field</li> <li>Note: The title is centered at the top of the plot</li> </ul>"},{"location":"plot_config/#legend","title":"Legend","text":"<ul> <li>Purpose: Show/hide the plot legend</li> <li>Default: Enabled</li> <li>Usage: Check/uncheck \"Show Legend\"</li> <li>Note: The legend displays trace labels and their colors</li> </ul>"},{"location":"plot_config/#mouse-mode","title":"Mouse Mode","text":"<ul> <li>Purpose: Control how mouse interactions work</li> <li>Options:<ul> <li>Rect (default): Click and drag to zoom to a rectangular area</li> <li>Pan: Click and drag to pan the plot view</li> </ul> </li> <li>Usage: Select from the \"Mouse Mode\" dropdown</li> </ul>"},{"location":"plot_config/#time-range-settings","title":"Time Range Settings","text":""},{"location":"plot_config/#start-time-end-time","title":"Start Time &amp; End Time","text":"<ul> <li>Purpose: Set specific time boundaries for the plot</li> <li>Default: Current plot range</li> <li>Usage: Use the date/time pickers to set start and end times</li> <li>Features:</li> <li>Calendar popup for easy date selection</li> <li>Format: <code>yyyy-MM-dd HH:mm:ss</code></li> <li>Automatically disables autoscroll when changed</li> </ul>"},{"location":"plot_config/#autoscroll-interval","title":"Autoscroll Interval","text":"<ul> <li>Purpose: Control how often the plot updates during autoscroll</li> <li>Default: 5 seconds</li> <li>Range: 1-60 seconds</li> <li>Usage: Adjust the \"Autoscroll Interval\" spinbox</li> </ul>"},{"location":"plot_config/#appearance-settings","title":"Appearance Settings","text":""},{"location":"plot_config/#background-color","title":"Background Color","text":"<ul> <li>Purpose: Set the plot background color</li> <li>Default: White</li> <li>Usage: Click the color button to open a color picker</li> <li>Note: Changes are applied immediately</li> </ul>"},{"location":"plot_config/#axis-tick-font-size","title":"Axis Tick Font Size","text":"<ul> <li>Purpose: Control the size of axis tick labels</li> <li>Default: 12 points</li> <li>Usage: Adjust the \"Axis Tick Font Size\" spinbox</li> <li>Note: Smaller fonts show more tick marks, larger fonts show fewer</li> </ul>"},{"location":"plot_config/#crosshair","title":"Crosshair","text":"<ul> <li>Purpose: Display a crosshair cursor on the plot</li> <li>Default: Disabled</li> <li>Usage: Check/uncheck \"Show Crosshair\"</li> <li>Note: Yellow crosshair follows mouse movement</li> </ul>"},{"location":"plot_config/#grid-settings","title":"Grid Settings","text":""},{"location":"plot_config/#x-axis-gridlines","title":"X-Axis Gridlines","text":"<ul> <li>Purpose: Show/hide horizontal gridlines</li> <li>Default: Disabled</li> <li>Usage: Check/uncheck \"X Axis Gridline\"</li> </ul>"},{"location":"plot_config/#y-axis-gridlines","title":"Y-Axis Gridlines","text":"<ul> <li>Purpose: Show/hide vertical gridlines for all Y-axes</li> <li>Default: Disabled</li> <li>Usage: Check/uncheck \"All Y Axis Gridlines\"</li> </ul>"},{"location":"plot_config/#gridline-opacity","title":"Gridline Opacity","text":"<ul> <li>Purpose: Control the transparency of gridlines</li> <li>Default: ~50% (127/255)</li> <li>Range: 0-255 (0 = transparent, 255 = opaque)</li> <li>Usage: Use the opacity slider</li> <li>Note: Affects both X and Y axis gridlines</li> </ul>"},{"location":"plot_config/#configuration-persistence","title":"Configuration Persistence","text":"<p>All plot settings are automatically saved when you: - Save a Trace configuration file (<code>.trc</code>) - Export your current setup</p> <p>Settings are restored when you: - Load a Trace configuration file - Start Trace with a saved configuration</p>"},{"location":"plot_config/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<ul> <li>Ctrl+T: Toggle between light and dark themes</li> <li>Ctrl+I: Save plot as image</li> <li>Ctrl+E: Post to E-Log</li> </ul>"},{"location":"plot_config/#tips","title":"Tips","text":"<ol> <li>Screenshots: Configure appearance settings before taking screenshots for presentations</li> <li>Sharing: Save your configuration to share plot styles with colleagues</li> <li>Performance: Higher autoscroll intervals reduce CPU usage but may feel less responsive</li> <li>Accessibility: Larger font sizes and higher gridline opacity improve readability</li> </ol>"},{"location":"traces/","title":"Traces","text":"<p>Traces, sometimes called curves, are the lines that are shown on the application's plot. They show both live and archive data for the given channel.</p> <p>The properties of each trace can be controlled by the user through interaction with the configuration section of the application.</p>"},{"location":"traces/#adding-traces","title":"Adding Traces","text":"<p>Users can add traces to the plot by adding them to the configuration section. This can be done by entering a channel into the text box at the top of the section and hitting <code>Enter</code> or clicking the button labeled \"Plot\". Once a channel is added, the trace will be added to the plot and both live and archived data will be shown. Traces can also be added using the PV Search tool.</p> <p>When adding new traces, they will be attached to the last y-axis in the configuration section. If no axes exist, a new one will be created for the new trace.</p>"},{"location":"traces/#planned-for-future-development","title":"Planned for Future Development","text":"<p>When adding new traces, they will be attached to a y-axis with the same unit. If no such axis exists, a new one will be created for the channel's unit. If the channel has no units, a new axis will be created with no associated units.</p>"},{"location":"traces/#hiding-traces","title":"Hiding Traces","text":"<p>Users can hide or show individual traces on the plot without removing them. This can be done by unchecking the box labeled \"Active\".</p>"},{"location":"traces/#removing-traces","title":"Removing Traces","text":"<p>Users can remove traces from the plot by clicking the  button for the associated trace. This will remove the row from the configuration section and remove the trace from the plot at the same time.</p>"},{"location":"traces/#moving-traces","title":"Moving Traces","text":"<p>When a trace is created it is attached to the last Y-axis in the configuration section, as mentioned above in Adding Traces. If users want to move a trace to a different Y-axis, they can click and hold the handle marked with a  symbol.</p>"},{"location":"traces/#formula-traces","title":"Formula Traces","text":"<p>Users can add formulas to the plot by entering their formula to be calculated as the trace's channel. The formula should be prepended with <code>f://</code> to signify that the channel is a formula. Formulas can also be added using the formula input tool by clicking the  button.</p> <p>Other traces the formula uses are represented by their unique variable name in a set of curly brackets, e.g. <code>{x1}</code>, <code>{x4}</code>, <code>{fx3}</code>. Formulas can include all basic arithmetic and binary operations, as well as <code>mean</code> and all functions in Python's standard math library.</p> <p>As an example, if we have 2 PVs with the variable names <code>x1</code> and <code>x2</code>, then we may have the formulas:</p> <ul> <li><code>f://{x1} + {x2}</code></li> <li><code>f://min({x1}, {x2})</code></li> <li><code>f://{x1} ^ {x2}</code></li> </ul>"},{"location":"traces/#trace-settings","title":"Trace Settings","text":"<p>Users can change a trace's settings by clicking the associated  button on the right side of the configuration section. This will open a pop-up window that allows for a lot of customization of individual traces.</p>"},{"location":"traces/#curve-name","title":"Curve Name","text":"<p>This setting lets users change the name of the on the plot's legend. The default value is the trace's channel or formula.</p>"},{"location":"traces/#color","title":"Color","text":"<p>The color the curve should show up as on the plot &amp; legend. Sets the color for both the trace and its symbols.</p> <p>Clicking this button will open the default PyQT color selector dialog window. Once the color has been changed, right clicking the button will set it back to its initial color.</p>"},{"location":"traces/#optimized-bin-count","title":"Optimized Bin Count","text":"<p>This setting allows users to set the resolution of historical data gathered from the archiver appliance. This only applies when the user requests around 5 hours or more worth of archive data. The default value is 5000 data points.</p>"},{"location":"traces/#live-data-archive-data","title":"Live Data &amp; Archive Data","text":"<p>The user can determine what kind of data should be fetched. Live data will be added to the trace on the channel's value change. If Live data fetching is disabled and then later reenabled, then archiver data will be fetched to backfill the missing section. By default, both Live data and Archive data fetching are enabled.</p>"},{"location":"traces/#line-type","title":"Line Type","text":"<p>A dropdown menu containing 2 options: Direct and Step. The Direct option draws sloped lines directly between points on the plot. The Step option draws the trace as horizontal lines to the right of their points and continue until a new point on the plot.</p>"},{"location":"traces/#line-style-line-width","title":"Line Style &amp; Line Width","text":"<p>Controls the style and size of the trace on the plot. The styles include no line, solid (-----), dash (- - -), dot (...), dash dot (-.-.-), and dash dot dot (-..-..).</p> <p>The widths are limited to 1px - 5px, with 1px being the default.</p>"},{"location":"traces/#line-extension","title":"Line Extension","text":"<p>Checking this box will result in a line being drawn from the last point into the future. This can be used if a curve doesn't have as recent an archived point as the other, then this line will could be used to show the last value of the curve in the past.</p>"},{"location":"traces/#symbol-symbol-size","title":"Symbol &amp; Symbol Size","text":"<p>Controls what symbols should be shown at each point on the trace.</p> <p>By default no symbols are shown, but users have many shapes they can choose from including circles, triangles, squares, etc. Users can also choose the size of the symbol at 5px, 10px, 15px, or 20px with 10px being the default.</p>"},{"location":"y_axes/","title":"Y-Axes","text":"<p>Users are able to manage the axes on their plot in the configuration section. From adding/removing axes, hiding axes, or changing an axis' properties, users have plenty of control over the Y-Axes of their plot.</p>"},{"location":"y_axes/#adding-axes","title":"Adding Axes","text":"<p>Users can create new Y-axes to organize traces by clicking the button labeled \"New Axis\" at the bottom of the configuration section. The new axis won't have any associated traces on creation, but the can be added and configured.</p>"},{"location":"y_axes/#renaming-axes","title":"Renaming Axes","text":"<p>By default, new Y-axes are names \"Y-Axis &lt;#&gt;\" where <code>&lt;#&gt;</code> is an incrementing number. Users are able to rename an axis by editing the text in the associate text box.</p>"},{"location":"y_axes/#deleting-axes","title":"Deleting Axes","text":"<p>Users can remove axes by clicking the  button for the given axis on the right side of the section. Deleting an axis will remove the axis from both the table and the plot, as well as all of the traces attached to that axis.</p>"},{"location":"y_axes/#hiding-axes","title":"Hiding Axes","text":"<p>Users have the option to hide/show Y-axes on the plot using the checkbox labeled \"Active\" on the right side of the section. Hiding a Y-axis will hide all traces attached to it as well.</p>"},{"location":"y_axes/#axis-settings","title":"Axis Settings","text":"<p>Users can change an axis' vertical range and settings on an axis-by-axis basis.</p> <p>Some of an axis' settings can be configured by clicking the associated  button on the right side of the section. This will open a pop-up window that allows for a lot of customization of the axis. It looks like this.</p>"},{"location":"y_axes/#vertical-range","title":"Vertical Range","text":"<p>An axis' range can be changed in a few different ways. By default, an axis will automatically scale its range to show all data for its traces. This feature can be enabled/disabled using the checkbox labeled \"Auto\". It will also be automatically disabled if the user changes the range manually in one of the following ways.</p> <p>Another, more common way for users to change the range is by scrolling/dragging on the plot. This can be done on individual axes or on all axes at once. See Mouse Controls for more details.</p> <p>Finally, users also have the option to set the range manually by altering the values in the text boxes labeled <code>min, max</code> in the configuration section. This will result in the Y-axis being locked at that range, even if trace data isn't in that range.</p>"},{"location":"y_axes/#orientation","title":"Orientation","text":"<p>Sets if the axis is displayed on the left or right side of the plot. This doesn't affect the data or the plot and is purely a cosmetic change.</p>"},{"location":"y_axes/#log-mode","title":"Log Mode","text":"<p>Sets if the axis is on a linear scale or a logarithmic scale.</p>"},{"location":"y_axes/#y-axis-gridline","title":"Y-Axis Gridline","text":"<p>Sets if gridlines are shown on the plot. These will be horizontal lines at all major ticks on the Y-axis.</p> <p>Gridlines can be enabled/disabled individually here, or enabled/disabled for all axes in the plot settings pop-up.</p>"},{"location":"overview/config_section/","title":"Configuration Section","text":"<p>The configuration section is where users are able to add axes and traces to the plot as well as configure their appearances.</p>"},{"location":"overview/config_section/#adding-traces","title":"Adding Traces","text":"<p>To add traces to the plot, users can type a PV address into the line edit at the top of the section and hit enter or click the \"Plot\" button. This will create a trace for the PV and add it to the Y-axis listed last in the configuration section.</p> <p>Users are able to search for PV(s) by clicking the button labeled \"Search PVs\" to open the Archive Search Tool. More information on the tool can be found here.</p> <p>Users are also able to add formula traces by using the Formula Maker Tool. The tool can be opened by clicking the  button in the top of this section.</p>"},{"location":"overview/config_section/#adding-axes","title":"Adding Axes","text":"<p>Users are also able to create new Y-axes using the large button at the bottom of the section labeled \"New Axis\". Clicking this will add a new axis to both the plot and the configuration section.</p>"},{"location":"overview/config_section/#hiding-axes-traces","title":"Hiding Axes &amp; Traces","text":"<p>Users are able to hide traces or axes on the plot without deleting them from the application. This could be useful if users want to visualize the plot without individual traces, or if there is a lot of clutter.</p>"},{"location":"overview/config_section/#from-the-section","title":"From the Section","text":"<p>Axes and all of their curves can be collapsed in the configuration section by clicking the  next to them on the left side of the section. All of the traces will still appear on the plot.</p>"},{"location":"overview/config_section/#from-the-plot","title":"From the Plot","text":"<p>Both axes and individual traces can be shown/hidden from the plot by toggling the checkboxes labeled \"Active\".</p>"},{"location":"overview/footer/","title":"Footer","text":"<p>At the very bottom of the screen is a footer containing some information that may be useful to users.</p> <p>The left side of the footer displays some information about the application itself. Here is what the footer displays, listed from left to right: - Server that Trace is running on - Archiver URL used by PyDM to fetch archiver data - Imported config file (if a file was imported/exported; more information here)</p> <p>The current date and time is displayed on the right side of the footer. This can be useful if users take a screenshot to share around.</p>"},{"location":"overview/plot_section/","title":"Plot Section &amp; Mouse Interaction","text":"<p>The plot section is primarily for viewing the plot, but also has some control over the plot's settings. It displays whatever traces, axes, or other properties the user sets.</p>"},{"location":"overview/plot_section/#mouse-controls","title":"Mouse Controls","text":"<p>The plot's axes can be controlled using the mouse. Users can scroll up to zoom in, or scroll down to zoom out. If this is done over a single axis, then just the one axis is affected. However, if the user scrolls in the plotting area, then the X-Axis and all Y-Axes will zoom in the corresponding direction.</p> <p>Users are able to pan along a single axis by clicking and dragging it. This works on both X and Y-Axes. Clicking and dragging in the plotting area has a different functionality. A box will be drawn between where the mouse button was pressed and where it was released, and then the plot will zoom in to show the selected range.</p>"},{"location":"overview/plot_section/#time-span-buttons","title":"Time Span Buttons","text":"<p>Above the plotting section are a few buttons for quickly toggling between common time spans (30s, 1m, 1h, 1w, 1M). Clicking these will cause the plot to consistently update to show that time range. For instance, toggling the 1h button will result in the last hour of data being shown, and every 5 seconds the plot will shift to the right to update.</p>"},{"location":"overview/plot_section/#plot-settings","title":"Plot Settings","text":"<p>Users can change the settings of the plot using the settings button in the top left corner of the plot marked with a  icon. Clicking this button opens a pop-up window with controls over the plot's configuration such as background color, time-range, show gridlines, etc.</p>"},{"location":"reference/","title":"Developer Reference","text":"<p>Welcome to the Trace Developer Reference. This section provides comprehensive documentation for the internal Python modules, classes, and functions that make up the Trace application. Here you will find detailed descriptions of each component, including their parameters, return values, and usage examples.</p> <p>Use this reference to:</p> <ul> <li>Understand the structure and functionality of Trace\u2019s codebase</li> <li>Integrate or extend Trace with your own scripts or plugins</li> <li>Explore available widgets, file I/O utilities, and service modules</li> </ul> <p>Browse the subpages for specific modules and components. For guidance on using the application, see the user documentation in the main sections.</p>"},{"location":"reference/trace/","title":"Main","text":""},{"location":"reference/trace/#main.TraceDisplay","title":"<code>TraceDisplay(parent=None, args=None, macros=None)</code>","text":"<p>               Bases: <code>Display</code></p> <p>Main display widget for the Trace application.</p> <p>This class builds and manages the user interface, including the plot, control panel, menus, theme handling, and interactions such as file I/O and E-Log posting.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget, by default None.</p> <code>None</code> <code>args</code> <code>list[str] | None</code> <p>Command-line style arguments passed in by the host application.</p> <code>None</code> <code>macros</code> <code>dict | None</code> <p>PyDM-style macro substitutions that can influence startup behavior.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>This method initializes the widget in place.</p> Source code in <code>trace/main.py</code> <pre><code>def __init__(self, parent=None, args=None, macros=None) -&gt; None:\n    \"\"\"Initialize the Trace display and construct the UI.\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        The parent widget, by default None.\n    args : list[str] | None, optional\n        Command-line style arguments passed in by the host application.\n    macros : dict | None, optional\n        PyDM-style macro substitutions that can influence startup behavior.\n\n    Returns\n    -------\n    None\n        This method initializes the widget in place.\n    \"\"\"\n    super(TraceDisplay, self).__init__(parent=parent, args=args, macros=macros, ui_filename=None)\n\n    app = QApplication.instance()\n    if not app.main_window:\n        return\n\n    self.theme_manager = ThemeManager(\n        app,\n    )\n    settings = QSettings()\n    self.is_dark_mode = settings.value(\"isDarkTheme\", False, type=bool)\n    self.build_ui()\n    self.configure_app(app)\n    self.setup_icons()\n    self.resize(1000, 600)\n\n    # Set plot's timerange after the UI is built\n    default_button = self.timespan_buttons.button(3600)\n    default_button.setChecked(True)\n\n    input_file, startup_pvs = self.parse_cli_args(args, macros)\n    if input_file:\n        self.file_handler.open_file(input_file)\n    for pv in startup_pvs:\n        self.layout().itemAt(0).widget().widget(1).add_curve(pv)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.gridline_opacity","title":"<code>gridline_opacity</code>  <code>property</code>","text":"<p>Get the current gridline opacity value from the plot settings.</p> <p>Returns:</p> Type Description <code>int</code> <p>The alpha value (0-255) used for y-axis gridline opacity.</p>"},{"location":"reference/trace/#main.TraceDisplay.minimumSizeHint","title":"<code>minimumSizeHint()</code>","text":"<p>Return the minimum recommended size for the widget.</p> <p>Returns:</p> Type Description <code>QSize</code> <p>The minimum size hint used by Qt layouts.</p> Source code in <code>trace/main.py</code> <pre><code>def minimumSizeHint(self) -&gt; QSize:\n    \"\"\"Return the minimum recommended size for the widget.\n\n    Returns\n    -------\n    QSize\n        The minimum size hint used by Qt layouts.\n    \"\"\"\n    return QSize(700, 350)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.build_ui","title":"<code>build_ui()</code>","text":"<p>Set up the main UI for the application.</p> <p>Returns:</p> Type Description <code>None</code> <p>Constructs and lays out child widgets.</p> Source code in <code>trace/main.py</code> <pre><code>def build_ui(self) -&gt; None:\n    \"\"\"Set up the main UI for the application.\n\n    Returns\n    -------\n    None\n        Constructs and lays out child widgets.\n    \"\"\"\n    # Set window title\n    self.setWindowTitle(\"Trace\")\n    # Create main layout\n    main_layout = QVBoxLayout()\n    self.setLayout(main_layout)\n\n    # Create the plotting and control widgets\n    plot_side_widget = self.build_plot_side(self)\n    self.control_panel = ControlPanel(theme_manager=self.theme_manager)\n    self.control_panel.layout().setContentsMargins(8, 0, 0, 0)\n    self.control_panel.plot = self.plot\n    self.control_panel.curve_list_changed.connect(self.data_insight_tool.update_pv_select_box)\n\n    # Create main splitter\n    main_splitter = QSplitter(self)\n    main_splitter.addWidget(plot_side_widget)\n    main_splitter.addWidget(self.control_panel)\n    main_splitter.setCollapsible(0, False)\n    main_splitter.setStretchFactor(0, 1)\n    main_splitter.setHandleWidth(10)\n\n    main_layout.addWidget(main_splitter)\n\n    # Create the footer section of the app\n    footer_widget = self.build_footer(self)\n    main_layout.addWidget(footer_widget)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.build_plot_side","title":"<code>build_plot_side(parent)</code>","text":"<p>Build the plot side of the application, including the toolbar and plot widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the plot side.</p> required <p>Returns:</p> Type Description <code>QWidget</code> <p>Returns the plot side widget.</p> Source code in <code>trace/main.py</code> <pre><code>def build_plot_side(self, parent: QWidget) -&gt; QWidget:\n    \"\"\"Build the plot side of the application, including the toolbar\n    and plot widget.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget for the plot side.\n\n    Returns\n    -------\n    QWidget\n        Returns the plot side widget.\n    \"\"\"\n    plot_side_widget = QWidget(parent)\n    plot_side_layout = QVBoxLayout()\n    plot_side_layout.setContentsMargins(0, 0, 8, 0)\n    plot_side_widget.setLayout(plot_side_layout)\n\n    toolbar = self.build_toolbar(plot_side_widget)\n    plot_side_layout.addWidget(toolbar)\n\n    background_color = \"#1E1E1E\" if self.theme_manager.get_current_theme() == Theme.DARK else \"white\"\n\n    self.plot = PyDMArchiverTimePlot(\n        plot_side_widget,\n        background=background_color,\n        optimized_data_bins=5000,\n        cache_data=False,\n        show_all=False,\n    )\n\n    multi_axis_plot = self.plot.plotItem\n    multi_axis_plot.vb.menu = None\n    multi_axis_plot.sigXRangeChangedManually.connect(self.disable_auto_scroll_button.click)\n    plot_side_layout.addWidget(self.plot)\n\n    self.data_insight_tool = DataInsightTool(self)\n    self.data_insight_tool.plot = self.plot\n\n    self.settings_button = QPushButton(self.plot)\n    self.settings_button.setFlat(True)\n\n    self.plot_settings = PlotSettingsModal(self.settings_button, self.plot)\n    self.plot_settings.auto_scroll_interval_change.connect(self.set_auto_scroll_interval)\n    self.plot_settings.grid_alpha_change.connect(self.gridline_opacity_change.emit)\n    self.plot_settings.set_all_y_axis_gridlines.connect(self.plot.setShowYGrid)\n    self.plot_settings.set_all_y_axis_gridlines.connect(self.set_all_y_axis_gridlines.emit)\n    self.plot_settings.disable_autoscroll.connect(self.disable_auto_scroll_button.click)\n    self.plot_settings.sig_curve_palette_changed.connect(self.set_curve_palette)\n    self.settings_button.clicked.connect(self.plot_settings.show)\n\n    return plot_side_widget\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.build_toolbar","title":"<code>build_toolbar(parent)</code>","text":"<p>Build the toolbar for the plotting section of the application. This includes buttons for setting the autoscroll timespan.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the toolbar.</p> required <p>Returns:</p> Type Description <code>QWidget</code> <p>Returns the toolbar widget.</p> Source code in <code>trace/main.py</code> <pre><code>def build_toolbar(self, parent: QWidget) -&gt; QWidget:\n    \"\"\"Build the toolbar for the plotting section of the application. This\n    includes buttons for setting the autoscroll timespan.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget for the toolbar.\n\n    Returns\n    -------\n    QWidget\n        Returns the toolbar widget.\n    \"\"\"\n    toolbar_widget = QWidget(parent)\n    # Create tool layout\n    tool_layout = QHBoxLayout()\n    tool_layout.setContentsMargins(0, 0, 0, 0)\n    toolbar_widget.setLayout(tool_layout)\n\n    tool_spacer = QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)\n    tool_layout.addSpacerItem(tool_spacer)\n\n    timespan_buttons = self.build_timespan_buttons(toolbar_widget)\n    tool_layout.addWidget(timespan_buttons)\n\n    return toolbar_widget\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.build_timespan_buttons","title":"<code>build_timespan_buttons(parent)</code>","text":"<p>Build the timespan buttons for the toolbar. This includes buttons for users to set enable autoscrolling for various timespans.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the timespan buttons.</p> required <p>Returns:</p> Type Description <code>QWidget</code> <p>Returns the timespan buttons widget.</p> Source code in <code>trace/main.py</code> <pre><code>def build_timespan_buttons(self, parent: QWidget) -&gt; QWidget:\n    \"\"\"Build the timespan buttons for the toolbar. This includes buttons\n    for users to set enable autoscrolling for various timespans.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget for the timespan buttons.\n\n    Returns\n    -------\n    QWidget\n        Returns the timespan buttons widget.\n    \"\"\"\n    timespan_button_widget = QWidget(parent)\n    timespan_button_layout = QHBoxLayout()\n    timespan_button_layout.setContentsMargins(0, 0, 0, 0)\n    timespan_button_widget.setLayout(timespan_button_layout)\n\n    self.timespan_buttons = QButtonGroup(timespan_button_widget)\n    self.timespan_buttons.setExclusive(True)\n\n    timespan_button_data = (\n        (\"1m\", 60),\n        (\"1h\", 3600),\n        (\"1d\", 86400),\n        (\"1w\", 604800),\n        (\"1M\", 2628300),\n        (\"Disable AutoScroll\", DISABLE_AUTO_SCROLL),\n    )\n\n    for text, id in timespan_button_data:\n        timespan_button = QPushButton(text, timespan_button_widget)\n        timespan_button.setMaximumWidth(35)\n        timespan_button.setCheckable(True)\n        timespan_button_layout.addWidget(timespan_button)\n        self.timespan_buttons.addButton(timespan_button, id)\n\n    self.disable_auto_scroll_button = self.timespan_buttons.button(DISABLE_AUTO_SCROLL)\n    self.disable_auto_scroll_button.hide()\n\n    self.timespan_buttons.buttonToggled.connect(self.set_auto_scroll_span)\n\n    return timespan_button_widget\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.build_footer","title":"<code>build_footer(parent)</code>","text":"<p>Build the footer for the application. This displays the name of the server the application is running on, the archiver URL, and a timestamp PV.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget for the footer.</p> required <p>Returns:</p> Type Description <code>QWidget</code> <p>The footer widget to be added to a layout.</p> Source code in <code>trace/main.py</code> <pre><code>def build_footer(self, parent: QWidget) -&gt; QWidget:\n    \"\"\"Build the footer for the application. This displays the name\n    of the server the application is running on, the archiver URL,\n    and a timestamp PV.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget for the footer.\n\n    Returns\n    -------\n    QWidget\n        The footer widget to be added to a layout.\n    \"\"\"\n    self.footer_label_font = QFont()\n    self.footer_label_font.setPointSize(8)\n\n    footer_widget = QWidget(parent)\n    footer_widget.setFixedHeight(12)\n    footer_layout = QHBoxLayout()\n    footer_layout.setContentsMargins(0, 0, 0, 0)\n    footer_widget.setLayout(footer_layout)\n\n    # Left side of footer, with various info labels\n    self.footer_info_widget = QWidget(footer_widget)\n    footer_layout.addWidget(self.footer_info_widget)\n    footer_info_layout = QHBoxLayout(self.footer_info_widget)\n    footer_info_layout.setContentsMargins(0, 0, 0, 0)\n\n    footer_label_data = (\n        (gethostname(), \"Node Name\"),\n        (os.getenv(\"PYDM_ARCHIVER_URL\"), \"Archiver URL\"),\n    )\n\n    for text, tooltip in footer_label_data:\n        label = QLabel(text, self.footer_info_widget)\n        label.setFont(self.footer_label_font)\n        label.setToolTip(tooltip)\n        label.setAlignment(Qt.AlignBottom)\n        footer_info_layout.addWidget(label)\n        footer_info_layout.addWidget(BreakerLabel(self.footer_info_widget))\n\n    last_breaker = self.footer_info_widget.children()[-1]\n    footer_info_layout.removeWidget(last_breaker)\n\n    footer_spacer = QSpacerItem(40, 12, QSizePolicy.Expanding, QSizePolicy.Minimum)\n    footer_layout.addSpacerItem(footer_spacer)\n\n    self.time_label = PyDMLabel(footer_widget, f\"ca://{datetime_pv}\")\n    self.time_label.setAlignment(Qt.AlignBottom)\n    footer_layout.addWidget(self.time_label)\n\n    return footer_widget\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.set_file_indicator","title":"<code>set_file_indicator(file_path)</code>","text":"<p>Set the file indicator label to the given file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The file path to set the label to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Updates the footer to indicate the currently loaded file.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot(str)\ndef set_file_indicator(self, file_path: str) -&gt; None:\n    \"\"\"Set the file indicator label to the given file path.\n\n    Parameters\n    ----------\n    file_path : str\n        The file path to set the label to.\n\n    Returns\n    -------\n    None\n        Updates the footer to indicate the currently loaded file.\n    \"\"\"\n    if not file_path:\n        return\n    filename = os.path.basename(file_path)\n    if hasattr(self, \"file_label\") and self.file_label is not None:\n        self.file_label.setText(filename)\n    else:\n        self.footer_info_widget.layout().addWidget(BreakerLabel(self.footer_info_widget))\n        self.file_label = QLabel(filename, self.footer_info_widget)\n        self.file_label.setFont(self.footer_label_font)\n        self.file_label.setToolTip(\"Currently loaded file\")\n        self.footer_info_widget.layout().addWidget(self.file_label)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.setup_icons","title":"<code>setup_icons()</code>","text":"<p>Set up all icons after the theme manager is initialized.</p> <p>Returns:</p> Type Description <code>None</code> <p>Updates icon assets for current theme.</p> Source code in <code>trace/main.py</code> <pre><code>def setup_icons(self) -&gt; None:\n    \"\"\"Set up all icons after the theme manager is initialized.\n\n    Returns\n    -------\n    None\n        Updates icon assets for current theme.\n    \"\"\"\n    self.settings_button.setIcon(self.theme_manager.create_icon(\"msc.settings-gear\", IconColors.PRIMARY))\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.on_theme_changed","title":"<code>on_theme_changed(theme)</code>","text":"<p>Handle theme changes - update icons and button text</p> <p>Parameters:</p> Name Type Description Default <code>theme</code> <code>Theme</code> <p>The new theme that was set.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Applies UI updates relevant to the selected theme.</p> Source code in <code>trace/main.py</code> <pre><code>def on_theme_changed(self, theme: Theme) -&gt; None:\n    \"\"\"Handle theme changes - update icons and button text\n\n    Parameters\n    ----------\n    theme : Theme\n        The new theme that was set.\n\n    Returns\n    -------\n    None\n        Applies UI updates relevant to the selected theme.\n    \"\"\"\n    if theme == Theme.DARK:\n        self.theme_toggle_button.setText(\"Light Mode\")\n        icon = self.theme_manager.create_icon(\"fa.sun-o\", IconColors.PRIMARY)\n    else:\n        self.theme_toggle_button.setText(\"Dark Mode\")\n        icon = self.theme_manager.create_icon(\"fa.moon-o\", IconColors.PRIMARY)\n\n    if icon:\n        self.theme_toggle_button.setIcon(icon)\n\n    settings_icon = self.theme_manager.create_icon(\"msc.settings-gear\", IconColors.PRIMARY)\n    if settings_icon:\n        self.settings_button.setIcon(settings_icon)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.set_curve_palette","title":"<code>set_curve_palette(palette_name, apply=False)</code>","text":"<p>Set color palette for adding new curves</p> <p>Args:     palette_name (str): name of the selected palette, from trace/config.color_palette     apply (bool): boolean indicator of whether to apply palette to existing curves.</p> Source code in <code>trace/main.py</code> <pre><code>def set_curve_palette(self, palette_name: str, apply: bool = False):\n    \"\"\"\n    Set color palette for adding new curves\n\n    Args:\n        palette_name (str): name of the selected palette, from trace/config.color_palette\n        apply (bool): boolean indicator of whether to apply palette to existing curves.\n    \"\"\"\n    self.control_panel.set_curve_palette(palette_name=palette_name, apply=apply)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.configure_app","title":"<code>configure_app(app)</code>","text":"<p>UI changes to be made to the PyDMApplication. Hides navigation &amp; status bars, sets up file IO, sets up shortcuts &amp; menus.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>QApplication</code> <p>The instance of the QApplication.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Applies application-wide configuration.</p> Source code in <code>trace/main.py</code> <pre><code>def configure_app(self, app: QApplication) -&gt; None:\n    \"\"\"UI changes to be made to the PyDMApplication. Hides navigation\n    &amp; status bars, sets up file IO, sets up shortcuts &amp; menus.\n\n    Parameters\n    ----------\n    app : QApplication\n        The instance of the QApplication.\n\n    Returns\n    -------\n    None\n        Applies application-wide configuration.\n    \"\"\"\n    # Hide navigation bar by default (can be shown in menu bar)\n    app.main_window.toggle_nav_bar(False)\n    app.main_window.ui.actionShow_Navigation_Bar.setChecked(False)\n\n    # Hide status bar by default (can be shown in menu bar)\n    app.main_window.toggle_status_bar(False)\n    app.main_window.ui.actionShow_Status_Bar.setChecked(False)\n\n    # Create a TraceFileController instance for handling file I/O operations\n    self.file_handler = TraceFileHandler(self.plot, self)\n    self.file_handler.axes_signal.connect(self.control_panel.set_axes)\n    self.file_handler.curves_signal.connect(self.control_panel.set_curves)\n    self.file_handler.plot_settings_signal.connect(self.plot_settings.plot_setup)\n    self.file_handler.auto_scroll_span_signal.connect(self.set_auto_scroll_span)\n    self.file_handler.timerange_signal.connect(self.set_plot_timerange)\n    self.file_handler.file_loaded_signal.connect(self.set_file_indicator)\n\n    # Remove shortcut from the \"Open File\" menu action\n    open_file_action = app.main_window.ui.actionOpen_File\n    open_file_action.setText(\"Open PyDM File...\")\n    open_file_action.setShortcut(QKeySequence())\n\n    # Create a custom menu for the application\n    menu_bar: QMenuBar = app.main_window.ui.menubar\n    first_menu = app.main_window.ui.menuFile.menuAction()\n    trace_menu = self.construct_trace_menu(menu_bar)\n    menu_bar.insertMenu(first_menu, trace_menu)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.construct_trace_menu","title":"<code>construct_trace_menu(parent)</code>","text":"<p>Create the menu for the application. This includes actions for file IO, saving to the E-Log, opening tools, and setting the app theme.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QMenuBar</code> <p>The menu bar that the Trace menu will be a part of.</p> required <p>Returns:</p> Type Description <code>QMenu</code> <p>The Trace menu consisting of actions for configuring the app.</p> Source code in <code>trace/main.py</code> <pre><code>def construct_trace_menu(self, parent: QMenuBar) -&gt; QMenu:\n    \"\"\"Create the menu for the application. This includes actions for\n    file IO, saving to the E-Log, opening tools, and setting the app theme.\n\n    Parameters\n    ----------\n    parent : QMenuBar\n        The menu bar that the Trace menu will be a part of.\n\n    Returns\n    -------\n    QMenu\n        The Trace menu consisting of actions for configuring the app.\n    \"\"\"\n    menu = QMenu(\"Trace\", parent)\n    save = menu.addAction(\"Save\", self.file_handler.save_file)\n    save.setShortcut(QKeySequence(\"Ctrl+S\"))\n    save_as = menu.addAction(\"Save As...\", self.file_handler.save_as)\n    save_as.setShortcut(QKeySequence(\"Ctrl+Shift+S\"))\n    load = menu.addAction(\"Open Trace Config...\", self.file_handler.open_file)\n    load.setShortcut(QKeySequence(\"Ctrl+O\"))\n    menu.addSeparator()\n\n    save_image = menu.addAction(\"Save Plot Image...\", self.save_plot_image)\n    save_image.setShortcut(QKeySequence(\"Ctrl+I\"))\n    save_elog = menu.addAction(\"Save ELOG Entry...\", self.elog_button_clicked)\n    save_elog.setShortcut(QKeySequence(\"Ctrl+E\"))\n    menu.addSeparator()\n\n    fetch_archive = menu.addAction(\"Fetch Archive Data\", self.fetch_archive)\n    fetch_archive.setShortcut(QKeySequence(\"Ctrl+F\"))\n    dit_action = menu.addAction(\"Data Insight Tool...\", self.data_insight_tool.show)\n    dit_action.setShortcut(QKeySequence(\"Ctrl+D\"))\n\n    menu.addSeparator()\n\n    if self.is_dark_mode:\n        self.theme_action = menu.addAction(\"Switch to Light Mode\", self.toggle_theme)\n    else:\n        self.theme_action = menu.addAction(\"Switch to Dark Mode\", self.toggle_theme)\n\n    self.theme_action.setShortcut(QKeySequence(\"Ctrl+T\"))\n\n    return menu\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.toggle_theme","title":"<code>toggle_theme()</code>","text":"<p>Toggle between dark and light mode.</p> <p>Returns:</p> Type Description <code>None</code> <p>Applies the selected theme and refreshes the UI.</p> Source code in <code>trace/main.py</code> <pre><code>def toggle_theme(self):\n    \"\"\"Toggle between dark and light mode.\n\n    Returns\n    -------\n    None\n        Applies the selected theme and refreshes the UI.\n    \"\"\"\n    if self.is_dark_mode:\n        self.theme_manager.set_theme(Theme.LIGHT)\n        self.theme_action.setText(\"Switch to Dark Mode\")\n        self.plot.setBackgroundColor(QColor(\"#FFFFFF\"))\n        self.setup_icons()\n        self.is_dark_mode = False\n    else:\n        self.theme_manager.set_theme(Theme.DARK)\n        self.theme_action.setText(\"Switch to Light Mode\")\n        self.plot.setBackgroundColor(QColor(\"#1E1E1E\"))\n        self.setup_icons()\n        self.is_dark_mode = True\n\n    QApplication.processEvents()\n    self.repaint()\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.save_plot_image","title":"<code>save_plot_image()</code>","text":"<p>Saves current plot as an image. Opens file dialog to allow user to set custom location.</p> <p>Returns:</p> Type Description <code>None</code> <p>Writes the exported image to disk when a path is selected.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot()\ndef save_plot_image(self) -&gt; None:\n    \"\"\"Saves current plot as an image. Opens file dialog to allow user to\n    set custom location.\n\n    Returns\n    -------\n    None\n        Writes the exported image to disk when a path is selected.\n    \"\"\"\n    exporter = ImageExporter(self.plot.plotItem)\n    default_filename = datetime.now().strftime(f\"{getuser()}_trace_%Y%m%d_%H%M%S.png\")\n    usr_home_dir = os.path.expanduser(\"~\")\n    file_path, _ = QFileDialog.getSaveFileName(\n        None,\n        \"Save Plot Image\",\n        os.path.join(usr_home_dir, default_filename),\n        \"PNG Files (*.png);;JPEG Files (*.jpg);;All Files (*)\",\n    )\n    if file_path:\n        try:\n            exporter.export(file_path)\n            logger.info(f\"Saved image file to: {file_path}\")\n        except Exception as e:\n            logger.error(f\"Failed to save image: {e}\")\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.elog_button_clicked","title":"<code>elog_button_clicked()</code>","text":"<p>Takes a snapshot of the plot and posts it to the Elog API.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the post was successful, False otherwise.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot()\ndef elog_button_clicked(self) -&gt; bool:\n    \"\"\"Takes a snapshot of the plot and posts it to the Elog API.\n\n    Returns\n    -------\n    bool\n        True if the post was successful, False otherwise.\n    \"\"\"\n    # Test if API is reachable\n    status_code, _ = get_user()\n    if status_code != 200:\n        error_dialog = QMessageBox()\n        error_dialog.setIcon(QMessageBox.Warning)\n        error_dialog.setWindowTitle(\"Connection Error\")\n        error_dialog.setText(\"Failed to connect to the Elog API.\")\n        error_dialog.setInformativeText(\n            f\"\"\"No entry was posted. If this issue persists, please report it in the\n            #elog-general Slack channel. \\n\\nError Code: {status_code}\"\"\"\n        )\n        error_dialog.setStandardButtons(QMessageBox.Ok)\n        error_dialog.exec_()\n        return False\n\n    # Form the request info\n    # Use ImageExporter to take a snapshot of the plot\n    exporter = ImageExporter(self.plot.plotItem)\n    img: QImage = exporter.export(toBytes=True)\n    # Convert Qimage to bytes\n    buffer = QBuffer()\n    buffer.open(QIODevice.ReadWrite)\n    img.save(buffer, \"PNG\")\n    image_bytes = buffer.data()\n    # Get entry info from user\n    dialog = ElogPostModal.maybe_create(self, image_bytes=image_bytes)\n    if dialog is not None and dialog.exec_() == QDialog.Accepted:\n        title, body, logbooks, attach_config = dialog.get_inputs()\n    else:\n        return False\n\n    config_file_path = None\n    if attach_config:\n        self.file_handler.save_file()\n        config_file_path = self.file_handler.current_file\n\n    # Post the request to the Elog API\n    status_code, _ = post_entry(title, body, logbooks, image_bytes, config_file_path)\n\n    # Check if the request was successful\n    if status_code == 201:\n        success_dialog = QMessageBox()\n        success_dialog.setIcon(QMessageBox.Information)\n        success_dialog.setWindowTitle(\"Elog Entry Posted\")\n        success_dialog.setText(\"Elog entry posted successfully!\")\n        success_dialog.setStandardButtons(QMessageBox.Ok)\n        success_dialog.exec_()\n        return True\n    else:\n        error_dialog = QMessageBox()\n        error_dialog.setIcon(QMessageBox.Warning)\n        error_dialog.setWindowTitle(\"Connection Error\")\n        error_dialog.setText(\"Failed to connect to the Elog API.\")\n        error_dialog.setInformativeText(\n            f\"No entry was posted. If this issue persists, please report it in the \\\n            #elog-general Slack channel. \\n\\nError Code: {status_code}\"\n        )\n        error_dialog.setStandardButtons(QMessageBox.Ok)\n        error_dialog.exec_()\n        return False\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.fetch_archive","title":"<code>fetch_archive()</code>","text":"<p>Trigger a fetch of data from the EPICS Archiver Appliance.</p> <p>Returns:</p> Type Description <code>None</code> <p>Queues a data request if one is not already pending.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot()\ndef fetch_archive(self) -&gt; None:\n    \"\"\"Trigger a fetch of data from the EPICS Archiver Appliance.\n\n    Returns\n    -------\n    None\n        Queues a data request if one is not already pending.\n    \"\"\"\n    if not (self.plot._archive_request_queued):\n        logger.info(\"Requesting data from archiver\")\n        self.plot.requestDataFromArchiver()\n    else:\n        logger.info(\"Archive fetch is already queued\")\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.set_plot_timerange","title":"<code>set_plot_timerange(timerange)</code>","text":"<p>Set the plot's timerange to the given start and end datetimes.</p> <p>Parameters:</p> Name Type Description Default <code>timerange</code> <code>tuple[float, float]</code> <p>The new time range for the plot to show. Index 0 is the timestamp on the left side of the plot, index 1 on the right.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Sets the x-axis view range of the plot.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot(tuple)\ndef set_plot_timerange(self, timerange: tuple[float, float]) -&gt; None:\n    \"\"\"Set the plot's timerange to the given start and end datetimes.\n\n    Parameters\n    ----------\n    timerange : tuple[float, float]\n        The new time range for the plot to show. Index 0 is the\n        timestamp on the left side of the plot, index 1 on the right.\n\n    Returns\n    -------\n    None\n        Sets the x-axis view range of the plot.\n    \"\"\"\n    self.disable_auto_scroll_button.click()\n    self.plot.setXRange(*timerange)\n    logger.debug(f\"Plot timerange set to {timerange[0]} - {timerange[1]}\")\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.set_auto_scroll_span","title":"<code>set_auto_scroll_span(arg1=None, arg2=None)</code>","text":"<p>Update the auto-scroll timespan based on UI interaction or input.</p> <p>This enables autoscrolling of the x-axis for the selected span and disables manual mouse controls. When the special \"Disable AutoScroll\" button is selected, autoscrolling is turned off and mouse controls are re-enabled.</p> <p>Parameters:</p> Name Type Description Default <code>arg1</code> <code>QAbstractButton | float | int | None</code> <p>The toggled timespan button or an explicit timespan value in seconds. If None, the currently checked button is used.</p> <code>None</code> <code>arg2</code> <code>float | None</code> <p>The checked state flag passed by Qt when connected to a button toggled signal; ignored unless <code>arg1</code> is a button.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Applies the autoscroll configuration to the plot.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot()\n@Slot(float)\n@Slot(QAbstractButton, float)\ndef set_auto_scroll_span(self, arg1=None, arg2=None) -&gt; None:\n    \"\"\"Update the auto-scroll timespan based on UI interaction or input.\n\n    This enables autoscrolling of the x-axis for the selected span and\n    disables manual mouse controls. When the special \"Disable AutoScroll\"\n    button is selected, autoscrolling is turned off and mouse controls are\n    re-enabled.\n\n    Parameters\n    ----------\n    arg1 : QAbstractButton | float | int | None, optional\n        The toggled timespan button or an explicit timespan value in\n        seconds. If None, the currently checked button is used.\n    arg2 : float | None, optional\n        The checked state flag passed by Qt when connected to a button\n        toggled signal; ignored unless `arg1` is a button.\n\n    Returns\n    -------\n    None\n        Applies the autoscroll configuration to the plot.\n    \"\"\"\n    if isinstance(arg1, QAbstractButton):\n        if not arg2:\n            return\n        timespan = self.timespan_buttons.id(arg1)\n    elif isinstance(arg1, (int, float)):\n        timespan = arg1\n    else:\n        timespan = self.timespan_buttons.checkedId()\n\n    enable_scroll = timespan != DISABLE_AUTO_SCROLL\n\n    if enable_scroll:\n        logger.debug(f\"Enabling plot autoscroll for {timespan}s\")\n    else:\n        logger.debug(\"Disabling plot autoscroll, using mouse controls\")\n        self.disable_auto_scroll_button.click()\n\n    self.autoScroll(enable=enable_scroll, timespan=timespan)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.set_auto_scroll_interval","title":"<code>set_auto_scroll_interval(inteval)</code>","text":"<p>Set the auto-scroll refresh interval for the plot.</p> <p>Parameters:</p> Name Type Description Default <code>inteval</code> <code>int</code> <p>The refresh interval in milliseconds.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Updates the plot's autoscroll refresh rate.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot(int)\ndef set_auto_scroll_interval(self, inteval: int) -&gt; None:\n    \"\"\"Set the auto-scroll refresh interval for the plot.\n\n    Parameters\n    ----------\n    inteval : int\n        The refresh interval in milliseconds.\n\n    Returns\n    -------\n    None\n        Updates the plot's autoscroll refresh rate.\n    \"\"\"\n    timespan = self.timespan_buttons.checkedId()\n    enable_scroll = timespan != DISABLE_AUTO_SCROLL\n\n    self.plot.setAutoScroll(enable_scroll, timespan, refresh_rate=inteval)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.autoScroll","title":"<code>autoScroll(enable, timespan=None)</code>","text":"<p>Enable or disable autoscroll, optionally specifying a timespan.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether autoscroll should be enabled.</p> required <code>timespan</code> <code>float | None</code> <p>The x-axis span, in seconds, to keep visible while autoscrolling. If None, uses the currently selected timespan button.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Configures autoscroll on the underlying plot widget.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot(bool)\n@Slot(bool, float)\ndef autoScroll(self, enable: bool, timespan: float = None):\n    \"\"\"Enable or disable autoscroll, optionally specifying a timespan.\n\n    Parameters\n    ----------\n    enable : bool\n        Whether autoscroll should be enabled.\n    timespan : float | None, optional\n        The x-axis span, in seconds, to keep visible while autoscrolling.\n        If None, uses the currently selected timespan button.\n\n    Returns\n    -------\n    None\n        Configures autoscroll on the underlying plot widget.\n    \"\"\"\n    if timespan is None:\n        timespan = self.timespan_buttons.checkedId()\n        if timespan &lt; 0:\n            return\n\n    refresh_interval = self.plot_settings.auto_scroll_interval\n    self.plot.setAutoScroll(enable, timespan, refresh_rate=refresh_interval)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.git_version","title":"<code>git_version()</code>  <code>staticmethod</code>","text":"<p>Get the current git tag for the project.</p> <p>Returns:</p> Type Description <code>str</code> <p>The output of <code>git describe --tags</code>, or an empty string on failure.</p> Source code in <code>trace/main.py</code> <pre><code>@staticmethod\ndef git_version():\n    \"\"\"Get the current git tag for the project.\n\n    Returns\n    -------\n    str\n        The output of `git describe --tags`, or an empty string on failure.\n    \"\"\"\n    project_directory = __file__.rsplit(\"/\", 1)[0]\n    git_cmd = subprocess.run(\n        f\"cd {project_directory} &amp;&amp; git describe --tags\", text=True, shell=True, capture_output=True\n    )\n    return git_cmd.stdout.strip()\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.parse_cli_args","title":"<code>parse_cli_args(args, macros)</code>","text":"<p>Parse CLI-style arguments and macros into startup configuration.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Argument vector to parse. Unknown options are ignored.</p> required <code>macros</code> <code>dict | None</code> <p>PyDM-style macro substitutions. Values for <code>INPUT_FILE</code>, <code>PV</code>, or <code>PVS</code> here are merged with CLI options.</p> required <p>Returns:</p> Type Description <code>tuple[str, list[str]]</code> <p>A tuple of <code>(input_file, startup_pvs)</code> where <code>input_file</code> is the selected configuration file path (or empty string) and <code>startup_pvs</code> is a de-duplicated list of PV/formula strings to add.</p> Source code in <code>trace/main.py</code> <pre><code>def parse_cli_args(self, args, macros):\n    \"\"\"Parse CLI-style arguments and macros into startup configuration.\n\n    Parameters\n    ----------\n    args : list[str] | None\n        Argument vector to parse. Unknown options are ignored.\n    macros : dict | None\n        PyDM-style macro substitutions. Values for `INPUT_FILE`, `PV`, or\n        `PVS` here are merged with CLI options.\n\n    Returns\n    -------\n    tuple[str, list[str]]\n        A tuple of `(input_file, startup_pvs)` where `input_file` is the\n        selected configuration file path (or empty string) and\n        `startup_pvs` is a de-duplicated list of PV/formula strings to add.\n    \"\"\"\n    args = args or []\n    macros = macros or {}\n\n    parser = argparse.ArgumentParser(\n        prog=\"trace\",\n        description=\"Trace\\nThis is a PyDM application used to display archived and live pv data.\",\n        epilog=\"\\n\\t\".join(\n            [\n                \"Examples:\",\n                \"pydm $PHYSICS_TOP/trace/main.py\"\n                \"bash $PHYSICS_TOP/trace/launch_trace.bash\"\n                \"%(prog)s\"\n                \"%(prog)s -i some_input_file.trc\"\n                \"%(prog)s -p SOME:PV:TO:PLOT OTHER:PV:TO:PLOT\"\n                '%(prog)s -m \\'{\"PVS\": [\"FOO:CHANNEL\", \"BAR:CHANNEL\", \"f://{A}+{B}\"]}\\''\n                '%(prog)s -m \"INPUT_FILE = trace/examples/FormulaExample.trc\"',\n            ]\n        ),\n        formatter_class=argparse.RawTextHelpFormatter,\n    )\n\n    parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s \" + self.git_version())\n    parser.add_argument(\n        \"-i\",\n        \"--input_file\",\n        action=PathAction,\n        nargs=\"?\",\n        default=[],\n        help=\"Absolute file path to import from\\nAlternatively can be provided as INPUT_FILE macro\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--pvs\",\n        nargs=\"*\",\n        default=[],\n        help=\"\\n\".join(\n            [\n                \"Space-separated list of PVs to show on startup\",\n                \"Formulas should be passed without spaces: f://{A}+{B}\",\n                \"Alternatively can be provided as PV or PVS macros\",\n            ]\n        ),\n    )\n    parser.add_argument(\n        \"-m\",\n        \"--macro\",\n        default=\"\",\n        help=\"\\n\\t\".join(\n            [\n                \"Mimic PyDM macro replacements to use. Should be in JSON object format.\",\n                \"ON Formatting Reminder:\",\n                \"JSON requires double quotes for strings, so you should wrap this\",\n                \"whole argument in single quotes.\",\n                \"--or--\",\n                \"Specify macro replacements as KEY=value pairs using a comma as a\",\n                \"delimiter. If you want to uses spaces after the delimiters or around\",\n                \"the '=' signs, wrap the entire set with quotes.\",\n            ]\n        ),\n    )\n\n    # Parse arguments and ignore unknowns\n    known, unknown = parser.parse_known_args(args)\n    for arg in unknown:\n        if arg:\n            logger.warning(f\"Not using unknown argument: {arg}\")\n\n    # Parse any macros passed into trace\n    if known.macro:\n        parsed_macros = parse_macro_string(known.macro)\n        macros.update(**parsed_macros)\n\n    # Get the file to import from if one is provided. Prioritize args over macro\n    try:\n        # Need to unpack as PathAction returns a list\n        input_file = known.input_file[0]\n    except IndexError:\n        input_file = macros.get(\"INPUT_FILE\", \"\")\n\n    # Get the list of PVs to show on startup\n    startup_pvs = []\n    for key in (\"PV\", \"PVS\"):\n        if key in macros:\n            val = macros[key]\n            if isinstance(val, str):\n                startup_pvs.append(val)\n            elif isinstance(val, list):\n                startup_pvs.extend(val)\n    startup_pvs += known.pvs\n\n    # Remove duplicates from startup_pvs\n    startup_pvs = list(dict.fromkeys(startup_pvs))\n\n    return (input_file, startup_pvs)\n</code></pre>"},{"location":"reference/trace/#main.BreakerLabel","title":"<code>BreakerLabel(parent)</code>","text":"<p>               Bases: <code>QLabel</code></p> <p>A simple visual separator label used in the footer area.</p> <p>Displays a bold vertical bar character to separate adjacent labels.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget that will own this label.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Initializes the label and applies styling.</p> Source code in <code>trace/main.py</code> <pre><code>def __init__(self, parent):\n    \"\"\"Create a breaker label.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget that will own this label.\n\n    Returns\n    -------\n    None\n        Initializes the label and applies styling.\n    \"\"\"\n    super().__init__(parent)\n    self.setText(\"|\")\n    self.setFont(self.breaker_font)\n    self.setAlignment(Qt.AlignBottom)\n</code></pre>"},{"location":"reference/file_io/file_handler/","title":"File Handler","text":""},{"location":"reference/file_io/file_handler/#file_io.file_handler.TraceFileHandler","title":"<code>TraceFileHandler(plot, parent=None)</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Manage import/export of Trace save files and update the plot/UI.</p> <p>This QObject coordinates file dialogs, format conversion, and plot updates for Trace configuration files. It uses <code>TraceFileConverter</code> to read and write various supported formats (<code>.trc</code> native, <code>.xml</code> from Java Archive Viewer, and <code>.stp</code> from StripTool), validates the archiver URL, parses time ranges via <code>IOTimeParser</code>, and emits signals that other components consume to update axes, curves, plot settings, and the x-axis range.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>PyDMArchiverTimePlot</code> <p>Target plot whose configuration and data are exported/imported.</p> required <code>parent</code> <code>QObject | None</code> <p>Parent QObject for Qt ownership, by default None.</p> <code>None</code> Source code in <code>trace/file_io/file_handler.py</code> <pre><code>def __init__(self, plot: PyDMArchiverTimePlot, parent=None):\n    \"\"\"Initialize the File IO Manager, which is responsible for managing\n    the import and export of Trace save files\n\n    Parameters\n    ----------\n    plot : PyDMArchiverTimePlot\n        Target plot whose configuration and data are exported/imported.\n    parent : QObject | None, optional\n        Parent QObject for Qt ownership, by default None.\n    \"\"\"\n    super().__init__(parent)\n    self.plot = plot\n    self.current_file = None\n    self.current_dir = save_file_dir\n    self.converter = TraceFileConverter()\n</code></pre>"},{"location":"reference/file_io/file_handler/#file_io.file_handler.TraceFileHandler.save_file","title":"<code>save_file()</code>","text":"<p>Export the current plot data to the current file</p> Source code in <code>trace/file_io/file_handler.py</code> <pre><code>@Slot()\ndef save_file(self) -&gt; None:\n    \"\"\"Export the current plot data to the current file\"\"\"\n    if self.current_file is None:\n        logger.debug(\"No current file set, prompting for save location\")\n        self.save_as()\n        return\n    elif not self.current_file.match(\"*.trc\"):\n        self.current_file = self.current_file.with_suffix(\".trc\")\n\n    try:\n        logger.debug(f\"Attempting to export to file: {self.current_file}\")\n        self.converter.export_file(self.current_file, self.plot)\n    except FileNotFoundError as e:\n        logger.error(str(e))\n        self.save_as()\n</code></pre>"},{"location":"reference/file_io/file_handler/#file_io.file_handler.TraceFileHandler.save_as","title":"<code>save_as()</code>","text":"<p>Prompt the user for a file to export config data to</p> Source code in <code>trace/file_io/file_handler.py</code> <pre><code>@Slot()\ndef save_as(self) -&gt; None:\n    \"\"\"Prompt the user for a file to export config data to\"\"\"\n    file_name, _ = QFileDialog.getSaveFileName(\n        self.parent(), \"Save Trace\", str(self.current_dir), \"Trace Save File (*.trc)\"\n    )\n    file_path = Path(file_name)\n    if file_path.is_dir():\n        logger.warning(\"No file name provided to export save file to\")\n        return\n\n    self.current_file = file_path\n    self.current_dir = file_path.parent\n\n    self.save_file()\n</code></pre>"},{"location":"reference/file_io/file_handler/#file_io.file_handler.TraceFileHandler.open_file","title":"<code>open_file(file_name=None)</code>","text":"<p>Prompt the user for which config file to load from</p> Source code in <code>trace/file_io/file_handler.py</code> <pre><code>@Slot()\n@Slot(str)\n@Slot(Path)\ndef open_file(self, file_name: str | Path = None) -&gt; None:\n    \"\"\"Prompt the user for which config file to load from\"\"\"\n    # Get the save file from the user\n    if not file_name:\n        file_name, _ = QFileDialog.getOpenFileName(\n            self.parent(),\n            \"Open Trace\",\n            str(self.current_dir),\n            \"Trace Save File (*.trc *.xml *.stp);;Java Archive Viewer (*.xml);;\"\n            + \"StripTool File (*.stp);;All Files (*)\",\n        )\n    file_path = Path(file_name)\n    if not file_path.is_file():\n        logger.warning(f\"Attempted import is not a file: {file_path}\")\n        return\n\n    # Import the given file, and convert it from Java Archive Viewer's\n    # format to Trace's format if necessary\n    try:\n        logger.debug(f\"Attempting to import file: {file_path}\")\n        file_data = self.converter.import_file(file_path)\n        self.current_file = file_path\n        self.current_dir = file_path.parent\n        logger.info(f\"Successfully loaded file: {file_path}\")\n    except (FileNotFoundError, ValueError) as e:\n        logger.error(str(e))\n        self.open_file()\n        return\n\n    # Confirm the PYDM_ARCHIVER_URL is the same as the imported Archiver URL\n    # If they are not the same, prompt the user to confirm continuing\n    import_url = urlparse(file_data[\"archiver_url\"])\n    archiver_url = urlparse(getenv(\"PYDM_ARCHIVER_URL\"))\n    if import_url.hostname != archiver_url.hostname:\n        logger.warning(f\"Attempting to import save file using different Archiver URL: {import_url.hostname}\")\n        ret = QMessageBox.warning(\n            self.parent(),\n            \"Import Error\",\n            \"The config file you tried to open reads from a different archiver.\\n\"\n            f\"\\nCurrent archiver is:\\n{archiver_url.hostname}\\n\"\n            f\"\\nAttempted import uses:\\n{import_url.hostname}\\n\\n\"\n            \"\\nContinue?\",\n            QMessageBox.Yes | QMessageBox.No,\n            QMessageBox.No,\n        )\n        if ret == QMessageBox.No:\n            return\n\n    # Parse the time range for the X-Axis; check validity before prompting changes\n    try:\n        start_str = file_data[\"time_axis\"][\"start\"]\n        end_str = file_data[\"time_axis\"][\"end\"]\n        start_dt, end_dt = IOTimeParser.parse_times(start_str, end_str)\n        logger.debug(f\"Starting time: {start_dt}\")\n        logger.debug(f\"Ending time: {end_dt}\")\n    except ValueError as e:\n        logger.error(str(e))\n        self.open_file()\n        return\n\n    # Prompt a change to the plot's axes, curves, and settings\n    self.axes_signal.emit(file_data[\"y-axes\"])\n    self.curves_signal.emit(file_data[\"curves\"] + file_data[\"formula\"])\n    self.plot_settings_signal.emit(file_data[\"plot\"])\n    self.file_loaded_signal.emit(file_path)\n\n    # Prompt a change to the X-axis timerange\n    if end_str == \"now\":\n        delta = end_dt - start_dt\n        timespan = delta.total_seconds()\n        self.auto_scroll_span_signal.emit(timespan)\n    else:\n        x_range = (start_dt.timestamp(), end_dt.timestamp())\n        self.timerange_signal.emit(x_range)\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/","title":"Trace File Converter","text":""},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter","title":"<code>TraceFileConverter(input_file='', output_file='')</code>","text":"<p>Converter class that will convert save files for the Java-based Archive Viewer into a format readable by the Trace application. This class can also be used for importing data into Trace or exporting data from it.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str | Path</code> <p>Path to the file to import/convert. Can be set later via <code>import_file</code>. Defaults to an empty string (unset).</p> <code>''</code> <code>output_file</code> <code>str | Path</code> <p>Path to the destination Trace file for export. Can be set later via <code>export_file</code>. Defaults to an empty string (unset).</p> <code>''</code> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def __init__(self, input_file: str | Path = \"\", output_file: str | Path = \"\") -&gt; None:\n    \"\"\"Initialize a new converter with optional input and output files.\n\n    Parameters\n    ----------\n    input_file : str | pathlib.Path, optional\n        Path to the file to import/convert. Can be set later via\n        `import_file`. Defaults to an empty string (unset).\n    output_file : str | pathlib.Path, optional\n        Path to the destination Trace file for export. Can be set later via\n        `export_file`. Defaults to an empty string (unset).\n    \"\"\"\n    self.input_file = input_file\n    self.output_file = output_file\n\n    self.stored_data = None\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.import_is_xml","title":"<code>import_is_xml()</code>","text":"<p>Helper function to determine if the import file is in XML format.</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def import_is_xml(self):\n    \"\"\"Helper function to determine if the import file is in XML format.\"\"\"\n    with self.input_file.open() as f:\n        return f.readline().startswith(\"&lt;?xml\")\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.import_is_stp","title":"<code>import_is_stp()</code>","text":"<p>Helper function to determine if the import file is a StripTool file.</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def import_is_stp(self):\n    \"\"\"Helper function to determine if the import file is a StripTool file.\"\"\"\n    with self.input_file.open() as f:\n        return f.readline().startswith(\"StripConfig\")\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.import_file","title":"<code>import_file(file_name=None)</code>","text":"<p>Import Archive Viewer save data from the provided file. The file should be one of two types: '.trc' or '.xml'. The data is returned as well as saved in the stored_data property.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str or Path</code> <p>The absolute filepath for the input file to import</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A python dictionaty containing the data imported from the provided file</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def import_file(self, file_name: str | Path = None) -&gt; dict:\n    \"\"\"Import Archive Viewer save data from the provided file. The file\n    should be one of two types: '.trc' or '.xml'. The data is returned as\n    well as saved in the stored_data property.\n\n    Parameters\n    ----------\n    file_name : str or pathlib.Path\n        The absolute filepath for the input file to import\n\n    Returns\n    -------\n    dict\n        A python dictionaty containing the data imported from the provided file\n    \"\"\"\n    if file_name:\n        self.input_file = Path(file_name)\n    if not self.input_file.is_file():\n        raise FileNotFoundError(f\"Data file not found: {self.input_file}\")\n\n    text = self.input_file.read_text()\n    if self.import_is_xml():\n        etree = ET.ElementTree(ET.fromstring(text))\n        self.stored_data = self.xml_to_dict(etree)\n        self.stored_data = self.convert_xml_data(self.stored_data)\n    elif self.import_is_stp():\n        self.stored_data = self.stp_to_dict(text)\n        self.stored_data = self.convert_stp_data(self.stored_data)\n    else:\n        self.stored_data = json.loads(text)\n\n    if not self.stored_data[\"curves\"]:\n        raise ValueError(f\"Incorrect input file format: {self.input_file}\")\n\n    return self.stored_data\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.export_file","title":"<code>export_file(file_name=None, output_data=None)</code>","text":"<p>Export the provided Archive Viewer save data to the provided file. The file to export to should be of type '.trc'. The provided data can be either a dictionary or a PyDMTimePlot object. If no data is provided, then the converter's previously imported data is exported.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str or Path</code> <p>The absolute file path of the file that save data should be written to. Should be of file type '.trc'.</p> <code>None</code> <code>output_data</code> <code>dict or PyDMTimePlot</code> <p>The data that should be exported, by default uses previously imported data</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the provided file name does not match the expected output file type '.trc'</p> <code>ValueError</code> <p>If no output data is provided and the converter hasn't imported data previously</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def export_file(self, file_name: str | Path = None, output_data: dict | PyDMTimePlot = None) -&gt; None:\n    \"\"\"Export the provided Archive Viewer save data to the provided file.\n    The file to export to should be of type '.trc'. The provided data can\n    be either a dictionary or a PyDMTimePlot object. If no data is provided,\n    then the converter's previously imported data is exported.\n\n    Parameters\n    ----------\n    file_name : str or pathlib.Path\n        The absolute file path of the file that save data should be written\n        to. Should be of file type '.trc'.\n    output_data : dict or PyDMTimePlot, optional\n        The data that should be exported, by default uses previously imported data\n\n    Raises\n    ------\n    FileNotFoundError\n        If the provided file name does not match the expected output file type '.trc'\n    ValueError\n        If no output data is provided and the converter hasn't imported data previously\n    \"\"\"\n    if file_name:\n        self.output_file = Path(file_name)\n    if not self.output_file.suffix:\n        self.output_file = self.output_file.with_suffix(\".trc\")\n    elif not self.output_file.match(\"*.trc\"):\n        raise FileNotFoundError(f\"Incorrect output file format: {self.output_file.suffix}\")\n\n    if not output_data:\n        if not self.stored_data:\n            raise ValueError(\n                \"Output data is required but was not provided and the 'stored_data' property is not populated.\"\n            )\n        output_data = self.stored_data\n    elif isinstance(output_data, PyDMTimePlot):\n        output_data = self.get_plot_data(output_data)\n\n    output_data = self.remove_null_values(output_data)\n\n    with open(self.output_file, \"w\") as f:\n        json.dump(output_data, f, indent=4)\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.convert_xml_data","title":"<code>convert_xml_data(data_in={})</code>","text":"<p>Convert the inputted data from being formatted for the Java Archive Viewer to a format used by trace. This is accomplished by converting one dictionary structure to another.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>dict</code> <p>The input data to be converted, by default uses previously imported data</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>The converted data in a format that can be used by trace</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def convert_xml_data(self, data_in: dict = {}) -&gt; dict:\n    \"\"\"Convert the inputted data from being formatted for the Java Archive\n    Viewer to a format used by trace. This is accomplished by converting one\n    dictionary structure to another.\n\n    Parameters\n    ----------\n    data_in : dict, optional\n        The input data to be converted, by default uses previously imported data\n\n    Returns\n    -------\n    dict\n        The converted data in a format that can be used by trace\n    \"\"\"\n    if not data_in:\n        data_in = self.stored_data\n\n    converted_data = {}\n\n    converted_data[\"archiver_url\"] = data_in.get(\"connection_parameter\", getenv(\"PYDM_ARCHIVER_URL\"))\n    converted_data[\"archiver_url\"] = converted_data[\"archiver_url\"].replace(\"pbraw://\", \"http://\")\n\n    show_legend = data_in[\"legend_configuration\"][\"show_ave_name\"] == \"true\"\n\n    converted_data[\"plot\"] = {\"title\": data_in[\"plot_title\"], \"legend\": show_legend}\n\n    # Convert date formats from MM/DD/YYYY --&gt; YYYY-MM-DD\n    converted_data[\"time_axis\"] = {}\n    for key, val in data_in[\"time_axis\"][0].items():\n        if key in [\"start\", \"end\"]:\n            val = self.reformat_date(val)\n        converted_data[\"time_axis\"][key] = val\n\n    converted_data[\"y-axes\"] = []\n    for axis_in in data_in[\"range_axis\"]:\n        ax_dict = {\n            \"name\": axis_in[\"name\"],\n            \"label\": axis_in[\"name\"],\n            \"minRange\": axis_in[\"min\"],\n            \"maxRange\": axis_in[\"max\"],\n            \"orientation\": axis_in[\"location\"],\n            \"logMode\": axis_in[\"type\"] != \"normal\",\n        }\n        converted_data[\"y-axes\"].append(ax_dict)\n\n    converted_data[\"curves\"] = []\n    for pv_in in data_in[\"pv\"]:\n        color = self.srgb_to_qColor(pv_in[\"color\"])\n        pv_dict = {\n            \"name\": pv_in[\"name\"],\n            \"channel\": pv_in[\"name\"],\n            \"yAxisName\": pv_in[\"range_axis_name\"],\n            \"lineWidth\": int(float(pv_in[\"draw_width\"])),\n            \"color\": color.name(),\n            \"thresholdColor\": color.name(),\n        }\n        converted_data[\"curves\"].append(pv_dict)\n\n    converted_data[\"formula\"] = []\n    for formula_in in data_in[\"formula\"]:\n        color = self.srgb_to_qColor(formula_in[\"color\"])\n        formula = \"f://\" + formula_in[\"term\"]\n        for curve in formula_in[\"curveDict\"].keys():\n            insert = \"{\" + curve + \"}\"\n            formula = re.sub(curve, insert, formula)\n        formula_dict = {\n            \"name\": formula_in[\"name\"],\n            \"formula\": formula,\n            \"curveDict\": formula_in[\"curveDict\"],\n            \"yAxisName\": formula_in[\"range_axis_name\"],\n            \"lineWidth\": float(formula_in[\"draw_width\"]),\n            \"color\": color.name(),\n            \"thresholdColor\": color.name(),\n        }\n        converted_data[\"formula\"].append(formula_dict)\n\n    self.stored_data = self.remove_null_values(converted_data)\n    return self.stored_data\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.convert_stp_data","title":"<code>convert_stp_data(data_in={})</code>","text":"<p>Convert the inputted data from a format used by StripTool to a format used by Trace. This is accomplished by converting one dictionary structure to another.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>dict</code> <p>The input data to be converted, by default uses previously imported data</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>The converted data in a format that can be used by trace</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def convert_stp_data(self, data_in: dict = {}) -&gt; dict:\n    \"\"\"Convert the inputted data from a format used by StripTool to a format\n    used by Trace. This is accomplished by converting one dictionary structure\n    to another.\n\n    Parameters\n    ----------\n    data_in : dict, optional\n        The input data to be converted, by default uses previously imported data\n\n    Returns\n    -------\n    dict\n        The converted data in a format that can be used by trace\n    \"\"\"\n    if not data_in:\n        data_in = self.stored_data\n\n    if \"Curve\" not in data_in:\n        raise ValueError(f\"Incorrect input file format: {self.input_file}\")\n\n    converted = {\"archiver_url\": getenv(\"PYDM_ARCHIVER_URL\")}\n\n    # Convert all colors to a usable format\n    for k, v in data_in[\"Color\"].items():\n        color = self.xColor_to_qColor(v)\n        data_in[\"Color\"][k] = color.name()\n\n    # Convert plot config\n    converted[\"plot\"] = {}\n    converted[\"plot\"][\"xGrid\"] = bool(data_in[\"Option\"][\"GridXon\"])\n    converted[\"plot\"][\"yGrid\"] = bool(data_in[\"Option\"][\"GridYon\"])\n    converted[\"plot\"][\"backgroundColor\"] = data_in[\"Color\"][\"Background\"]\n\n    # Convert time_axis\n    converted[\"time_axis\"] = {\"name\": \"Main Time Axis\", \"location\": \"bottom\"}\n    converted[\"time_axis\"][\"start\"] = \"-\" + data_in[\"Time\"][\"Timespan\"] + \"s\"\n    converted[\"time_axis\"][\"end\"] = \"now\"\n\n    y_axis_names = {}\n\n    # Convert curves\n    converted[\"curves\"] = []\n    converted[\"formula\"] = []\n    for ind, data in data_in[\"Curve\"].items():\n        curve = {}\n        curve[\"name\"] = data[\"Name\"]\n        curve[\"channel\"] = data[\"Name\"]\n\n        color_key = f\"Color{int(ind) + 1}\"\n        if color_key in data_in[\"Color\"]:\n            curve[\"color\"] = data_in[\"Color\"][color_key]\n            curve[\"thresholdColor\"] = data_in[\"Color\"][color_key]\n\n        # Set curve's axis to the curve's units\n        if \"Units\" not in data:\n            continue\n        unit = \"\".join(data[\"Units\"])\n        curve[\"yAxisName\"] = unit\n\n        # Set the associated axis' log mode\n        log_mode = data[\"Scale\"] == \"1\"\n        if unit not in y_axis_names:\n            y_axis_names[unit] = []\n        y_axis_names[unit].append(log_mode)\n\n        converted[\"curves\"].append(curve)\n\n    # Convert y-axes\n    converted[\"y-axes\"] = []\n    for axis_name, log_mode in y_axis_names.items():\n        axis = {\"name\": axis_name, \"label\": axis_name, \"orientation\": \"left\"}\n        axis[\"logMode\"] = all(log_mode)\n        converted[\"y-axes\"].append(axis)\n\n    return converted\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.reformat_date","title":"<code>reformat_date(input_str)</code>  <code>classmethod</code>","text":"<p>Convert a time string from the format 'MM/DD/YYYY' --&gt; 'YYYY-MM-DD' and retain time if included</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Date string in the format of 'MM/DD/YYYY'; can include a time</p> required <p>Returns:</p> Type Description <code>str</code> <p>Date string in the format of 'YYYY-MM-DD'</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>@classmethod\ndef reformat_date(cls, input_str: str) -&gt; str:\n    \"\"\"Convert a time string from the format 'MM/DD/YYYY' --&gt; 'YYYY-MM-DD'\n    and retain time if included\n\n    Parameters\n    ----------\n    input_str : str\n        Date string in the format of 'MM/DD/YYYY'; can include a time\n\n    Returns\n    -------\n    str\n        Date string in the format of 'YYYY-MM-DD'\n    \"\"\"\n    if not cls.full_java_absolute_re.fullmatch(input_str):\n        return input_str\n\n    date = cls.java_date_re.search(input_str).group()\n    m, d, y = date.split(\"/\")\n    formatted_date = f\"{y}-{m}-{d}\"\n\n    time_match = cls.time_re.search(input_str)\n    if time_match:\n        formatted_date += \" \" + time_match.group()\n    return formatted_date\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.xml_to_dict","title":"<code>xml_to_dict(xml)</code>  <code>staticmethod</code>","text":"<p>Convert an XML ElementTree containing an Archive Viewer save file to a dictionary for easier use</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>ElementTree</code> <p>The XML ElementTree object read from the file</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The data in a dictionary format</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>@staticmethod\ndef xml_to_dict(xml: ET.ElementTree) -&gt; dict:\n    \"\"\"Convert an XML ElementTree containing an Archive Viewer save\n    file to a dictionary for easier use\n\n    Parameters\n    ----------\n    xml : ET.ElementTree\n        The XML ElementTree object read from the file\n\n    Returns\n    -------\n    dict\n        The data in a dictionary format\n    \"\"\"\n    data_dict = {\n        \"connection_parameter\": \"\",\n        \"plot_title\": \"\",\n        \"legend_configuration\": {},\n        \"time_axis\": [],\n        \"range_axis\": [],\n        \"pv\": [],\n        \"formula\": [],\n    }\n\n    data_dict[\"connection_parameter\"] = xml.find(\"connection_parameter\").text\n    data_dict[\"plot_title\"] = xml.find(\"plot_title\").text\n    data_dict[\"legend_configuration\"] = xml.find(\"legend_configuration\").attrib\n\n    for key in (\"time_axis\", \"range_axis\", \"pv\"):\n        for element in xml.findall(key):\n            ele_dict = element.attrib\n            ele_dict |= {sub_ele.tag: sub_ele.text for sub_ele in element}\n            data_dict[key].append(ele_dict)\n    key = \"formula\"\n    for element in xml.findall(key):\n        ele_dict = element.attrib\n        curveDict = dict()\n        for sub_ele in element:\n            if sub_ele.tag == \"argument_ave\":\n                tempDict = sub_ele.attrib\n                curveDict[tempDict[\"variable\"]] = tempDict[\"name\"]\n            else:\n                ele_dict |= {sub_ele.tag: sub_ele.text}\n        ele_dict[\"curveDict\"] = curveDict\n        data_dict[key].append(ele_dict)\n    return data_dict\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.stp_to_dict","title":"<code>stp_to_dict(stp_text)</code>  <code>staticmethod</code>","text":"<p>Convert the StripTool file's text into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>stp_text</code> <code>str</code> <p>The full file text from the StripTool file</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The data in a dictionary format</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>@staticmethod\ndef stp_to_dict(stp_text: str) -&gt; dict:\n    \"\"\"Convert the StripTool file's text into a dictionary.\n\n    Parameters\n    ----------\n    stp_text : str\n        The full file text from the StripTool file\n\n    Returns\n    -------\n    dict\n        The data in a dictionary format\n    \"\"\"\n    extracted_data = {}\n\n    for line in stp_text.splitlines():\n        line_split = line.split()\n        if not line_split:\n            continue\n\n        key = line_split[0].removeprefix(\"Strip.\")\n        val = None\n        if len(line_split) == 1:\n            val = \"\"\n        elif len(line_split) == 2:\n            val = line_split[1]\n        else:\n            val = line_split[1:]\n\n        # Find which child dictionary should contain the key-value pair\n        data_loc = extracted_data\n        key_split = key.split(\".\")\n        for k in key_split[:-1]:\n            if k not in data_loc:\n                data_loc[k] = {}\n            data_loc = data_loc[k]\n        data_loc[key_split[-1]] = val\n\n    return extracted_data\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.get_plot_data","title":"<code>get_plot_data(plot)</code>  <code>classmethod</code>","text":"<p>Extract plot, axis, and curve data from a PyDMTimePlot object</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>PyDMTimePlot</code> <p>The PyDM Plotting object to extract data from. Gets plot, axis, and curve data.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of all of the relevant data for the given plot</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>@classmethod\ndef get_plot_data(cls, plot: PyDMTimePlot) -&gt; dict:\n    \"\"\"Extract plot, axis, and curve data from a PyDMTimePlot object\n\n    Parameters\n    ----------\n    plot : PyDMTimePlot\n        The PyDM Plotting object to extract data from. Gets plot, axis, and curve data.\n\n    Returns\n    -------\n    dict\n        A dictionary representation of all of the relevant data for the given plot\n    \"\"\"\n    output_dict = {\n        \"archiver_url\": getenv(\"PYDM_ARCHIVER_URL\"),\n        \"plot\": {},\n        \"time_axis\": {},\n        \"y-axes\": [],\n        \"curves\": [],\n        \"formula\": [],\n    }\n\n    auto_scroll_enabled = plot.auto_scroll_timer.isActive()\n    if auto_scroll_enabled:\n        timespan = -1 * plot.scroll_timespan\n        timespan_td = timedelta(seconds=timespan)\n        start_str = cls.delta_to_relative(timespan_td)\n        end_str = \"now\"\n    else:\n        [start_ts, end_ts] = plot.getXAxis().range\n        start_dt = datetime.fromtimestamp(start_ts)\n        end_dt = datetime.fromtimestamp(end_ts)\n        start_str = start_dt.isoformat(sep=\" \", timespec=\"seconds\")\n        end_str = end_dt.isoformat(sep=\" \", timespec=\"seconds\")\n\n    output_dict[\"plot\"] = plot.to_dict()\n    output_dict[\"time_axis\"] = {\n        \"name\": \"Main Time Axis\",\n        \"start\": start_str,\n        \"end\": end_str,\n        \"location\": \"bottom\",\n    }\n\n    for a in plot.getYAxes():\n        axis_dict = json.loads(a, object_pairs_hook=OrderedDict)\n        output_dict[\"y-axes\"].append(axis_dict)\n\n    for c in plot.getCurves():\n        curve_dict = json.loads(c, object_pairs_hook=OrderedDict)\n        if \"channel\" in curve_dict:\n            if not curve_dict[\"channel\"]:\n                continue\n            output_dict[\"curves\"].append(curve_dict)\n        else:\n            if not curve_dict[\"formula\"]:\n                continue\n            output_dict[\"formula\"].append(curve_dict)\n\n    return output_dict\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.delta_to_relative","title":"<code>delta_to_relative(delta)</code>  <code>staticmethod</code>","text":"<p>Convert a datetime.timedelta to a relative time string</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>timedelta</code> <p>The timedelta to convert</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representing the timedelta in a relative format</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>@staticmethod\ndef delta_to_relative(delta: timedelta) -&gt; str:\n    \"\"\"Convert a datetime.timedelta to a relative time string\n\n    Parameters\n    ----------\n    delta : datetime.timedelta\n        The timedelta to convert\n\n    Returns\n    -------\n    str\n        A string representing the timedelta in a relative format\n    \"\"\"\n    return_list = []\n    remaining_seconds = int(delta.total_seconds())\n\n    negative = False\n    if remaining_seconds &lt; 0:\n        negative = True\n        remaining_seconds = abs(remaining_seconds)\n\n    # Calculate years, months, weeks, days, hours, minutes, seconds\n    years, remaining_seconds = divmod(remaining_seconds, 365 * 24 * 3600)\n    months, remaining_seconds = divmod(remaining_seconds, 30 * 24 * 3600)\n    weeks, remaining_seconds = divmod(remaining_seconds, 7 * 24 * 3600)\n    days, remaining_seconds = divmod(remaining_seconds, 24 * 3600)\n    hours, remaining_seconds = divmod(remaining_seconds, 3600)\n    minutes, seconds = divmod(remaining_seconds, 60)\n\n    # Append non-zero values to the return list\n    return_list.append(f\"{years}y\" if years else \"\")\n    return_list.append(f\"{months}M\" if months else \"\")\n    return_list.append(f\"{weeks}w\" if weeks else \"\")\n    return_list.append(f\"{days}d\" if days else \"\")\n    return_list.append(f\"{hours}H\" if hours else \"\")\n    return_list.append(f\"{minutes}m\" if minutes else \"\")\n    return_list.append(f\"{seconds}s\" if seconds else \"\")\n\n    # Filter out empty strings and apply the '+' or '-' sign\n    return_list = [item for item in return_list if item]\n    sign = \"-\" if negative else \"+\"\n    return_list = [sign + item for item in return_list]\n\n    return \" \".join(return_list) if return_list else \"-1d\"  # Default to -1 day if no time is given\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.srgb_to_qColor","title":"<code>srgb_to_qColor(srgb)</code>  <code>staticmethod</code>","text":"<p>Convert RGB strings to QColors. The string is a 32-bit integer containing the aRGB values of a color. (e.g. #FF0000 or -65536)</p> <p>Parameters:</p> Name Type Description Default <code>srgb</code> <code>str</code> <p>Either a hex value or a string containing a signed 32-bit integer</p> required <p>Returns:</p> Type Description <code>QColor</code> <p>A QColor object storing the color described in the string</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>@staticmethod\ndef srgb_to_qColor(srgb: str) -&gt; QColor:\n    \"\"\"Convert RGB strings to QColors. The string is a 32-bit\n    integer containing the aRGB values of a color. (e.g. #FF0000 or -65536)\n\n    Parameters\n    ----------\n    srgb : str\n        Either a hex value or a string containing a signed 32-bit integer\n\n    Returns\n    -------\n    QColor\n        A QColor object storing the color described in the string\n    \"\"\"\n    if not srgb:\n        return QColor()\n    elif srgb[0] != \"#\":\n        rgb_int = int(srgb) &amp; 0xFFFFFFFF\n        srgb = f\"#{rgb_int:08X}\"\n    return QColor(srgb)\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.xColor_to_qColor","title":"<code>xColor_to_qColor(rgb)</code>  <code>staticmethod</code>","text":"<p>Convert XColor values into QColors. Colors in StripTool files (*.stp) are saved as XColors.</p> <p>Parameters:</p> Name Type Description Default <code>rgb</code> <code>list(str)</code> <p>A list of strings containing the rgb values (0 &lt;= rgb &lt; 0xFFFF)</p> required <p>Returns:</p> Type Description <code>QColor</code> <p>A QColor object storing the color described in the string</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>@staticmethod\ndef xColor_to_qColor(rgb: list[str]) -&gt; QColor:\n    \"\"\"Convert XColor values into QColors. Colors in StripTool files (*.stp)\n    are saved as XColors.\n\n    Parameters\n    ----------\n    rgb : list(str)\n        A list of strings containing the rgb values (0 &lt;= rgb &lt; 0xFFFF)\n\n    Returns\n    -------\n    QColor\n        A QColor object storing the color described in the string\n    \"\"\"\n    for i in range(3):\n        rgb[i] = int(rgb[i]) // 256\n\n    return QColor(*rgb)\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.TraceFileConverter.remove_null_values","title":"<code>remove_null_values(obj_in)</code>  <code>staticmethod</code>","text":"<p>Delete None values recursively from all of the dictionaries, tuples, lists, sets</p> <p>Parameters:</p> Name Type Description Default <code>obj_in</code> <code>dict | list</code> <p>Some dictionary, possibly containing key-value pairs where value is None</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The same dictionary, but with those key-value pairs deleted</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>@staticmethod\ndef remove_null_values(obj_in: dict | list) -&gt; dict | list:\n    \"\"\"Delete None values recursively from all of the dictionaries, tuples, lists, sets\n\n    Parameters\n    ----------\n    obj_in : dict | list\n        Some dictionary, possibly containing key-value pairs where value is None\n\n    Returns\n    -------\n    dict\n        The same dictionary, but with those key-value pairs deleted\n    \"\"\"\n    if isinstance(obj_in, dict):\n        for key, value in list(obj_in.items()):\n            if isinstance(value, (list, dict, tuple, set)):\n                obj_in[key] = TraceFileConverter.remove_null_values(value)\n            elif value is None or key is None:\n                del obj_in[key]\n\n    elif isinstance(obj_in, (list, set, tuple)):\n        temp_list = []\n        for item in obj_in:\n            if item is None:\n                continue\n            temp_list.append(TraceFileConverter.remove_null_values(item))\n        obj_in = type(obj_in)(temp_list)\n\n    return obj_in\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.PathAction","title":"<code>PathAction</code>","text":"<p>               Bases: <code>Action</code></p>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.PathAction.__call__","title":"<code>__call__(parser, namespace, values, option_string=None)</code>","text":"<p>Convert filepath string from argument into  a pathlib.Path object</p> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def __call__(\n    self, parser: ArgumentParser, namespace: Namespace, values: str | list, option_string: str = None\n) -&gt; None:\n    \"\"\"Convert filepath string from argument into  a pathlib.Path object\"\"\"\n    if isinstance(values, str):\n        values = [values]\n\n    new_paths = []\n    for file_path in values:\n        new_path = path.expandvars(file_path)\n        new_path = Path(new_path).expanduser()\n        new_path = new_path.resolve()\n        new_paths.append(new_path)\n    setattr(namespace, self.dest, new_paths)\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.convert","title":"<code>convert(converter, input_file=None, output_file=None, overwrite=False)</code>","text":"<p>Individually convert the provided input file into the expected output file. If requested, overwrite the existing output file if it exists already.</p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>TraceFileConverter</code> <p>The TraceFileConverter object to use for the conversion.</p> required <code>input_file</code> <code>list[Path]</code> <p>The user provided input file to be converted</p> <code>None</code> <code>output_file</code> <code>list[Path]</code> <p>The user provided output file name to use during conversion, by default None</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether or not to overwrite the existing output file, by default False</p> <code>False</code> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def convert(converter: TraceFileConverter, input_file: Path = None, output_file: Path = None, overwrite: bool = False):\n    \"\"\"Individually convert the provided input file into the expected output file. If requested,\n    overwrite the existing output file if it exists already.\n\n    Parameters\n    ----------\n    converter : TraceFileConverter\n        The TraceFileConverter object to use for the conversion.\n    input_file : list[Path]\n        The user provided input file to be converted\n    output_file : list[Path], optional\n        The user provided output file name to use during conversion, by default None\n    overwrite : bool, optional\n        Whether or not to overwrite the existing output file, by default False\n    \"\"\"\n    # Check that the input file is usable\n    if not input_file:\n        raise FileNotFoundError(\"Input file not provided\")\n    elif not input_file.is_file():\n        raise FileNotFoundError(f\"Data file not found: {input_file}\")\n    elif not (input_file.match(\"*.xml\") or input_file.match(\"*.stp\")):\n        raise FileNotFoundError(f\"Incorrect input file format: {input_file}\")\n\n    # Check that the output file is usable\n    if not output_file:\n        output_file = input_file.with_suffix(\".trc\")\n    elif not output_file.suffix:\n        output_file = output_file.with_suffix(\".trc\")\n    elif not output_file.match(\"*.trc\"):\n        raise FileNotFoundError(f\"Incorrect output file format: {output_file}\")\n\n    # Check if file exists, and if it does if the overwrite flag is used\n    if output_file.is_file() and not overwrite:\n        raise FileExistsError(f\"Output file exists but overwrite not enabled: {output_file}\")\n\n    converter.import_file(input_file)\n    converter.export_file(output_file)\n</code></pre>"},{"location":"reference/file_io/trace_file_convert/#file_io.trace_file_convert.main","title":"<code>main(input_file=None, output_file=None, overwrite=False, clean=False)</code>","text":"<p>Convert all provided input files into the expected output files. If requested, overwrite the existing output files and remove any leftover input files.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>list[Path]</code> <p>The user provided input files to be converted</p> <code>None</code> <code>output_file</code> <code>list[Path]</code> <p>The user provided output file names to use during conversion, by default None</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether or not to overwrite the existing output files, by default False</p> <code>False</code> <code>clean</code> <code>bool</code> <p>Whether or not to remove the input files after conversion, by default False</p> <code>False</code> Source code in <code>trace/file_io/trace_file_convert.py</code> <pre><code>def main(input_file: list[Path] = None, output_file: list[Path] = None, overwrite: bool = False, clean: bool = False):\n    \"\"\"Convert all provided input files into the expected output files. If requested,\n    overwrite the existing output files and remove any leftover input files.\n\n    Parameters\n    ----------\n    input_file : list[Path]\n        The user provided input files to be converted\n    output_file : list[Path], optional\n        The user provided output file names to use during conversion, by default None\n    overwrite : bool, optional\n        Whether or not to overwrite the existing output files, by default False\n    clean : bool, optional\n        Whether or not to remove the input files after conversion, by default False\n    \"\"\"\n    converter = TraceFileConverter()\n\n    # Get a zip object where every input_file has an associated output_file\n    file_match = zip_longest(input_file, output_file)\n    if len(input_file) &lt; len(output_file):\n        file_match = zip(input_file, output_file)\n\n    # Iterate through all provided input and output file names\n    for file_in, file_out in file_match:\n        try:\n            convert(converter, file_in, file_out, overwrite)\n\n            # Remove the input file if requested; skipped if conversion fails\n            if clean:\n                file_in.unlink()\n                logger.debug(f\"Removing input file: {file_in.name}\")\n        except BaseException as e:\n            error_message = \"Failed: \" + file_in.name\n            if file_out:\n                error_message += \" --&gt; \" + file_out.name\n            error_message += f\": {e}\"\n            logger.error(error_message)\n</code></pre>"},{"location":"reference/services/elog_client/","title":"E-Log Service","text":"<p>elog_client.py</p> <p>Elog API client for posting entries and fetching user and logbook information.</p>"},{"location":"reference/services/elog_client/#services.elog_client.get_user","title":"<code>get_user()</code>","text":"<p>Fetches the user information from the ELOG API. Also used to verify the API key. :return: A tuple containing the status code and the user data or exception.</p> Source code in <code>trace/services/elog_client.py</code> <pre><code>def get_user() -&gt; tuple[int, dict | Exception]:\n    \"\"\"\n    Fetches the user information from the ELOG API. Also used to verify the API key.\n    :return: A tuple containing the status code and the user data or exception.\n    \"\"\"\n    url = f\"{ELOG_API_URL}/v1/users/me\"\n    headers = {\"x-vouch-idp-accesstoken\": ELOG_API_KEY}\n    try:\n        response = requests.get(url, headers=headers)\n        response.raise_for_status()\n        return response.status_code, response.json()\n    except requests.exceptions.RequestException as e:\n        logger.error(e)\n        return response.status_code, e\n</code></pre>"},{"location":"reference/services/elog_client/#services.elog_client.post_entry","title":"<code>post_entry(title, body, logbooks, image_bytes, config_file_path=None)</code>","text":"<p>Posts a new entry with image to the ELOG API.</p> <p>:param title: The title of the entry. :param body: The body of the entry. :param logbooks: A list of logbook names to post the entry to. :param image_bytes: Bytes of the image to be attached to the entry. :param config_file: Optional, path of config file to attach. :return: A tuple containing the status code and the response data or exception.</p> Source code in <code>trace/services/elog_client.py</code> <pre><code>def post_entry(\n    title: str, body: str, logbooks: list[str], image_bytes, config_file_path: Path | None = None\n) -&gt; tuple[int, dict | Exception]:\n    \"\"\"\n    Posts a new entry with image to the ELOG API.\n\n    :param title: The title of the entry.\n    :param body: The body of the entry.\n    :param logbooks: A list of logbook names to post the entry to.\n    :param image_bytes: Bytes of the image to be attached to the entry.\n    :param config_file: Optional, path of config file to attach.\n    :return: A tuple containing the status code and the response data or exception.\n    \"\"\"\n    url = f\"{ELOG_API_URL}/v2/entries\"\n    headers = {\"x-vouch-idp-accesstoken\": ELOG_API_KEY}\n\n    entry_data = {\"title\": title, \"text\": body, \"logbooks\": logbooks}\n    entry_json = json.dumps(entry_data).encode(\"utf-8\")\n\n    files = [\n        (\"entry\", (\"entry.json\", entry_json, \"application/json\")),\n        (\"files\", (\"trace_plot.png\", image_bytes, \"image/png\")),\n    ]\n    if config_file_path is not None:\n        with open(config_file_path, \"rb\") as f:\n            config_bytes = f.read()\n        files.append((\"files\", (config_file_path.name, config_bytes, \"application/octet-stream\")))\n    try:\n        response = requests.post(\n            url,\n            headers=headers,\n            files=files,\n        )\n        response.raise_for_status()\n        return response.status_code, response.json()\n    except requests.exceptions.RequestException as e:\n        logger.error(e)\n        return response.status_code, e\n</code></pre>"},{"location":"reference/services/elog_client/#services.elog_client.get_logbooks","title":"<code>get_logbooks()</code>","text":"<p>Fetches the list of logbooks from the ELOG API.</p> <p>:return: A tuple containing the status code and a list of logbook names or an exception.</p> Source code in <code>trace/services/elog_client.py</code> <pre><code>def get_logbooks() -&gt; tuple[int, list[str] | Exception]:\n    \"\"\"\n    Fetches the list of logbooks from the ELOG API.\n\n    :return: A tuple containing the status code and a list of logbook names or an exception.\n    \"\"\"\n    url = f\"{ELOG_API_URL}/v1/logbooks\"\n    headers = {\"x-vouch-idp-accesstoken\": ELOG_API_KEY}\n\n    try:\n        response = requests.get(url, headers=headers)\n        response.raise_for_status()\n        return response.status_code, [logbook[\"name\"] for logbook in response.json()[\"payload\"]]\n    except requests.exceptions.RequestException as e:\n        logger.error(e)\n        return response.status_code, e\n</code></pre>"},{"location":"reference/services/theme_manager/","title":"Theme Manager","text":"<p>The ThemeManager is a QObject that allows for Trace to achieve a uniform look/feel throughout the application. It determines if the app should display a light or a dark theme and manages color palettes for each.</p>"},{"location":"reference/services/theme_manager/#services.theme_manager.Theme","title":"<code>Theme</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Theme enumeration for light and dark modes.</p>"},{"location":"reference/services/theme_manager/#services.theme_manager.IconColors","title":"<code>IconColors</code>","text":"<p>Constants for icon color types.</p>"},{"location":"reference/services/theme_manager/#services.theme_manager.ThemeManager","title":"<code>ThemeManager(app, parent=None)</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Theme manager for Qt applications with icon support. It manages both Qt palette themes and icon colors, providing a unified interface for light/dark mode switching with persistent settings.</p> <p>Attributes:</p> Name Type Description <code>theme_changed</code> <code>Signal</code> <p>Signal emitted when theme changes, passes Theme enum value.</p> <code>current_theme</code> <code>Theme</code> <p>Currently active theme.</p> <code>app</code> <code>QApplication</code> <p>Qt application instance.</p> <code>light_palette</code> <code>QPalette</code> <p>Palette configuration for light theme.</p> <code>dark_palette</code> <code>QPalette</code> <p>Palette configuration for dark theme.</p> <code>light_icon_colors</code> <code>IconColorDict</code> <p>Icon color mapping for light theme.</p> <code>dark_icon_colors</code> <code>IconColorDict</code> <p>Icon color mapping for dark theme.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>QApplication</code> <p>The Qt application instance to manage themes for.</p> required <code>parent</code> <code>QObject | None</code> <p>Parent QObject for memory management, by default None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; app = QApplication(sys.argv)\n&gt;&gt;&gt; theme_manager = IntegratedThemeManager(app)\n&gt;&gt;&gt; theme_manager.set_theme(Theme.DARK)\n</code></pre> Source code in <code>trace/services/theme_manager.py</code> <pre><code>def __init__(\n    self,\n    app: QApplication,\n    parent: QObject | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the integrated theme manager.\n\n    Parameters\n    ----------\n    app : QApplication\n        The Qt application instance to manage themes for.\n    parent : QObject | None, optional\n        Parent QObject for memory management, by default None.\n\n    Examples\n    --------\n    &gt;&gt;&gt; app = QApplication(sys.argv)\n    &gt;&gt;&gt; theme_manager = IntegratedThemeManager(app)\n    &gt;&gt;&gt; theme_manager.set_theme(Theme.DARK)\n    \"\"\"\n    super().__init__(parent)\n    self.app = app\n    self.current_theme = Theme.LIGHT\n    self.app.setStyle(QStyleFactory.create(\"Fusion\"))\n\n    self._setup_palettes()\n    self._setup_icon_colors()\n\n    # Load saved theme preference\n    settings = QSettings()\n    is_dark = settings.value(\"isDarkTheme\", False, bool)\n    self.set_theme(Theme.DARK if is_dark else Theme.LIGHT)\n</code></pre>"},{"location":"reference/services/theme_manager/#services.theme_manager.ThemeManager.set_theme","title":"<code>set_theme(theme)</code>","text":"<p>Set the application theme.</p> <p>Parameters:</p> Name Type Description Default <code>theme</code> <code>Theme</code> <p>The theme to apply (Theme.LIGHT or Theme.DARK).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; theme_manager.set_theme(Theme.DARK)\n&gt;&gt;&gt; theme_manager.set_theme(Theme.LIGHT)\n</code></pre> Source code in <code>trace/services/theme_manager.py</code> <pre><code>def set_theme(self, theme: Theme) -&gt; None:\n    \"\"\"\n    Set the application theme.\n\n    Parameters\n    ----------\n    theme : Theme\n        The theme to apply (Theme.LIGHT or Theme.DARK).\n\n    Examples\n    --------\n    &gt;&gt;&gt; theme_manager.set_theme(Theme.DARK)\n    &gt;&gt;&gt; theme_manager.set_theme(Theme.LIGHT)\n    \"\"\"\n    self.current_theme = theme\n\n    if theme == Theme.DARK:\n        self.app.setPalette(self.dark_palette)\n        stylesheet = dark_stylesheet.read_text()\n    else:\n        self.app.setPalette(self.light_palette)\n        stylesheet = light_stylesheet.read_text()\n\n    self.app.main_window.setStyleSheet(stylesheet)\n\n    settings = QSettings()\n    settings.setValue(\"isDarkTheme\", theme == Theme.DARK)\n\n    self.theme_changed.emit(theme)\n</code></pre>"},{"location":"reference/services/theme_manager/#services.theme_manager.ThemeManager.toggle_theme","title":"<code>toggle_theme()</code>","text":"<p>Toggle between light and dark themes.</p> <p>Switches from light to dark or dark to light, whichever is opposite to the current theme.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; theme_manager.toggle_theme()  # Switches to opposite theme\n</code></pre> Source code in <code>trace/services/theme_manager.py</code> <pre><code>def toggle_theme(self) -&gt; None:\n    \"\"\"\n    Toggle between light and dark themes.\n\n    Switches from light to dark or dark to light, whichever is opposite\n    to the current theme.\n\n    Examples\n    --------\n    &gt;&gt;&gt; theme_manager.toggle_theme()  # Switches to opposite theme\n    \"\"\"\n    new_theme = Theme.DARK if self.current_theme == Theme.LIGHT else Theme.LIGHT\n    self.set_theme(new_theme)\n</code></pre>"},{"location":"reference/services/theme_manager/#services.theme_manager.ThemeManager.get_current_theme","title":"<code>get_current_theme()</code>","text":"<p>Get the current theme.</p> <p>Returns:</p> Type Description <code>Theme</code> <p>The currently active theme.</p> Source code in <code>trace/services/theme_manager.py</code> <pre><code>def get_current_theme(self) -&gt; Theme:\n    \"\"\"\n    Get the current theme.\n\n    Returns\n    -------\n    Theme\n        The currently active theme.\n    \"\"\"\n    return self.current_theme\n</code></pre>"},{"location":"reference/services/theme_manager/#services.theme_manager.ThemeManager.get_icon_color","title":"<code>get_icon_color(color_type=IconColors.PRIMARY)</code>","text":"<p>Get icon color for the current theme.</p> <p>Parameters:</p> Name Type Description Default <code>color_type</code> <code>str</code> <p>The type of icon color to retrieve, by default IconColors.PRIMARY. Must be one of the IconColors constants.</p> <code>PRIMARY</code> <p>Returns:</p> Type Description <code>ColorHex</code> <p>Hex color string (e.g., '#ffffff') appropriate for the current theme.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color = theme_manager.get_icon_color(IconColors.PRIMARY)\n&gt;&gt;&gt; warning_color = theme_manager.get_icon_color(IconColors.WARNING)\n</code></pre> Source code in <code>trace/services/theme_manager.py</code> <pre><code>def get_icon_color(self, color_type: str = IconColors.PRIMARY) -&gt; ColorHex:\n    \"\"\"\n    Get icon color for the current theme.\n\n    Parameters\n    ----------\n    color_type : str, optional\n        The type of icon color to retrieve, by default IconColors.PRIMARY.\n        Must be one of the IconColors constants.\n\n    Returns\n    -------\n    ColorHex\n        Hex color string (e.g., '#ffffff') appropriate for the current theme.\n\n    Examples\n    --------\n    &gt;&gt;&gt; color = theme_manager.get_icon_color(IconColors.PRIMARY)\n    &gt;&gt;&gt; warning_color = theme_manager.get_icon_color(IconColors.WARNING)\n    \"\"\"\n    colors = self.dark_icon_colors if self.current_theme == Theme.DARK else self.light_icon_colors\n    return colors.get(color_type, colors[IconColors.PRIMARY])\n</code></pre>"},{"location":"reference/services/theme_manager/#services.theme_manager.ThemeManager.create_icon","title":"<code>create_icon(icon_name, color_type=IconColors.PRIMARY, scale_factor=1.0, custom_color=None)</code>","text":"<p>Create a themed icon using qtawesome.</p> <p>Parameters:</p> Name Type Description Default <code>icon_name</code> <code>str</code> <p>The qtawesome icon name (e.g., 'fa.home', 'mdi.gear').</p> required <code>color_type</code> <code>str</code> <p>The type of icon color to use, by default IconColors.PRIMARY.</p> <code>PRIMARY</code> <code>scale_factor</code> <code>float</code> <p>Scale factor for icon size, by default 1.0.</p> <code>1.0</code> <code>custom_color</code> <code>ColorHex | None</code> <p>Custom hex color to override theme color, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>QIcon | None</code> <p>The created icon, or None if qtawesome is not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; icon = theme_manager.create_icon('fa.home')\n&gt;&gt;&gt; warning_icon = theme_manager.create_icon('fa.exclamation-triangle', IconColors.WARNING)\n&gt;&gt;&gt; custom_icon = theme_manager.create_icon('fa.gear', custom_color='#ff0000')\n</code></pre> Source code in <code>trace/services/theme_manager.py</code> <pre><code>def create_icon(\n    self,\n    icon_name: str,\n    color_type: str = IconColors.PRIMARY,\n    scale_factor: float = 1.0,\n    custom_color: ColorHex | None = None,\n) -&gt; QIcon | None:\n    \"\"\"\n    Create a themed icon using qtawesome.\n\n    Parameters\n    ----------\n    icon_name : str\n        The qtawesome icon name (e.g., 'fa.home', 'mdi.gear').\n    color_type : str, optional\n        The type of icon color to use, by default IconColors.PRIMARY.\n    scale_factor : float, optional\n        Scale factor for icon size, by default 1.0.\n    custom_color : ColorHex | None, optional\n        Custom hex color to override theme color, by default None.\n\n    Returns\n    -------\n    QIcon | None\n        The created icon, or None if qtawesome is not available.\n\n    Examples\n    --------\n    &gt;&gt;&gt; icon = theme_manager.create_icon('fa.home')\n    &gt;&gt;&gt; warning_icon = theme_manager.create_icon('fa.exclamation-triangle', IconColors.WARNING)\n    &gt;&gt;&gt; custom_icon = theme_manager.create_icon('fa.gear', custom_color='#ff0000')\n    \"\"\"\n    color = custom_color or self.get_icon_color(color_type)\n    return qta.icon(icon_name, color=color, scale_factor=scale_factor)\n</code></pre>"},{"location":"reference/services/theme_manager/#services.theme_manager.ThemeManager.get_all_icon_colors","title":"<code>get_all_icon_colors()</code>","text":"<p>Get all available icon colors for the current theme.</p> <p>Returns:</p> Type Description <code>IconColorDict</code> <p>Dictionary mapping color type names to hex color strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; colors = theme_manager.get_all_icon_colors()\n&gt;&gt;&gt; primary_color = colors[IconColors.PRIMARY]\n</code></pre> Source code in <code>trace/services/theme_manager.py</code> <pre><code>def get_all_icon_colors(self) -&gt; IconColorDict:\n    \"\"\"\n    Get all available icon colors for the current theme.\n\n    Returns\n    -------\n    IconColorDict\n        Dictionary mapping color type names to hex color strings.\n\n    Examples\n    --------\n    &gt;&gt;&gt; colors = theme_manager.get_all_icon_colors()\n    &gt;&gt;&gt; primary_color = colors[IconColors.PRIMARY]\n    \"\"\"\n    return self.dark_icon_colors.copy() if self.current_theme == Theme.DARK else self.light_icon_colors.copy()\n</code></pre>"},{"location":"reference/utilities/formula_validation/","title":"Formula Validation","text":""},{"location":"reference/utilities/formula_validation/#utilities.formula_validation.validate_formula","title":"<code>validate_formula(expr, allowed_symbols)</code>","text":"<p>Validate a mathematical formula expression for safety and correctness.</p> <p>This function parses the expression using Python's AST and validates that: - Only allowed operators and functions are used - All variable names are in the allowed symbols set - The expression is syntactically valid</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The mathematical expression to validate</p> required <code>allowed_symbols</code> <code>Set[str]</code> <p>Set of allowed variable names in the expression</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the expression contains disallowed operators, functions, or symbols</p> <code>SyntaxError</code> <p>If the expression is not syntactically valid Python</p> Source code in <code>trace/utilities/formula_validation.py</code> <pre><code>def validate_formula(expr: str, allowed_symbols: Set[str]) -&gt; None:\n    \"\"\"Validate a mathematical formula expression for safety and correctness.\n\n    This function parses the expression using Python's AST and validates that:\n    - Only allowed operators and functions are used\n    - All variable names are in the allowed symbols set\n    - The expression is syntactically valid\n\n    Parameters\n    ----------\n    expr : str\n        The mathematical expression to validate\n    allowed_symbols : Set[str]\n        Set of allowed variable names in the expression\n\n    Raises\n    ------\n    ValueError\n        If the expression contains disallowed operators, functions, or symbols\n    SyntaxError\n        If the expression is not syntactically valid Python\n    \"\"\"\n    tree = ast.parse(expr, mode=\"eval\")\n\n    for node in ast.walk(tree):\n        if not isinstance(node, _ALLOWED_NODES):\n            raise ValueError(f'Operator \"{type(node).__name__}\" not allowed')\n\n        if isinstance(node, ast.Call):\n            fn = node.func.id if isinstance(node.func, ast.Name) else None\n            if fn not in _ALLOWED_FUNC_NAMES:\n                raise ValueError(f'Function \"{fn}\" not permitted')\n\n        if isinstance(node, ast.Name):\n            if node.id not in allowed_symbols and node.id not in _ALLOWED_FUNC_NAMES:\n                raise ValueError(f'Unknown symbol \"{node.id}\"')\n</code></pre>"},{"location":"reference/utilities/formula_validation/#utilities.formula_validation.sanitize_for_validation","title":"<code>sanitize_for_validation(expr)</code>","text":"<p>Convert formula expression with variable placeholders to valid Python expression.</p> <p>This function replaces variable placeholders in the format {VAR_NAME} with temporary identifiers (v0, v1, etc.) that can be parsed by Python's AST. This allows validation of formulas that reference curve variables.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The formula expression containing variable placeholders like {PV1}</p> required <p>Returns:</p> Type Description <code>tuple[str, set[str]]</code> <p>A tuple containing: - python_expr : str     Expression that the Python AST can parse with temporary identifiers - allowed_syms : set[str]     The generated temporary identifiers, ready to pass to <code>validate_formula</code></p> Source code in <code>trace/utilities/formula_validation.py</code> <pre><code>def sanitize_for_validation(expr: str) -&gt; tuple[str, set[str]]:\n    \"\"\"Convert formula expression with variable placeholders to valid Python expression.\n\n    This function replaces variable placeholders in the format {VAR_NAME} with\n    temporary identifiers (v0, v1, etc.) that can be parsed by Python's AST.\n    This allows validation of formulas that reference curve variables.\n\n    Parameters\n    ----------\n    expr : str\n        The formula expression containing variable placeholders like {PV1}\n\n    Returns\n    -------\n    tuple[str, set[str]]\n        A tuple containing:\n        - python_expr : str\n            Expression that the Python AST can parse with temporary identifiers\n        - allowed_syms : set[str]\n            The generated temporary identifiers, ready to pass to `validate_formula`\n    \"\"\"\n    mapping = {}\n\n    def _repl(match):\n        var = match.group(1)\n        if var not in mapping:\n            mapping[var] = f\"v{len(mapping)}\"\n        return mapping[var]\n\n    python_expr = re.sub(r\"{([^}]+)}\", _repl, expr)\n    return python_expr, set(mapping.values())\n</code></pre>"},{"location":"reference/utilities/time_parser/","title":"Time Parser","text":""},{"location":"reference/utilities/time_parser/#utilities.time_parser.IOTimeParser","title":"<code>IOTimeParser</code>","text":"<p>Collection of classmethods to parse a given date time string. The string can contain an absolute date and time, or a date and time that are relative to another time or even each other.</p>"},{"location":"reference/utilities/time_parser/#utilities.time_parser.IOTimeParser.is_relative","title":"<code>is_relative(input_str)</code>  <code>classmethod</code>","text":"<p>Check if the given string is a relative time (e.g. '+1d', '-8h', '-1w 08:00')</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>String to be checked if in relative time format</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the provided string is in relative time format</p> Source code in <code>trace/utilities/time_parser.py</code> <pre><code>@classmethod\ndef is_relative(cls, input_str: str) -&gt; bool:\n    \"\"\"Check if the given string is a relative time (e.g. '+1d',\n    '-8h', '-1w 08:00')\n\n    Parameters\n    ----------\n    input_str : str\n        String to be checked if in relative time format\n\n    Returns\n    -------\n    bool\n        True if the provided string is in relative time format\n    \"\"\"\n    found = cls.full_relative_re.fullmatch(input_str)\n    return bool(found)\n</code></pre>"},{"location":"reference/utilities/time_parser/#utilities.time_parser.IOTimeParser.is_absolute","title":"<code>is_absolute(input_str)</code>  <code>classmethod</code>","text":"<p>Check if the given string is an absolute time (e.g. '2024-07-16 08:00')</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>String to be checked if in absolute time format</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the provided string is in absolute time format</p> Source code in <code>trace/utilities/time_parser.py</code> <pre><code>@classmethod\ndef is_absolute(cls, input_str: str) -&gt; bool:\n    \"\"\"Check if the given string is an absolute time (e.g.\n    '2024-07-16 08:00')\n\n    Parameters\n    ----------\n    input_str : str\n        String to be checked if in absolute time format\n\n    Returns\n    -------\n    bool\n        True if the provided string is in absolute time format\n    \"\"\"\n    found = cls.full_absolute_re.fullmatch(input_str)\n    return bool(found)\n</code></pre>"},{"location":"reference/utilities/time_parser/#utilities.time_parser.IOTimeParser.relative_to_delta","title":"<code>relative_to_delta(time)</code>  <code>classmethod</code>","text":"<p>Convert the given string containing a relative time into a datetime.timedelta</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str</code> <p>String consisting of a time in a relative format (e.g. '-1d')</p> required <p>Returns:</p> Type Description <code>timedelta</code> <p>A duration expressing the difference between two datetimes</p> Source code in <code>trace/utilities/time_parser.py</code> <pre><code>@classmethod\ndef relative_to_delta(cls, time: str) -&gt; datetime.timedelta:\n    \"\"\"Convert the given string containing a relative time into a\n    datetime.timedelta\n\n    Parameters\n    ----------\n    time : str\n        String consisting of a time in a relative format (e.g. '-1d')\n\n    Returns\n    -------\n    datetime.timedelta\n        A duration expressing the difference between two datetimes\n    \"\"\"\n    td = datetime.timedelta()\n    negative = True\n    for token in cls.relative_re.findall(time):\n        logger.debug(f\"Processing relative time token: {token}\")\n        if token[0] in \"+-\":\n            negative = token[0] == \"-\"\n        elif negative:\n            token = \"-\" + token\n        number = int(token[:-1])\n\n        unit = token[-1]\n        if unit == \"s\":\n            td += datetime.timedelta(seconds=number)\n        elif unit == \"m\":\n            td += datetime.timedelta(minutes=number)\n        elif unit == \"H\":\n            td += datetime.timedelta(hours=number)\n        elif unit == \"w\":\n            td += datetime.timedelta(weeks=number)\n        elif unit in \"yMd\":\n            if unit == \"y\":\n                number *= 365\n            elif unit == \"M\":\n                number *= 30\n            td += datetime.timedelta(days=number)\n    logger.debug(f\"Relative time '{time}' as delta: {td}\")\n    return td\n</code></pre>"},{"location":"reference/utilities/time_parser/#utilities.time_parser.IOTimeParser.set_time_on_datetime","title":"<code>set_time_on_datetime(dt, time_str)</code>  <code>classmethod</code>","text":"<p>Set an absolute time on a datetime object</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>The datetime to alter</p> required <code>time_str</code> <code>str</code> <p>The string containing the new time to set (e.g. '-1d 15:00')</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>The datetime object with the same date and the new time</p> Source code in <code>trace/utilities/time_parser.py</code> <pre><code>@classmethod\ndef set_time_on_datetime(cls, dt: datetime.datetime, time_str: str) -&gt; datetime.datetime:\n    \"\"\"Set an absolute time on a datetime object\n\n    Parameters\n    ----------\n    dt : datetime\n        The datetime to alter\n    time_str : str\n        The string containing the new time to set (e.g. '-1d 15:00')\n\n    Returns\n    -------\n    datetime\n        The datetime object with the same date and the new time\n    \"\"\"\n    # Get absolute time from string, return datetime if none\n    try:\n        time = cls.time_re.search(time_str).group()\n    except AttributeError:\n        return dt\n\n    if time.count(\":\") == 1:\n        time += \":00\"\n    h, m, s = map(int, map(float, time.split(\":\")))\n    dt = dt.replace(hour=h, minute=m, second=s)\n\n    return dt\n</code></pre>"},{"location":"reference/utilities/time_parser/#utilities.time_parser.IOTimeParser.parse_times","title":"<code>parse_times(start_str, end_str)</code>  <code>classmethod</code>","text":"<p>Convert 2 strings containing a start and end date &amp; time, return the values' datetime objects. The strings can be formatted as either absolute times or relative times. Both are needed as relative times may be relative to the other time.</p> <p>Parameters:</p> Name Type Description Default <code>start_str</code> <code>str</code> <p>The leftmost time the x-axis of the plot should show</p> required <code>end_str</code> <code>str</code> <p>The rigthmost time the x-axis of the plot should show, should be &gt;start</p> required <p>Returns:</p> Type Description <code>tuple[datetime, datetime]</code> <p>The python datetime objects for the exact start and end datetimes referenced</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>One of the given strings is in an incorrect format</p> Source code in <code>trace/utilities/time_parser.py</code> <pre><code>@classmethod\ndef parse_times(cls, start_str: str, end_str: str) -&gt; tuple[datetime.datetime, datetime.datetime]:\n    \"\"\"Convert 2 strings containing a start and end date &amp; time, return the\n    values' datetime objects. The strings can be formatted as either absolute\n    times or relative times. Both are needed as relative times may be relative\n    to the other time.\n\n    Parameters\n    ----------\n    start_str : str\n        The leftmost time the x-axis of the plot should show\n    end_str : str\n        The rigthmost time the x-axis of the plot should show, should be &gt;start\n\n    Returns\n    -------\n    tuple[datetime, datetime]\n        The python datetime objects for the exact start and end datetimes referenced\n\n    Raises\n    ------\n    ValueError\n        One of the given strings is in an incorrect format\n    \"\"\"\n    start_dt = start_delta = None\n    end_dt = end_delta = None\n    basetime = datetime.datetime.now()\n\n    # Process the end time string first to determine\n    # if the basetime is the start time, end time, or 'now'\n    if end_str == \"now\":\n        end_dt = basetime\n    elif cls.is_relative(end_str):\n        end_delta = cls.relative_to_delta(end_str)\n\n        # end_delta &gt;= 0 --&gt; the basetime is start time, so are processed after the start time\n        # end_delta &lt;  0 --&gt; the basetime is 'now'\n        if end_delta &lt; datetime.timedelta():\n            end_dt = basetime + end_delta\n            end_dt = cls.set_time_on_datetime(end_dt, end_str)\n    elif cls.is_absolute(end_str):\n        end_dt = datetime.datetime.fromisoformat(end_str)\n        basetime = end_dt\n    else:\n        raise ValueError(\"Time Axis end value is in an unexpected format.\")\n\n    # Process the start time string second, it may be used as the basetime\n    if cls.is_relative(start_str):\n        start_delta = cls.relative_to_delta(start_str)\n\n        # start_delta &gt;= 0 --&gt; raise ValueError; this isn't allowed\n        if start_delta &lt; datetime.timedelta():\n            start_dt = basetime + start_delta\n            start_dt = cls.set_time_on_datetime(start_dt, start_str)\n        else:\n            raise ValueError(\"Time Axis start value cannot be a relative time and be positive.\")\n    elif cls.is_absolute(start_str):\n        start_dt = datetime.datetime.fromisoformat(start_str)\n    else:\n        raise ValueError(\"Time Axis start value is in an unexpected format.\")\n\n    # If the end time is relative and end_delta &gt;= 0 --&gt; start time is the base\n    if end_delta and end_delta &gt;= datetime.timedelta():\n        basetime = start_dt\n        end_dt = end_delta + basetime\n        end_dt = cls.set_time_on_datetime(end_dt, end_str)\n\n    return (start_dt, end_dt)\n</code></pre>"},{"location":"reference/widgets/archive_search/","title":"Archive Search","text":""},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel","title":"<code>ArchiveResultsTableModel(parent=None)</code>","text":"<p>               Bases: <code>QAbstractTableModel</code></p> <p>This table model holds the results of an archiver appliance PV search. This search is for names matching the input search words, and the results are a list of PV names that match that search.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QObject</code> <p>The parent item of this table</p> <code>None</code> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def __init__(self, parent: QObject = None) -&gt; None:\n    super().__init__(parent=parent)\n    self.results_list = []\n    self.column_names = (\"PV\",)\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel.rowCount","title":"<code>rowCount(index=QModelIndex())</code>","text":"<p>Return the row count of the table</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def rowCount(self, index: QModelIndex = QModelIndex()) -&gt; int:\n    \"\"\"Return the row count of the table\"\"\"\n    if index is not None and index.isValid():\n        return 0\n    return len(self.results_list)\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel.columnCount","title":"<code>columnCount(index=QModelIndex())</code>","text":"<p>Return the column count of the table</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def columnCount(self, index: QModelIndex = QModelIndex()) -&gt; int:\n    \"\"\"Return the column count of the table\"\"\"\n    if index is not None and index.isValid():\n        return 0\n    return len(self.column_names)\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel.data","title":"<code>data(index, role)</code>","text":"<p>Return the data for the associated role. Currently only supporting DisplayRole.</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def data(self, index: QModelIndex, role: int) -&gt; Any:\n    \"\"\"Return the data for the associated role. Currently only supporting DisplayRole.\"\"\"\n    if not index.isValid():\n        return None\n\n    if role != Qt.DisplayRole:\n        return None\n\n    return self.results_list[index.row()]\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel.headerData","title":"<code>headerData(section, orientation, role=Qt.DisplayRole)</code>","text":"<p>Return data associated with the header</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def headerData(self, section, orientation, role=Qt.DisplayRole) -&gt; Any:\n    \"\"\"Return data associated with the header\"\"\"\n    if role != Qt.DisplayRole:\n        return super().headerData(section, orientation, role)\n\n    return str(self.column_names[section])\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel.flags","title":"<code>flags(index)</code>","text":"<p>Return flags that determine how users can interact with the items in the table</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def flags(self, index: QModelIndex) -&gt; Qt.ItemFlags:\n    \"\"\"Return flags that determine how users can interact with the items in the table\"\"\"\n    if index.isValid():\n        return Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel.append","title":"<code>append(pv)</code>","text":"<p>Appends a row to this table given the PV name as input</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def append(self, pv: str) -&gt; None:\n    \"\"\"Appends a row to this table given the PV name as input\"\"\"\n    self.beginInsertRows(QModelIndex(), len(self.results_list), len(self.results_list))\n    self.results_list.append(pv)\n    self.endInsertRows()\n    self.layoutChanged.emit()\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel.replace_rows","title":"<code>replace_rows(pvs)</code>","text":"<p>Overwrites any existing rows in the table with the input list of PV names</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def replace_rows(self, pvs: list[str]) -&gt; None:\n    \"\"\"Overwrites any existing rows in the table with the input list of PV names\"\"\"\n    self.beginInsertRows(QModelIndex(), 0, len(pvs) - 1)\n    self.results_list = pvs\n    self.endInsertRows()\n    self.layoutChanged.emit()\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel.clear","title":"<code>clear()</code>","text":"<p>Clear out all data stored in this table</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear out all data stored in this table\"\"\"\n    self.beginRemoveRows(QModelIndex(), 0, len(self.results_list))\n    self.results_list = []\n    self.endRemoveRows()\n    self.layoutChanged.emit()\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveResultsTableModel.sort","title":"<code>sort(col, order=Qt.AscendingOrder)</code>","text":"<p>Sort the table by PV name</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def sort(self, col: int, order=Qt.AscendingOrder) -&gt; None:\n    \"\"\"Sort the table by PV name\"\"\"\n    self.results_list.sort(reverse=order == Qt.DescendingOrder)\n    self.layoutChanged.emit()\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveSearchWidget","title":"<code>ArchiveSearchWidget(parent=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget for searching and selecting PVs from the EPICS archiver appliance.</p> <p>This widget provides a search interface for finding PVs by name patterns using the archiver appliance. Users can search for PVs and add them to the plot by selecting them from the results table.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QObject</code> <p>The parent item of this widget</p> <code>None</code> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QObject</code> <p>The parent object</p> <code>None</code> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def __init__(self, parent: QObject = None):\n    \"\"\"Initialize the archive search widget.\n\n    Parameters\n    ----------\n    parent : QObject, optional\n        The parent object\n    \"\"\"\n    super().__init__(parent=parent)\n\n    self.network_manager = QNetworkAccessManager()\n    self.network_manager.finished.connect(self.populate_results_list)\n\n    self.resize(400, 800)\n    self.main_layout = QVBoxLayout()\n\n    self.archive_url_layout = QHBoxLayout()\n    self.archive_title_label = QLabel(\"Archive URL:\")\n    self.archive_url_layout.addWidget(self.archive_title_label)\n    self.archive_url_textedit = QLineEdit(getenv(\"PYDM_ARCHIVER_URL\"))\n    self.archive_url_textedit.setFixedWidth(250)\n    self.archive_url_textedit.setFixedHeight(25)\n    self.archive_url_layout.addWidget(self.archive_url_textedit)\n    self.main_layout.addLayout(self.archive_url_layout)\n\n    self.search_layout = QHBoxLayout()\n    self.search_label = QLabel(\"Pattern:\")\n    self.search_layout.addWidget(self.search_label)\n    self.search_box = QLineEdit()\n    self.search_layout.addWidget(self.search_box)\n    self.search_button = QPushButton(\"Search\")\n    self.search_button.setDefault(True)\n    self.search_button.clicked.connect(self.request_archiver_info)\n    self.search_layout.addWidget(self.search_button)\n    self.main_layout.addLayout(self.search_layout)\n\n    self.loading_label = QLabel(\"Loading...\")\n    self.loading_label.hide()\n    self.main_layout.addWidget(self.loading_label)\n\n    self.results_table_model = ArchiveResultsTableModel()\n    self.results_view = QTableView(self)\n    self.results_view.setModel(self.results_table_model)\n    # self.results_view.setProperty(\"showDropIndicator\", False)\n    # self.results_view.setDragDropOverwriteMode(False)\n    # self.results_view.setDragEnabled(True)  # Removing drag &amp; drop for now\n    self.results_view.setSelectionMode(QAbstractItemView.ExtendedSelection)\n    self.results_view.setSelectionBehavior(QAbstractItemView.SelectRows)\n    # self.results_view.setDropIndicatorShown(True)\n    self.results_view.setCornerButtonEnabled(False)\n    self.results_view.setSortingEnabled(True)\n    self.results_view.verticalHeader().setVisible(False)\n    self.results_view.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)\n    # self.results_view.startDrag = self.startDragAction\n    self.results_view.doubleClicked.connect(lambda: self.append_PVs_requested.emit(self.selectedPVs()))\n    self.main_layout.addWidget(self.results_view)\n\n    self.insert_button = QPushButton(\"Add PVs\")\n    self.insert_button.clicked.connect(lambda: self.append_PVs_requested.emit(self.selectedPVs()))\n    self.main_layout.addWidget(self.insert_button)\n\n    self.setLayout(self.main_layout)\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveSearchWidget.selectedPVs","title":"<code>selectedPVs()</code>","text":"<p>Get the list of selected PVs from the results table.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of selected PV names</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def selectedPVs(self) -&gt; list[str]:\n    \"\"\"Get the list of selected PVs from the results table.\n\n    Returns\n    -------\n    list[str]\n        List of selected PV names\n    \"\"\"\n    indices = self.results_view.selectedIndexes()\n    pv_list = []\n    for index in indices:\n        pv_list.append(self.results_table_model.results_list[index.row()])\n    return pv_list\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveSearchWidget.startDragAction","title":"<code>startDragAction(supported_actions)</code>","text":"<p>Handle drag action for PV names.</p> <p>This method is called when a user initiates a drag action for one of the results in the table. It allows dragging PV names onto a plot to automatically start drawing data for that PV.</p> <p>Parameters:</p> Name Type Description Default <code>supported_actions</code> <code>DropActions</code> <p>The supported drop actions, unused</p> required Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def startDragAction(self, supported_actions) -&gt; None:\n    \"\"\"Handle drag action for PV names.\n\n    This method is called when a user initiates a drag action for one of\n    the results in the table. It allows dragging PV names onto a plot to\n    automatically start drawing data for that PV.\n\n    Parameters\n    ----------\n    supported_actions : Qt.DropActions\n        The supported drop actions, unused\n    \"\"\"\n    drag = QDrag(self)\n    mime_data = QMimeData()\n    mime_data.setText(self.selectedPVs())\n    drag.setMimeData(mime_data)\n    drag.exec_()\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveSearchWidget.keyPressEvent","title":"<code>keyPressEvent(e)</code>","text":"<p>Handle key press events for search submission.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>QKeyEvent</code> <p>The key press event</p> required Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def keyPressEvent(self, e: QKeyEvent) -&gt; None:\n    \"\"\"Handle key press events for search submission.\n\n    Parameters\n    ----------\n    e : QKeyEvent\n        The key press event\n    \"\"\"\n    if e.key() == Qt.Key_Return or e.key() == Qt.Key_Enter:\n        self.request_archiver_info()\n    return super().keyPressEvent(e)\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveSearchWidget.request_archiver_info","title":"<code>request_archiver_info()</code>","text":"<p>Send a search request to the archiver appliance.</p> <p>Converts the search text to a regex pattern and queries the archiver appliance for matching PV names.</p> Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def request_archiver_info(self) -&gt; None:\n    \"\"\"Send a search request to the archiver appliance.\n\n    Converts the search text to a regex pattern and queries the archiver\n    appliance for matching PV names.\n    \"\"\"\n    search_text = self.search_box.text()\n    search_text = search_text.replace(\"?\", \".\")\n    search_text = search_text.replace(\"*\", \".*\")\n    search_text = search_text.replace(\"%\", \".*\")\n    url_string = f\"{self.archive_url_textedit.text()}/retrieval/bpl/searchForPVsRegex?regex=.*{search_text}.*\"\n    request = QNetworkRequest(QUrl(url_string))\n    self.network_manager.get(request)\n    self.loading_label.show()\n</code></pre>"},{"location":"reference/widgets/archive_search/#widgets.archive_search.ArchiveSearchWidget.populate_results_list","title":"<code>populate_results_list(reply)</code>","text":"<p>Handle the response from the archiver appliance search.</p> <p>Parameters:</p> Name Type Description Default <code>reply</code> <code>QNetworkReply</code> <p>The network reply containing search results</p> required Source code in <code>trace/widgets/archive_search.py</code> <pre><code>def populate_results_list(self, reply: QNetworkReply) -&gt; None:\n    \"\"\"Handle the response from the archiver appliance search.\n\n    Parameters\n    ----------\n    reply : QNetworkReply\n        The network reply containing search results\n    \"\"\"\n    self.loading_label.hide()\n    if reply.error() == QNetworkReply.NoError:\n        self.results_table_model.clear()\n        bytes_str = reply.readAll()\n        pv_list = str(bytes_str, \"utf-8\").split()\n        self.results_table_model.replace_rows(pv_list)\n    else:\n        logger.error(f\"Could not retrieve archiver results due to: {reply.error()}\")\n    reply.deleteLater()\n</code></pre>"},{"location":"reference/widgets/control_panel/","title":"Control Panel","text":""},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel","title":"<code>ControlPanel(theme_manager=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Main control panel widget for managing plot axes and curves.</p> <p>This widget provides the primary interface for adding, configuring, and managing plot axes and their associated curves. It includes functionality for PV search, formula creation, and curve management.</p> <p>Parameters:</p> Name Type Description Default <code>theme_manager</code> <code>ThemeManager</code> <p>The theme manager for handling UI theming</p> <code>None</code> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def __init__(self, theme_manager: ThemeManager = None):\n    \"\"\"Initialize the control panel.\n\n    Parameters\n    ----------\n    theme_manager : ThemeManager, optional\n        The theme manager for handling UI theming\n    \"\"\"\n    super().__init__()\n    self.theme_manager = theme_manager\n    self.setLayout(QtWidgets.QVBoxLayout())\n    # self.setStyleSheet(\"background-color: white;\")\n\n    self._curve_dict = {}\n    self.key_gen = self._generate_curve_key()\n    next(self.key_gen)  # Prime the generator\n\n    self.curve_palette = \"default\"\n    if self.theme_manager:\n        self.theme_manager.theme_changed.connect(self.on_theme_changed)\n\n    # Create pv plotter layout\n    pv_plotter_layout = QtWidgets.QHBoxLayout()\n    self.layout().addLayout(pv_plotter_layout)\n    self.search_button = QtWidgets.QPushButton()\n    self.search_button.setFlat(True)\n    self.search_button.clicked.connect(self.search_pv)\n    pv_plotter_layout.addWidget(self.search_button)\n\n    self.calc_button = QtWidgets.QPushButton()\n    self.calc_button.setFlat(True)\n    self.calc_button.clicked.connect(self.show_formula_dialog)\n    pv_plotter_layout.addWidget(self.calc_button)\n\n    self.pv_line_edit = QtWidgets.QLineEdit()\n    self.pv_line_edit.setPlaceholderText(\"Enter PV\")\n    self.pv_line_edit.returnPressed.connect(self.add_curve_from_line_edit)\n    pv_plotter_layout.addWidget(self.pv_line_edit)\n    pv_plot_button = QtWidgets.QPushButton(\"Plot\")\n    pv_plot_button.clicked.connect(self.add_curve_from_line_edit)\n    pv_plotter_layout.addWidget(pv_plot_button)\n\n    self.axis_list = QtWidgets.QVBoxLayout()\n    frame = QtWidgets.QFrame()\n    frame.setLayout(self.axis_list)\n    scrollarea = QtWidgets.QScrollArea()\n    scrollarea.setWidgetResizable(True)\n    scrollarea.setWidget(frame)\n    self.layout().addWidget(scrollarea)\n    self.axis_list.addStretch()\n\n    new_axis_button = QtWidgets.QPushButton(\"New Axis\")\n    new_axis_button.clicked.connect(self.add_empty_axis)\n    self.layout().addWidget(new_axis_button)\n\n    self.archive_search = ArchiveSearchWidget()\n    self.archive_search.append_PVs_requested.connect(self.add_curves)\n\n    self.formula_dialog = FormulaDialog(self)\n    self.formula_dialog.formula_accepted.connect(self.handle_formula_accepted)\n    self.curve_list_changed.connect(self.formula_dialog.curve_model.refresh)\n\n    self.update_icons()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.plot","title":"<code>plot</code>  <code>property</code> <code>writable</code>","text":"<p>Get the associated plot widget.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.curve_dict","title":"<code>curve_dict</code>  <code>property</code>","text":"<p>Return dictionary of curves with PV keys.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.curve_item_dict","title":"<code>curve_item_dict</code>  <code>property</code>","text":"<p>Returns dictionary of curves on plot with associated pvname, axisItem, and curveItem</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.update_icons","title":"<code>update_icons()</code>","text":"<p>Update all icons based on current theme.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def update_icons(self) -&gt; None:\n    \"\"\"Update all icons based on current theme.\"\"\"\n    if self.theme_manager:\n        calc_icon = self.theme_manager.create_icon(\"fa6s.calculator\", IconColors.PRIMARY)\n        if calc_icon:\n            self.calc_button.setIcon(calc_icon)\n        search_icon = self.theme_manager.create_icon(\"fa6s.magnifying-glass\", IconColors.PRIMARY)\n        if search_icon:\n            self.search_button.setIcon(search_icon)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.on_theme_changed","title":"<code>on_theme_changed(theme)</code>","text":"<p>Handle theme changes by updating icons.</p> <p>Parameters:</p> Name Type Description Default <code>theme</code> <code>Theme</code> <p>The new theme, unused</p> required Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def on_theme_changed(self, theme: Theme) -&gt; None:\n    \"\"\"Handle theme changes by updating icons.\n\n    Parameters\n    ----------\n    theme : Theme\n        The new theme, unused\n    \"\"\"\n    self.update_icons()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.minimumSizeHint","title":"<code>minimumSizeHint()</code>","text":"<p>Return the minimum size hint for the control panel.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def minimumSizeHint(self) -&gt; QtCore.QSize:\n    \"\"\"Return the minimum size hint for the control panel.\"\"\"\n    inner_size = self.axis_list.minimumSize()\n    buffer = self.pv_line_edit.font().pointSize() * 3\n    return QtCore.QSize(inner_size.width() + buffer, inner_size.height())\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.add_curve_from_line_edit","title":"<code>add_curve_from_line_edit()</code>","text":"<p>Add a curve from the PV line edit input.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def add_curve_from_line_edit(self) -&gt; None:\n    \"\"\"Add a curve from the PV line edit input.\"\"\"\n    pv = self.pv_line_edit.text()\n    self.add_curve(pv)\n    self.pv_line_edit.clear()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.search_pv","title":"<code>search_pv()</code>","text":"<p>Show or activate the PV search widget.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def search_pv(self) -&gt; None:\n    \"\"\"Show or activate the PV search widget.\"\"\"\n    if not self.archive_search.isVisible():\n        self.archive_search.show()\n    else:\n        self.archive_search.raise_()\n        self.archive_search.activateWindow()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.show_formula_dialog","title":"<code>show_formula_dialog()</code>","text":"<p>Show the formula dialog pop-up.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def show_formula_dialog(self):\n    \"\"\"Show the formula dialog pop-up.\"\"\"\n    if not hasattr(self, \"formula_dialog\") or not self.formula_dialog.isVisible():\n        self.formula_dialog.show()\n    else:\n        self.formula_dialog.raise_()\n        self.formula_dialog.activateWindow()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.handle_formula_accepted","title":"<code>handle_formula_accepted(formula)</code>","text":"<p>Handle the formula accepted from the formula dialog.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>The accepted formula string</p> required Source code in <code>trace/widgets/control_panel.py</code> <pre><code>@QtCore.Slot(str)\ndef handle_formula_accepted(self, formula: str) -&gt; None:\n    \"\"\"Handle the formula accepted from the formula dialog.\n\n    Parameters\n    ----------\n    formula : str\n        The accepted formula string\n    \"\"\"\n    self.add_curve(formula)\n    self.cleanup_duplicate_curves()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.cleanup_duplicate_curves","title":"<code>cleanup_duplicate_curves()</code>","text":"<p>Remove duplicate entries in curve dictionary.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def cleanup_duplicate_curves(self) -&gt; None:\n    \"\"\"Remove duplicate entries in curve dictionary.\"\"\"\n    seen_curves = {}\n    to_remove = []\n\n    for key, curve in self._curve_dict.items():\n        curve_id = id(curve)\n        if curve_id in seen_curves:\n            to_remove.append(key)\n        else:\n            seen_curves[curve_id] = key\n\n    for key in to_remove:\n        del self._curve_dict[key]\n\n    if to_remove:\n        self.curve_list_changed.emit()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.add_curves","title":"<code>add_curves(pvs)</code>","text":"<p>Add multiple curves from a list of PV names.</p> <p>Parameters:</p> Name Type Description Default <code>pvs</code> <code>list[str]</code> <p>List of PV names to add as curves</p> required Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def add_curves(self, pvs: list[str]) -&gt; None:\n    \"\"\"Add multiple curves from a list of PV names.\n\n    Parameters\n    ----------\n    pvs : list[str]\n        List of PV names to add as curves\n    \"\"\"\n    for pv in pvs:\n        self.add_curve(pv)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.add_axis_item","title":"<code>add_axis_item(axis)</code>","text":"<p>Add an existing AxisItem to the plot.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def add_axis_item(self, axis: BasePlotAxisItem) -&gt; \"AxisItem\":\n    \"\"\"Add an existing AxisItem to the plot.\"\"\"\n    self.match_axis_tick_font(axis)\n    axis_item = AxisItem(axis, control_panel=self, theme_manager=self.theme_manager)\n    axis_item.curves_list_changed.connect(self.curve_list_changed.emit)\n    self.axis_list.insertWidget(self.axis_list.count() - 1, axis_item)\n    logger.debug(f\"Added axis {axis.name} to plot\")\n    self.updateGeometry()\n\n    return axis_item\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.match_axis_tick_font","title":"<code>match_axis_tick_font(axis)</code>","text":"<p>Matches the axis' tick font to the X-Axis of the plot. Only necessary if the user has changed the tick font of the plot's axes.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>BasePlotAxisItem</code> <p>The axis to match the tick font for.</p> required Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def match_axis_tick_font(self, axis: BasePlotAxisItem) -&gt; None:\n    \"\"\"Matches the axis' tick font to the X-Axis of the plot. Only necessary\n    if the user has changed the tick font of the plot's axes.\n\n    Parameters\n    ----------\n    axis : BasePlotAxisItem\n        The axis to match the tick font for.\"\"\"\n    x_axis = self.plot.getAxis(\"bottom\")\n    if x_axis is not None:\n        axis.setTickFont(x_axis.style[\"tickFont\"])\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.get_axis_item","title":"<code>get_axis_item(axis_name)</code>","text":"<p>Get an AxisItem by its name.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def get_axis_item(self, axis_name: str) -&gt; \"AxisItem\":\n    \"\"\"Get an AxisItem by its name.\"\"\"\n    for index in range(self.axis_list.count()):\n        item = self.axis_list.itemAt(index).widget()\n        if isinstance(item, AxisItem) and item.name == axis_name:\n            return item\n    return None\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.get_last_axis_item","title":"<code>get_last_axis_item()</code>","text":"<p>Get the last AxisItem in the list.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def get_last_axis_item(self) -&gt; \"AxisItem\":\n    \"\"\"Get the last AxisItem in the list.\"\"\"\n    if self.axis_list.count() &gt; 1:  # the stretch makes count &gt;= 1\n        return self.axis_list.itemAt(self.axis_list.count() - 2).widget()\n    else:\n        logger.warning(\"No axes available to return the last AxisItem.\")\n        return None\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.set_curve_palette","title":"<code>set_curve_palette(palette_name, apply=False)</code>","text":"<p>Set the default palette for new curves.</p> <p>Parameters:     palette_name (str): name of selected palette     apply (bool): If true, apply palette to exiting curves</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def set_curve_palette(self, palette_name: str, apply: bool = False) -&gt; None:\n    \"\"\"\n    Set the default palette for new curves.\n\n    Parameters:\n        palette_name (str): name of selected palette\n        apply (bool): If true, apply palette to exiting curves\n    \"\"\"\n    self.curve_palette = palette_name\n    if apply:\n        for index, curve in enumerate(self.curve_item_dict.keys()):\n            color = ColorButton.index_color(index, palette=self.curve_palette)\n            curve.color = color\n            self.curve_item_dict[curve][\"curveItem\"].on_color_changed(color)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all axes and curves from the plot and control panel.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all axes and curves from the plot and control panel.\"\"\"\n    logger.debug(\"Clearing all axes and curves from the plot\")\n    while self.axis_list.count() &gt; 1:  # Keep the stretch at the end\n        self.axis_list.itemAt(0).widget().close()\n    self.plot.redrawPlot()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.clear_curves","title":"<code>clear_curves()</code>","text":"<p>Clear all curves from the plot and control panel.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def clear_curves(self) -&gt; None:\n    \"\"\"Clear all curves from the plot and control panel.\"\"\"\n    logger.debug(\"Clearing all curves from the plot\")\n    for axis_item in self.axis_list:\n        if isinstance(axis_item, AxisItem):\n            axis_item.clear_curves()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.set_axes","title":"<code>set_axes(axes=None)</code>","text":"<p>Given a list of dictionaries containing axis data, clear the plot's axes, and set all new axes based on the provided axis data.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>List[Dict]</code> <p>Axis properties to be set for all new axes on the plot</p> <code>None</code> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def set_axes(self, axes: list[dict] = None) -&gt; None:\n    \"\"\"Given a list of dictionaries containing axis data, clear the\n    plot's axes, and set all new axes based on the provided axis data.\n\n    Parameters\n    ----------\n    axes : List[Dict]\n        Axis properties to be set for all new axes on the plot\n    \"\"\"\n    self.clear_all()\n    for axis in axes:\n        self.plot.addAxis(\n            plot_data_item=None,\n            name=axis[\"name\"],\n            orientation=axis.get(\"orientation\", \"left\"),\n            label=axis[\"name\"],\n            log_mode=axis.get(\"logMode\", False),\n        )\n        # Convert axis properties to match BasePlotAxisItem\n        new_axis = self.plot._axes[-1]\n        new_axis.setLabel(axis[\"name\"], color=\"black\")\n\n        new_axis_item = self.add_axis_item(new_axis)\n        if \"minRange\" in axis:\n            new_axis_item.set_min_range(axis[\"minRange\"])\n        if \"maxRange\" in axis:\n            new_axis_item.set_max_range(axis[\"maxRange\"])\n        if \"autoRange\" in axis:\n            new_axis_item.auto_range_checkbox.setChecked(axis[\"autoRange\"])\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.set_curves","title":"<code>set_curves(curves=None)</code>","text":"<p>Given a list of dictionaries containing curve data, clear the plot's curves, and set all new curves based on the provided curve data.</p> <p>Parameters:</p> Name Type Description Default <code>curves</code> <code>List[Dict]</code> <p>Curve properties to be set for all new curves on the plot</p> <code>None</code> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def set_curves(self, curves: list[dict] = None) -&gt; None:\n    \"\"\"Given a list of dictionaries containing curve data, clear the\n    plot's curves, and set all new curves based on the provided curve data.\n\n    Parameters\n    ----------\n    curves : List[Dict]\n        Curve properties to be set for all new curves on the plot\n    \"\"\"\n    for curve_dict in curves:\n        try:\n            axis_name = curve_dict.get(\"yAxisName\", \"Y-Axis 0\")\n            axis_item = self.get_axis_item(axis_name)\n        except KeyError:\n            axis_item = self.get_last_axis_item()\n\n        if axis_item is None:\n            axis_item = self.add_empty_axis(axis_name)\n\n        pv_name = curve_dict.get(\"channel\", \"\")\n        del curve_dict[\"channel\"]  # Remove channel key to avoid conflicts with y_channel\n        axis_item.add_curve(pv_name, curve_dict)\n    self.plot.redrawPlot()\n    self.axis_list.itemAt(self.axis_list.count() - 2).widget()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.move_curve_to_axis","title":"<code>move_curve_to_axis(curve_item, target_axis_name)</code>","text":"<p>Remove a given CurveItem from its current AxisItem and add it to the AxisItem with the given target axis name. If no such AxisItem exists, a new one will be created. Intended to be used for Axes named after a curve's unit.</p> <p>Parameters:</p> Name Type Description Default <code>curve_item</code> <code>CurveItem</code> <p>CurveItem to be moved to a new axis.</p> required <code>target_axis_name</code> <code>str</code> <p>Name of the target axis to move the CurveItem to.</p> required Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def move_curve_to_axis(self, curve_item: \"CurveItem\", target_axis_name: str) -&gt; None:\n    \"\"\"Remove a given CurveItem from its current AxisItem and add it to\n    the AxisItem with the given target axis name. If no such AxisItem\n    exists, a new one will be created. Intended to be used for Axes\n    named after a curve's unit.\n\n    Parameters\n    ----------\n    curve_item : CurveItem\n        CurveItem to be moved to a new axis.\n    target_axis_name : str\n        Name of the target axis to move the CurveItem to.\n    \"\"\"\n    axis_item = self.get_axis_item(target_axis_name)\n    if axis_item is None:\n        axis_item = self.add_empty_axis(target_axis_name)\n\n    old_axis_item = curve_item.axis_item\n    old_axis_item.remove_curve_item(curve_item)\n    axis_item.add_curve_item(curve_item)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem","title":"<code>AxisItem(plot_axis_item, control_panel=None, theme_manager=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget for managing a single plot axis and its associated curves.</p> <p>This widget provides controls for axis configuration including name, range, auto-scaling, and curve management. It supports drag-and-drop for curve reordering and moving curves between axes.</p> <p>Parameters:</p> Name Type Description Default <code>plot_axis_item</code> <code>BasePlotAxisItem</code> <p>The plot axis item to manage</p> required <code>control_panel</code> <code>ControlPanel</code> <p>Reference to the parent control panel</p> <code>None</code> <code>theme_manager</code> <code>ThemeManager</code> <p>The theme manager for UI theming</p> <code>None</code> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def __init__(\n    self, plot_axis_item: BasePlotAxisItem, control_panel: ControlPanel = None, theme_manager: ThemeManager = None\n):\n    \"\"\"Initialize the axis item widget.\n\n    Parameters\n    ----------\n    plot_axis_item : BasePlotAxisItem\n        The plot axis item to manage\n    control_panel : ControlPanel, optional\n        Reference to the parent control panel\n    theme_manager : ThemeManager, optional\n        The theme manager for UI theming\n    \"\"\"\n    super().__init__()\n    self.source = plot_axis_item\n    self.control_panel_ref = control_panel\n    self.theme_manager = theme_manager\n    self.setLayout(QtWidgets.QVBoxLayout())\n    self.setAcceptDrops(True)\n\n    if self.theme_manager:\n        self.theme_manager.theme_changed.connect(self.on_theme_changed)\n\n    self.header_layout = QtWidgets.QHBoxLayout()\n    self.layout().addLayout(self.header_layout)\n\n    self._expanded = False\n    self.expand_button = QtWidgets.QPushButton()\n    self.expand_button.setFlat(True)\n    self.expand_button.clicked.connect(self.toggle_expand)\n    self.header_layout.addWidget(self.expand_button)\n\n    layout = QtWidgets.QVBoxLayout()\n    self.header_layout.addLayout(layout)\n    self.top_settings_layout = QtWidgets.QHBoxLayout()\n    layout.addLayout(self.top_settings_layout)\n    self.axis_label = QtWidgets.QLineEdit()\n    self.axis_label.setText(self.source.name)\n    self.axis_label.editingFinished.connect(self.set_axis_name)\n    self.axis_label.returnPressed.connect(self.axis_label.clearFocus)\n    self.top_settings_layout.addWidget(self.axis_label)\n    self.settings_button = QtWidgets.QPushButton()\n    self.settings_button.setFlat(True)\n    self.settings_modal = None\n    self.settings_button.clicked.connect(self.show_settings_modal)\n    self.top_settings_layout.addWidget(self.settings_button)\n    self.delete_button = QtWidgets.QPushButton()\n    self.delete_button.setFlat(True)\n    self.delete_button.clicked.connect(self.close)\n    self.top_settings_layout.addWidget(self.delete_button)\n    self.bottom_settings_layout = QtWidgets.QHBoxLayout()\n    layout.addLayout(self.bottom_settings_layout)\n    self.auto_range_checkbox = QtWidgets.QCheckBox(\"Auto\")\n    self.auto_range_checkbox.setCheckState(QtCore.Qt.Checked if self.source.auto_range else QtCore.Qt.Unchecked)\n    self.auto_range_checkbox.stateChanged.connect(self.set_auto_range)\n    self.source.linkedView().sigRangeChangedManually.connect(self.disable_auto_range)\n    self.bottom_settings_layout.addWidget(self.auto_range_checkbox)\n    self.bottom_settings_layout.addWidget(QtWidgets.QLabel(\"min, max\"))\n    self.min_range_line_edit = QtWidgets.QLineEdit()\n    self.min_range_line_edit.editingFinished.connect(self.set_min_range)\n    self.min_range_line_edit.editingFinished.connect(self.disable_auto_range)\n    self.min_range_line_edit.setMinimumWidth(self.min_range_line_edit.font().pointSize() * 8)\n    self.bottom_settings_layout.addWidget(self.min_range_line_edit)\n    self.bottom_settings_layout.addWidget(QtWidgets.QLabel(\",\"))\n    self.max_range_line_edit = QtWidgets.QLineEdit()\n    self.max_range_line_edit.editingFinished.connect(self.set_max_range)\n    self.max_range_line_edit.editingFinished.connect(self.disable_auto_range)\n    self.max_range_line_edit.setMinimumWidth(self.max_range_line_edit.font().pointSize() * 8)\n    self.bottom_settings_layout.addWidget(self.max_range_line_edit)\n    self.source.sigYRangeChanged.connect(self.handle_range_change)\n\n    self.active_toggle = ToggleSwitch(\"Active\")\n    self.active_toggle.setCheckState(QtCore.Qt.Checked if self.source.isVisible() else QtCore.Qt.Unchecked)\n    self.active_toggle.stateChanged.connect(self.set_active)\n    self.header_layout.addWidget(self.active_toggle)\n\n    self.placeholder = QtWidgets.QWidget(self)\n    self.placeholder.hide()\n    self.placeholder.setStyleSheet(\"background-color: lightgrey;\")\n\n    self.update_icons()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the axis.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.update_icons","title":"<code>update_icons()</code>","text":"<p>Update all icons based on current theme</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def update_icons(self):\n    \"\"\"Update all icons based on current theme\"\"\"\n    if self.theme_manager:\n        if self._expanded:\n            expand_icon = self.theme_manager.create_icon(\"msc.chevron-down\", IconColors.PRIMARY)\n        else:\n            expand_icon = self.theme_manager.create_icon(\"msc.chevron-right\", IconColors.PRIMARY)\n\n        if expand_icon:\n            self.expand_button.setIcon(expand_icon)\n\n        settings_icon = self.theme_manager.create_icon(\"msc.settings-gear\", IconColors.PRIMARY)\n        if settings_icon:\n            self.settings_button.setIcon(settings_icon)\n\n        delete_icon = self.theme_manager.create_icon(\"msc.trash\", IconColors.PRIMARY)\n        if delete_icon:\n            self.delete_button.setIcon(delete_icon)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.on_theme_changed","title":"<code>on_theme_changed(theme)</code>","text":"<p>Handle theme changes by updating icons</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def on_theme_changed(self, theme: Theme):\n    \"\"\"Handle theme changes by updating icons\"\"\"\n    self.update_icons()\n\n    # Change axis label color to match theme\n    label_text = self.source.labelText\n    self.source.setLabel(label_text, color=self.theme_manager.get_icon_color())\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.make_curve_widget","title":"<code>make_curve_widget(plot_curve_item)</code>","text":"<p>Create a CurveItem widget for the given plot curve item and add it to this AxisItem.</p> <p>Parameters:</p> Name Type Description Default <code>plot_curve_item</code> <code>ArchivePlotCurveItem | FormulaCurveItem</code> <p>The plot curve item to create a CurveItem for.</p> required <p>Returns:</p> Type Description <code>CurveItem</code> <p>The created CurveItem widget.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def make_curve_widget(self, plot_curve_item: ArchivePlotCurveItem | FormulaCurveItem) -&gt; \"CurveItem\":\n    \"\"\"Create a CurveItem widget for the given plot curve item and add\n    it to this AxisItem.\n\n    Parameters\n    ----------\n    plot_curve_item : ArchivePlotCurveItem | FormulaCurveItem\n        The plot curve item to create a CurveItem for.\n\n    Returns\n    -------\n    CurveItem\n        The created CurveItem widget.\n    \"\"\"\n    curve_item = CurveItem(self, plot_curve_item)\n    curve_item.curve_deleted.connect(lambda curve: self.handle_curve_deleted(curve))\n    curve_item.active_toggle.setCheckState(self.active_toggle.checkState())\n\n    self.layout().addWidget(curve_item)\n    self.curves_list_changed.emit()\n\n    if not self._expanded:\n        self.toggle_expand()\n\n    return curve_item\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.add_curve","title":"<code>add_curve(pv, channel_args=None)</code>","text":"<p>Create a new ArchivePlotCurveItem for the given PV and add it to this AxisItem. Also creates a CurveItem widget for it.</p> <p>Parameters:</p> Name Type Description Default <code>pv</code> <code>str</code> <p>The process variable name to create the curve for.</p> required <code>channel_args</code> <code>dict</code> <p>The arguments to pass to the ArchivePlotCurveItem constructor, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>CurveItem</code> <p>The created CurveItem widget.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def add_curve(self, pv: str, channel_args: dict = None) -&gt; \"CurveItem\":\n    \"\"\"Create a new ArchivePlotCurveItem for the given PV and add it\n    to this AxisItem. Also creates a CurveItem widget for it.\n\n    Parameters\n    ----------\n    pv : str\n        The process variable name to create the curve for.\n    channel_args : dict, optional\n        The arguments to pass to the ArchivePlotCurveItem constructor,\n        by default None\n\n    Returns\n    -------\n    CurveItem\n        The created CurveItem widget.\n    \"\"\"\n    palette = self.control_panel.curve_palette\n    color = ColorButton.index_color(len(self.plot._curves), palette=palette)\n    args = {\n        \"y_channel\": pv,\n        \"name\": pv,\n        \"color\": color,\n        \"useArchiveData\": True,\n        \"yAxisName\": self.source.name,\n    }\n    if channel_args is not None:\n        args.update(channel_args)\n\n    plot_curve_item = self.plot.addYChannel(**args)\n\n    return self.make_curve_widget(plot_curve_item)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.add_formula_curve","title":"<code>add_formula_curve(formula)</code>","text":"<p>Create a new FormulaCurveItem for the given formula and add it to this AxisItem. Also creates a CurveItem widget for it.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>The formula to create the curve for. Must start with \"f://\".</p> required <p>Returns:</p> Type Description <code>CurveItem</code> <p>The created CurveItem widget.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def add_formula_curve(self, formula: str) -&gt; \"CurveItem\":\n    \"\"\"Create a new FormulaCurveItem for the given formula and add it\n    to this AxisItem. Also creates a CurveItem widget for it.\n\n    Parameters\n    ----------\n    formula : str\n        The formula to create the curve for. Must start with \"f://\".\n\n    Returns\n    -------\n    CurveItem\n        The created CurveItem widget.\n    \"\"\"\n    var_names = re.findall(r\"{(.+?)}\", formula)\n    var_dict = {}\n\n    for var_name in var_names:\n        if var_name not in self.control_panel._curve_dict:\n            available_vars = list(self.control_panel._curve_dict.keys())\n            raise ValueError(f\"{var_name} is an invalid variable name. Available: {available_vars}\")\n        var_dict[var_name] = self.control_panel._curve_dict[var_name]\n\n    expr_body = formula[4:]\n    python_expr, allowed = sanitize_for_validation(expr_body)\n    try:\n        validate_formula(python_expr, allowed_symbols=allowed)\n    except ValueError as e:\n        logger.error(f\"Invalid formula '{formula}': {e}\")\n        raise\n\n    color = ColorButton.index_color((len(self.plot._curves)), palette=self.control_panel.curve_palette)\n    formula_curve_item = self.plot.addFormulaChannel(\n        formula=formula, name=formula, pvs=var_dict, color=color, useArchiveData=True, yAxisName=self.source.name\n    )\n    formula_curve_item.formula_invalid_signal.connect(self.auto_hide_invalid_formula)\n\n    return self.make_curve_widget(formula_curve_item)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.auto_hide_invalid_formula","title":"<code>auto_hide_invalid_formula(formula_curve=None)</code>","text":"<p>Automatically hide a formula when it becomes invalid</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>@Slot()\n@Slot(FormulaCurveItem)\ndef auto_hide_invalid_formula(self, formula_curve: FormulaCurveItem = None) -&gt; None:\n    \"\"\"Automatically hide a formula when it becomes invalid\"\"\"\n    if formula_curve is None:\n        formula_curve = self.sender()\n\n    curve_item = self.find_curve_item_for_curve(formula_curve)\n    if curve_item and hasattr(curve_item, \"active_toggle\"):\n        curve_item.active_toggle.setChecked(False)\n        if hasattr(curve_item, \"show_invalid_icon\"):\n            curve_item.show_invalid_icon(True)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.find_curve_item_for_curve","title":"<code>find_curve_item_for_curve(target_curve)</code>","text":"<p>Find the CurveItem widget that corresponds to a given curve</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def find_curve_item_for_curve(self, target_curve):\n    \"\"\"Find the CurveItem widget that corresponds to a given curve\"\"\"\n    for i in range(self.layout().count()):\n        widget = self.layout().itemAt(i).widget()\n        if hasattr(widget, \"source\") and widget.source == target_curve:\n            return widget\n\n    for i in range(self.control_panel.axis_list.count() - 1):  # -1 for stretch\n        axis_item = self.control_panel.axis_list.itemAt(i).widget()\n        if hasattr(axis_item, \"layout\"):\n            for j in range(axis_item.layout().count()):\n                widget = axis_item.layout().itemAt(j).widget()\n                if hasattr(widget, \"source\") and widget.source == target_curve:\n                    return widget\n\n    return None\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.set_curve_palette","title":"<code>set_curve_palette(palette_name, apply=True)</code>","text":"<p>Set colors of all curves on this axisItem according to selected palette</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def set_curve_palette(self, palette_name: str, apply: bool = True):\n    \"\"\"Set colors of all curves on this axisItem according to selected palette\"\"\"\n    if apply:\n        for j in range(self.layout().count()):\n            widget = self.layout().itemAt(j).widget()\n            if hasattr(widget, \"source\"):\n                curve = widget.source\n                color = ColorButton.index_color(j - 1, palette=palette_name)\n                curve.color = color\n                self.find_curve_item_for_curve(curve).on_color_changed(color)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.remove_curve_item","title":"<code>remove_curve_item(curve_item, delete_curve=False)</code>","text":"<p>Removes the given CurveItem from the AxisItem and plot's axis. This is required for moving a CurveItem to a new AxisItem. Can delete the CurveItem and curve if specified. This will remove it from the plot.</p> <p>Parameters:</p> Name Type Description Default <code>curve_item</code> <code>CurveItem</code> <p>The CurveItem to be removed from the axis.</p> required <code>delete_curve</code> <code>bool</code> <p>If True, the CurveItem will be deleted and the curve removed from the plot entirely. If False, it will just be unlinked from this axis., by default False.</p> <code>False</code> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def remove_curve_item(self, curve_item: \"CurveItem\", delete_curve: bool = False) -&gt; None:\n    \"\"\"Removes the given CurveItem from the AxisItem and plot's axis.\n    This is required for moving a CurveItem to a new AxisItem. Can\n    delete the CurveItem and curve if specified. This will remove it\n    from the plot.\n\n    Parameters\n    ----------\n    curve_item : CurveItem\n        The CurveItem to be removed from the axis.\n    delete_curve : bool, optional\n        If True, the CurveItem will be deleted and the curve removed\n        from the plot entirely. If False, it will just be unlinked\n        from this axis., by default False.\n    \"\"\"\n    curve_item.curve_deleted.disconnect()\n    self.layout().removeWidget(curve_item)\n    self.plot.plotItem.unlinkDataFromAxis(curve_item.source)\n\n    if delete_curve:\n        curve_item.close()\n    self.curves_list_changed.emit()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.add_curve_item","title":"<code>add_curve_item(curve_item)</code>","text":"<p>Add an existing CurveItem to this AxisItem.</p> <p>Parameters:</p> Name Type Description Default <code>curve_item</code> <code>CurveItem</code> <p>The CurveItem to be added to this axis.</p> required Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def add_curve_item(self, curve_item: \"CurveItem\") -&gt; None:\n    \"\"\"Add an existing CurveItem to this AxisItem.\n\n    Parameters\n    ----------\n    curve_item : CurveItem\n        The CurveItem to be added to this axis.\n    \"\"\"\n    # Need to link curve to axis before setting y_axis_name on curve\n    self.plot.plotItem.linkDataToAxis(curve_item.source, self.name)\n    curve_item.source.y_axis_name = self.name\n\n    curve_item.curve_deleted.connect(lambda curve: self.handle_curve_deleted(curve))\n    curve_item.active_toggle.setCheckState(self.active_toggle.checkState())\n\n    if self.layout().indexOf(curve_item) != -1:\n        self.layout().removeWidget(curve_item)\n\n    idx = self.layout().indexOf(self.placeholder)\n    self.layout().insertWidget(idx, curve_item)\n\n    if not self._expanded:\n        self.toggle_expand()\n    self.curves_list_changed.emit()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.clear_curves","title":"<code>clear_curves()</code>","text":"<p>Clear all curves from this axis item.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def clear_curves(self) -&gt; None:\n    \"\"\"Clear all curves from this axis item.\"\"\"\n    for i in range(self.layout().count() - 1, -1, -1):\n        item = self.layout().itemAt(i).widget()\n        if isinstance(item, CurveItem):\n            self.remove_curve_item(item, delete_curve=True)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem","title":"<code>CurveItem(axis_item, source)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget for managing a single curve on the plot.</p> <p>This widget provides controls for curve configuration including name, color, visibility, and connection status. It supports drag-and-drop for moving curves between axes and formula editing for formula curves.</p> <p>Parameters:</p> Name Type Description Default <code>axis_item</code> <code>AxisItem</code> <p>The parent axis item</p> required <code>source</code> <code>ArchivePlotCurveItem or FormulaCurveItem</code> <p>The plot curve item to manage</p> required Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def __init__(self, axis_item: AxisItem, source: ArchivePlotCurveItem | FormulaCurveItem):\n    \"\"\"Initialize the curve item widget.\n\n    Parameters\n    ----------\n    axis_item : AxisItem\n        The parent axis item\n    source : ArchivePlotCurveItem or FormulaCurveItem\n        The plot curve item to manage\n    \"\"\"\n    super().__init__()\n    self._axis_item = axis_item\n    self.source = source\n    self.control_panel = axis_item.control_panel\n\n    self.theme_manager = axis_item.theme_manager\n    self.theme_manager.theme_changed.connect(lambda _: self.update_icons())\n\n    self.variable_name = self.control_panel.key_gen.send(self.source)\n    self.control_panel.curve_dict[self.variable_name] = self.source\n    if not self.is_formula_curve():\n        self.source.unitSignal.connect(lambda unit: self.control_panel.move_curve_to_axis(self, unit))\n\n    self.setup_layout()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.plot","title":"<code>plot</code>  <code>property</code>","text":"<p>Get the PlotWidget that this CurveItem belongs to.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.axis_item","title":"<code>axis_item</code>  <code>property</code>","text":"<p>Get the AxisItem that this CurveItem belongs to.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.setup_layout","title":"<code>setup_layout()</code>","text":"<p>Setup the layout and widgets for the CurveItem.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def setup_layout(self):\n    \"\"\"Setup the layout and widgets for the CurveItem.\"\"\"\n    curve_layout = QtWidgets.QHBoxLayout()\n    self.setLayout(curve_layout)\n\n    self.handle = DragHandle()\n    self.handle.setFlat(True)\n    self.handle.setStyleSheet(\"border: None;\")\n    self.handle.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor))\n    curve_layout.addWidget(self.handle)\n\n    self.active_toggle = ToggleSwitch(\"Active\", color=self.source.color_string)\n    self.active_toggle.setCheckState(QtCore.Qt.Checked if self.source.isVisible() else QtCore.Qt.Unchecked)\n    self.active_toggle.stateChanged.connect(self.set_active)\n    curve_layout.addWidget(self.active_toggle)\n\n    second_layout = QtWidgets.QVBoxLayout()\n    curve_layout.addLayout(second_layout)\n\n    pv_settings_layout = QtWidgets.QHBoxLayout()\n    second_layout.addLayout(pv_settings_layout)\n\n    self.invalid_action = None\n    self.variable_name_label = QtWidgets.QLabel()\n    self.variable_name_label.setMinimumWidth(40)\n    self.variable_name_label.setAlignment(QtCore.Qt.AlignCenter)\n    self.variable_name_label.setText(self.variable_name)\n    self.variable_name_label.setToolTip(\"Variable name of the curve\")\n    pv_settings_layout.addWidget(self.variable_name_label)\n\n    self.label = QtWidgets.QLineEdit()\n    self.setup_line_edit()\n    pv_settings_layout.addWidget(self.label)\n\n    self.pv_settings_modal = None\n    self.pv_settings_button = QtWidgets.QPushButton()\n    self.pv_settings_button.setFlat(True)\n    self.pv_settings_button.clicked.connect(self.show_settings_modal)\n    pv_settings_layout.addWidget(self.pv_settings_button)\n\n    self.live_connection_status = QtWidgets.QLabel()\n    self.live_connection_status.setToolTip(\"Not connected to live data\")\n    self.source.live_channel_connection.connect(self.update_live_icon)\n    pv_settings_layout.addWidget(self.live_connection_status)\n\n    self.archive_connection_status = QtWidgets.QLabel()\n    self.archive_connection_status.setToolTip(\"Not connected to archive data\")\n    self.source.archive_channel_connection.connect(self.update_archive_icon)\n    pv_settings_layout.addWidget(self.archive_connection_status)\n\n    self.delete_button = QtWidgets.QPushButton()\n    self.delete_button.setFlat(True)\n    self.delete_button.clicked.connect(self.close)\n    pv_settings_layout.addWidget(self.delete_button)\n\n    self.update_icons()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.setup_line_edit","title":"<code>setup_line_edit()</code>","text":"<p>Set up the line edit with appropriate behavior for formula vs regular curves</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def setup_line_edit(self):\n    \"\"\"Set up the line edit with appropriate behavior for formula vs regular curves\"\"\"\n    if self.is_formula_curve():\n        text = self.source.formula\n        placeholder = \"Edit formula (f://...)\"\n        self.label.editingFinished.connect(self.update_formula)\n    else:\n        text = self.source.name()\n        placeholder = \"PV Name\"\n        self.label.editingFinished.connect(self.set_curve_pv)\n\n    self.label.setText(text)\n    self.label.setPlaceholderText(placeholder)\n    self.label.returnPressed.connect(self.label.clearFocus)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.update_icons","title":"<code>update_icons()</code>","text":"<p>Update all icons based on current theme</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>@Slot()\ndef update_icons(self):\n    \"\"\"Update all icons based on current theme\"\"\"\n    handle_icon = self.theme_manager.create_icon(\"ph.dots-six-vertical\", scale_factor=1.5)\n    self.handle.setIcon(handle_icon)\n\n    settings_icon = self.theme_manager.create_icon(\"msc.settings-gear\")\n    self.pv_settings_button.setIcon(settings_icon)\n\n    delete_icon = self.theme_manager.create_icon(\"msc.trash\")\n    self.delete_button.setIcon(delete_icon)\n\n    icon_disconnected = self.theme_manager.create_icon(\"msc.debug-disconnect\")\n    self.live_connection_status.setPixmap(icon_disconnected.pixmap(16, 16))\n    self.archive_connection_status.setPixmap(icon_disconnected.pixmap(16, 16))\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.show_invalid_icon","title":"<code>show_invalid_icon(show=True)</code>","text":"<p>Show or hide the invalid formula icon overlaid on the line edit</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def show_invalid_icon(self, show=True):\n    \"\"\"Show or hide the invalid formula icon overlaid on the line edit\"\"\"\n    if not self.is_formula_curve():\n        return\n\n    if show:\n        if self.invalid_action is None:\n            icon = self.theme_manager.create_icon(\"fa6s.triangle-exclamation\", IconColors.ERROR)\n            self.invalid_action = self.label.addAction(icon, QtWidgets.QLineEdit.TrailingPosition)\n            self.invalid_action.setToolTip(\"Formula is invalid\")\n\n        self.label.setStyleSheet(\n            \"\"\"\n            QLineEdit {\n                border: 2px solid #d32f2f;\n                border-radius: 4px;\n                padding: 4px;\n            }\n            \"\"\"\n        )\n    else:\n        if self.invalid_action is not None:\n            self.label.removeAction(self.invalid_action)\n            self.invalid_action = None\n\n        self.label.setStyleSheet(\"\")\n\n        if self.label.toolTip() == \"Formula is invalid\":\n            self.label.setToolTip(\"\")\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.on_color_changed","title":"<code>on_color_changed(color)</code>","text":"<p>Handle color change from settings modal</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>@QtCore.Slot(object)\ndef on_color_changed(self, color):\n    \"\"\"Handle color change from settings modal\"\"\"\n    self.update_color_toggle()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.update_color_toggle","title":"<code>update_color_toggle()</code>","text":"<p>Update the color toggle when the curve color changes</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def update_color_toggle(self):\n    \"\"\"Update the color toggle when the curve color changes\"\"\"\n    if hasattr(self, \"active_toggle\"):\n        curve_color = getattr(self.source, \"color_string\", None)\n        self.active_toggle.setColor(curve_color)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.is_formula_curve","title":"<code>is_formula_curve()</code>","text":"<p>Check if this is a formula curve.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this is a formula curve, False otherwise</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def is_formula_curve(self) -&gt; bool:\n    \"\"\"Check if this is a formula curve.\n\n    Returns\n    -------\n    bool\n        True if this is a formula curve, False otherwise\n    \"\"\"\n    return isinstance(self.source, FormulaCurveItem)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.update_formula","title":"<code>update_formula()</code>","text":"<p>Handle formula updates when user edits the formula text.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def update_formula(self) -&gt; None:\n    \"\"\"Handle formula updates when user edits the formula text.\"\"\"\n    if hasattr(self, \"_updating_formula\") and self._updating_formula:\n        return\n\n    self.show_invalid_icon(False)\n\n    new_formula = self.label.text().strip()\n\n    if not new_formula.startswith(\"f://\"):\n        QtWidgets.QMessageBox.warning(\n            self, \"Invalid Formula\", \"Formula must start with 'f://'.\\nExample: f://{PV1}+2\"\n        )\n        if hasattr(self.source, \"formula\"):\n            self.label.setText(self.source.formula)\n        return\n\n    current_formula = getattr(self.source, \"formula\", \"\") if hasattr(self.source, \"formula\") else \"\"\n    if new_formula == current_formula:\n        return\n\n    self._updating_formula = True\n\n    try:\n        var_names = re.findall(r\"{(.+?)}\", new_formula)\n\n        for var_name in var_names:\n            if var_name not in self.control_panel._curve_dict:\n                raise ValueError(\n                    f\"Variable '{var_name}' not found. Available: {list(self.control_panel._curve_dict.keys())}\"\n                )\n\n        expr_body = new_formula[4:]\n        if var_names:\n            python_expr, allowed = sanitize_for_validation(expr_body)\n            validate_formula(python_expr, allowed_symbols=allowed)\n        else:\n            validate_formula(expr_body, allowed_symbols=set())\n\n        def delayed_update():\n            try:\n                self._perform_formula_update(new_formula)\n                self.show_invalid_icon(False)\n            except ValueError as e:\n                QtWidgets.QMessageBox.critical(None, \"Formula Update Failed\", f\"Failed to update formula: {str(e)}\")\n                if hasattr(self.source, \"formula\"):\n                    self.label.setText(self.source.formula)\n                else:\n                    self.show_invalid_icon(True)\n            finally:\n                if hasattr(self, \"_updating_formula\"):\n                    self._updating_formula = False\n\n        QTimer.singleShot(10, delayed_update)\n\n    except Exception as e:\n        self._updating_formula = False\n        QtWidgets.QMessageBox.critical(self, \"Formula Update Failed\", f\"Failed to update formula: {str(e)}\")\n        if hasattr(self.source, \"formula\"):\n            self.label.setText(self.source.formula)\n        else:\n            self.show_invalid_icon(True)\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/","title":"Data Insight Tool","text":""},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.CAGetThread","title":"<code>CAGetThread(parent=None, address='')</code>","text":"<p>               Bases: <code>QThread</code></p> <p>Thread for making a CA get request to the given address. This is used to get the description of the curve.</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def __init__(self, parent: QObject = None, address: str = \"\") -&gt; None:\n    super().__init__(parent=parent)\n    self.address = address\n    self.stop_flag = False\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.CAGetThread.run","title":"<code>run()</code>","text":"<p>Get the value for the given address. Interruptable via the stop_flag. Does not attempt to emit the PV Value if interrupted.</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Get the value for the given address. Interruptable via the\n    stop_flag. Does not attempt to emit the PV Value if interrupted.\n    \"\"\"\n    pv = epics.PV(self.address)\n\n    if self.stop_flag:\n        return\n\n    try:\n        self.result_ready.emit(pv.value)\n    except epics.ca.ChannelAccessException as e:\n        logger.warning(f\"Channel Access error: {e}\")\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.CAGetThread.stop","title":"<code>stop()</code>","text":"<p>Set the stop flag</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Set the stop flag\"\"\"\n    self.stop_flag = True\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel","title":"<code>DataVisualizationModel(parent=None)</code>","text":"<p>               Bases: <code>QAbstractTableModel</code></p> <p>Table Model for fetching and storing the data for a given curve on the model. Gathers live data directly from the curve, but makes an HTTP request to the Archiver Appliance</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def __init__(self, parent: QObject = None) -&gt; None:\n    super().__init__(parent)\n    self.df = pd.DataFrame(columns=[\"Datetime\", \"Value\", \"Severity\", \"Source\"])\n\n    self.address = None\n    self.unit = None\n    self.description = None\n    self.caget_thread = None\n\n    self.network_manager = QNetworkAccessManager()\n    self.network_manager.finished.connect(self.recieve_archive_reply)\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.rowCount","title":"<code>rowCount(index=QModelIndex())</code>","text":"<p>Return the row count of the table</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def rowCount(self, index: QModelIndex = QModelIndex()) -&gt; int:\n    \"\"\"Return the row count of the table\"\"\"\n    if index is not None and index.isValid():\n        return 0\n    return self.df.shape[0]\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.columnCount","title":"<code>columnCount(index=QModelIndex())</code>","text":"<p>Return the column count of the table</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def columnCount(self, index: QModelIndex = QModelIndex()) -&gt; int:\n    \"\"\"Return the column count of the table\"\"\"\n    if index is not None and index.isValid():\n        return 0\n    return self.df.shape[1]\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.data","title":"<code>data(index, role=Qt.DisplayRole)</code>","text":"<p>Return the data for the associated role. Currently only supporting DisplayRole.</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def data(self, index: QModelIndex, role: Qt.ItemDataRole = Qt.DisplayRole) -&gt; str:\n    \"\"\"Return the data for the associated role. Currently only supporting DisplayRole.\"\"\"\n    if not index.isValid():\n        return None\n    elif role == Qt.DisplayRole:\n        val = self.df.iat[index.row(), index.column()]\n        return str(val)\n    return None\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.headerData","title":"<code>headerData(section, orientation, role=Qt.DisplayRole)</code>","text":"<p>Return data associated with the header</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.ItemDataRole = Qt.DisplayRole) -&gt; str:\n    \"\"\"Return data associated with the header\"\"\"\n    if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n        return self.df.columns[section]\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.set_description","title":"<code>set_description(description)</code>","text":"<p>Set the description of the curve. This is called when the CAGetThread emits a result_ready signal.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of the curve</p> required Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def set_description(self, description: str) -&gt; None:\n    \"\"\"Set the description of the curve. This is called when the CAGetThread\n    emits a result_ready signal.\n\n    Parameters\n    ----------\n    description : str\n        The description of the curve\n    \"\"\"\n    self.description = description\n    self.description_changed.emit()\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.set_all_data","title":"<code>set_all_data(curve_item, x_range)</code>","text":"<p>Set the model's data for the given curve and the given time range. This function determines what kind of data should be saved and prompts the methods for setting live or archived data as necessary. This also saves the meta data.</p> <p>Parameters:</p> Name Type Description Default <code>curve_item</code> <code>TimePlotCurveItem</code> <p>The curve for the model to collect and store data on</p> required <code>x_range</code> <code>list[int] | tuple[int, int]</code> <p>The time range to collect and store data between</p> required Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def set_all_data(self, curve_item: TimePlotCurveItem, x_range: list[int] | tuple[int, int]) -&gt; None:\n    \"\"\"Set the model's data for the given curve and the given time range.\n    This function determines what kind of data should be saved and prompts\n    the methods for setting live or archived data as necessary. This also\n    saves the meta data.\n\n    Parameters\n    ----------\n    curve_item : TimePlotCurveItem\n        The curve for the model to collect and store data on\n    x_range : list[int] | tuple[int, int]\n        The time range to collect and store data between\n    \"\"\"\n    self.address = curve_item.address if curve_item.address else \"\"\n    self.unit = curve_item.units\n\n    # Set the meta data label of the DataInsightTool\n    self.set_description(\"Loading...\")\n\n    # Create a new CAGetThread to get the description of the curve\n    if isinstance(self.caget_thread, CAGetThread) and self.caget_thread.isRunning():\n        self.caget_thread.stop()\n    self.caget_thread = CAGetThread(self, self.address + \".DESC\")\n    self.caget_thread.result_ready.connect(self.set_description)\n    self.caget_thread.start()\n\n    curve_range = (curve_item.min_x(), curve_item.max_x())\n    left_ts = max(x_range[0], curve_range[0])\n    right_ts = min(x_range[1], curve_range[1])\n\n    # Populate the model with live data if it is shown on the plot\n    if (curve_range[0] &lt;= x_range[1]) and (x_range[0] &lt;= curve_range[1]):\n        self.set_live_data(curve_item, (left_ts, right_ts))\n\n    # Populate the model with archive data if it is shown on the plot\n    if x_range[0] &lt;= curve_range[0]:\n        self.request_archive_data(curve_item.address, (x_range[0], left_ts))\n    else:\n        # Emulate network reply being recieved for parent widget\n        self.reply_recieved.emit()\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.set_live_data","title":"<code>set_live_data(curve_item, x_range)</code>","text":"<p>Set the live data for the given curve in the given time range. Appends rows within the time range to the end of the model's dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>curve_item</code> <code>TimePlotCurveItem</code> <p>The curve for the model to collect and store data on</p> required <code>x_range</code> <code>list[int] | tuple[int, int]</code> <p>The time range to collect and store data between</p> required Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def set_live_data(self, curve_item: TimePlotCurveItem, x_range: list[int] | tuple[int, int]) -&gt; None:\n    \"\"\"Set the live data for the given curve in the given time range. Appends\n    rows within the time range to the end of the model's dataframe.\n\n    Parameters\n    ----------\n    curve_item : TimePlotCurveItem\n        The curve for the model to collect and store data on\n    x_range : list[int] | tuple[int, int]\n        The time range to collect and store data between\n    \"\"\"\n    data_n = curve_item.points_accumulated\n    if data_n == 0:\n        return\n\n    data = curve_item.data_buffer[:, -data_n:]\n    indices = np.where((x_range[0] &lt;= data[0]) &amp; (data[0] &lt;= x_range[1]))[0]\n\n    convert_data = {\"Datetime\": [], \"Value\": [], \"Severity\": []}\n    convert_data[\"Datetime\"] = data[0, indices]\n    convert_data[\"Value\"] = data[1, indices]\n    convert_data[\"Severity\"] = [\"NaN\"] * indices.size\n    convert_data[\"Source\"] = [\"Live\"] * indices.size\n\n    live_df = pd.DataFrame(convert_data)\n    live_df[\"Datetime\"] = live_df[\"Datetime\"].apply(datetime.fromtimestamp)\n\n    self.beginResetModel()\n    self.df = live_df\n    self.endResetModel()\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.request_archive_data","title":"<code>request_archive_data(pv_name, x_range)</code>","text":"<p>Request data from the Archiver Appliance for the given PV and time range. Only gets raw data, never optimized. Ends early if there is no environment variable PYDM_ARCHIVER_URL, which would contain the url for the Archiver Appliance.</p> <p>Parameters:</p> Name Type Description Default <code>pv_name</code> <code>str</code> <p>The PV address to request data for</p> required <code>x_range</code> <code>list[int] | tuple[int, int]</code> <p>The time range to collect and store data between</p> required Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def request_archive_data(self, pv_name: str, x_range: list[int] | tuple[int, int]) -&gt; None:\n    \"\"\"Request data from the Archiver Appliance for the given PV and time range.\n    Only gets raw data, never optimized. Ends early if there is no environment\n    variable PYDM_ARCHIVER_URL, which would contain the url for the Archiver\n    Appliance.\n\n    Parameters\n    ----------\n    pv_name : str\n        The PV address to request data for\n    x_range : list[int] | tuple[int, int]\n        The time range to collect and store data between\n    \"\"\"\n    # Check the $PYDM_ARCHIVER_URL is populated\n    base_url = os.getenv(\"PYDM_ARCHIVER_URL\")\n    if base_url is None:\n        logger.error(\n            \"Environment variable: PYDM_ARCHIVER_URL must be defined to use the archiver plugin, for \"\n            \"example: http://lcls-archapp.slac.stanford.edu\"\n        )\n        return\n\n    # Correctly format the timestamps for the Archiver Appliance\n    from_dt = datetime.fromtimestamp(x_range[0], tz=timezone.utc)\n    from_date_str = from_dt.strftime(\"%Y-%m-%dT%H:%M:%S.%f\")[:-3] + \"Z\"\n\n    to_dt = datetime.fromtimestamp(x_range[1], tz=timezone.utc)\n    to_date_str = to_dt.strftime(\"%Y-%m-%dT%H:%M:%S.%f\")[:-3] + \"Z\"\n\n    # Construct the request url and make the request\n    url_string = f\"{base_url}/retrieval/data/getData.json?pv={pv_name}&amp;from={from_date_str}&amp;to={to_date_str}\"\n    request = QNetworkRequest(QUrl(url_string))\n    self.network_manager.get(request)\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.recieve_archive_reply","title":"<code>recieve_archive_reply(reply)</code>","text":"<p>Process the recieved reply to the request made in request_archive_data. Unpack the data and call set_archive_data. Mostly checks if the reply contains an error.</p> <p>Parameters:</p> Name Type Description Default <code>reply</code> <code>QNetworkReply</code> <p>Reply to the network request made in request_archive_data</p> required Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def recieve_archive_reply(self, reply: QNetworkReply) -&gt; None:\n    \"\"\"Process the recieved reply to the request made in request_archive_data.\n    Unpack the data and call set_archive_data. Mostly checks if the reply\n    contains an error.\n\n    Parameters\n    ----------\n    reply : QNetworkReply\n        Reply to the network request made in request_archive_data\n    \"\"\"\n    self.reply_recieved.emit()\n    if reply.error() == QNetworkReply.NoError:\n        bytes_str = reply.readAll()\n        try:\n            data_dict = json.loads(str(bytes_str, \"utf-8\"))\n            self.set_archive_data(data_dict)\n        except json.JSONDecodeError:\n            logger.warning(\"Data Insight Tool: No data received from archiver\")\n    else:\n        logger.debug(\n            f\"Request for data from archiver failed, request url: {reply.url()} retrieved header: \"\n            f\"{reply.header(QNetworkRequest.ContentTypeHeader)} error: {reply.error()}\"\n        )\n    reply.deleteLater()\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.set_archive_data","title":"<code>set_archive_data(data_dict)</code>","text":"<p>Set the live data for the given curve in the given time range. Appends rows within the time range to the end of the model's dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>data_dict</code> <code>dict</code> <p>Dictionary containing all data to be added to the model's dataframe</p> required Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def set_archive_data(self, data_dict: dict) -&gt; None:\n    \"\"\"Set the live data for the given curve in the given time range. Appends\n    rows within the time range to the end of the model's dataframe.\n\n    Parameters\n    ----------\n    data_dict : dict\n        Dictionary containing all data to be added to the model's dataframe\n    \"\"\"\n    convert_data = {\"Datetime\": [], \"Value\": [], \"Severity\": []}\n    for point in data_dict[0][\"data\"]:\n        ts = point[\"secs\"] + (point[\"nanos\"] * 1e-9)\n        convert_data[\"Datetime\"].append(datetime.fromtimestamp(ts))\n        convert_data[\"Value\"].append(point[\"val\"])\n        convert_data[\"Severity\"].append(SEVERITY_MAP[point[\"severity\"]])\n    convert_data[\"Source\"] = [\"Archive\"] * len(data_dict[0][\"data\"])\n    archive_df = pd.DataFrame(convert_data)\n\n    if self.df.empty:\n        self.beginResetModel()\n        self.df = archive_df\n        self.endResetModel()\n    else:\n        self.beginInsertRows(QModelIndex(), 0, archive_df.shape[0] - 1)\n        self.df = pd.concat([archive_df, self.df])\n        self.endInsertRows()\n    self.layoutChanged.emit()\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataVisualizationModel.export_data","title":"<code>export_data(file_path, extension)</code>","text":"<p>Export the model's data to the given file. Adds metadata to the top of the exported file with the curve's address, unit (if any), and description.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path of the file to be (over)written with the exported data</p> required <code>extension</code> <code>str</code> <p>The extension of the file to be (over)written</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised when export is requested without data in the model, or when an invalid file format is requested for export</p> <code>IsADirectoryError</code> <p>Raised when the provided filepath is a directory</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def export_data(self, file_path: Path, extension: str) -&gt; None:\n    \"\"\"Export the model's data to the given file. Adds metadata to the top of\n    the exported file with the curve's address, unit (if any), and description.\n\n    Parameters\n    ----------\n    file_path : Path\n        The path of the file to be (over)written with the exported data\n    extension : str\n        The extension of the file to be (over)written\n\n    Raises\n    ------\n    ValueError\n        Raised when export is requested without data in the model, or when an\n        invalid file format is requested for export\n    IsADirectoryError\n        Raised when the provided filepath is a directory\n    \"\"\"\n    if self.df.empty:\n        raise ValueError(\"No data to export. Request data first.\")\n    if file_path.is_dir():\n        raise IsADirectoryError(\"The selected path is a directory. Select a file to export to.\")\n    if extension not in [\".csv\", \".mat\", \".json\"]:\n        raise ValueError(\"Unrecognized file format requested. Skipping export.\")\n\n    header_dict = {\"Address\": self.address, \"Unit\": self.unit, \"Description\": self.description}\n\n    export_df = self.df.copy()\n    export_df[\"Datetime\"] = export_df[\"Datetime\"].astype(\"int64\") / 1e9\n\n    if extension == \".csv\":\n        file_header = \"\".join([f\"{k}: {v}\\n\" for k, v in header_dict.items()])\n        with file_path.open(\"w\") as file:\n            file.write(file_header)\n            export_df.to_csv(file, index=False, mode=\"a\")\n    elif extension == \".mat\":\n        header_dict.update({name: col.values for name, col in export_df.items()})\n        savemat(file_path, header_dict)\n    elif extension == \".json\":\n        if export_df[\"Value\"].dtype == object:\n            export_df[\"Value\"] = export_df[\"Value\"].astype(\"str\")\n        data_dict = export_df.to_dict(orient=\"records\")\n        export_dict = {\"meta\": header_dict, \"data\": data_dict}\n        with file_path.open(\"w\") as file:\n            json.dump(export_dict, file, indent=2)\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataInsightTool","title":"<code>DataInsightTool(parent, plot=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>The Data Insight Tool is a standalone widget that allows users to display all archive and live data on the plot for any given curve. Users are also able to export the raw data from this tool.</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def __init__(self, parent: QObject, plot: PyDMArchiverTimePlot = None) -&gt; None:\n    super().__init__(parent=parent)\n    self.setWindowFlag(Qt.Window)\n    self.resize(600, 600)\n    self.setWindowTitle(\"Data Insight Tool\")\n\n    self.layout_init()\n\n    self.data_vis_model.reply_recieved.connect(self.loading_label.hide)\n    self.data_vis_model.description_changed.connect(self.set_meta_data)\n    self.export_button.clicked.connect(self.export_data_to_file)\n    self.pv_select_box.currentIndexChanged.connect(self.get_data)\n    self.refresh_button.clicked.connect(self.get_data)\n\n    if isinstance(plot, PyDMArchiverTimePlot):\n        self.plot = plot\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataInsightTool.plot","title":"<code>plot</code>  <code>property</code> <code>writable</code>","text":"<p>Return the plot associated with this widget</p>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataInsightTool.layout_init","title":"<code>layout_init()</code>","text":"<p>Initialize the layout of the Data Insight Tool widget.</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def layout_init(self) -&gt; None:\n    \"\"\"Initialize the layout of the Data Insight Tool widget.\"\"\"\n    self.main_layout = QVBoxLayout()\n\n    # Populate the PV selection and request layout at the top of the widget\n    self.request_layout = QHBoxLayout()\n    self.pv_select_box = QComboBox()\n    self.pv_select_box.setSizeAdjustPolicy(QComboBox.AdjustToContents)\n    self.request_layout.addWidget(self.pv_select_box, alignment=Qt.AlignLeft)\n\n    self.loading_label = QLabel(\"Loading...\")\n    self.loading_label.hide()\n    self.request_layout.addWidget(self.loading_label, alignment=Qt.AlignCenter)\n\n    self.export_button = QPushButton(\"Export to File\")\n    self.request_layout.addWidget(self.export_button, alignment=Qt.AlignRight)\n    self.main_layout.addLayout(self.request_layout)\n\n    # Create the metadata label and refresh button\n    self.metadata_layout = QHBoxLayout()\n    self.meta_data_label = QLabel()\n    self.metadata_layout.addWidget(self.meta_data_label, alignment=Qt.AlignLeft)\n\n    self.refresh_button = QPushButton(\"Refresh Data\")\n    self.metadata_layout.addWidget(self.refresh_button, alignment=Qt.AlignRight)\n    self.main_layout.addLayout(self.metadata_layout)\n\n    # Set up the main data table in the center of the widget\n    self.data_vis_model = DataVisualizationModel()\n    self.data_table = FrozenTableView(self.data_vis_model)\n    self.main_layout.addWidget(self.data_table)\n\n    self.setLayout(self.main_layout)\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataInsightTool.set_meta_data","title":"<code>set_meta_data()</code>","text":"<p>Populate the meta_data_label with the curve's unit (if any) and description.</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def set_meta_data(self) -&gt; None:\n    \"\"\"Populate the meta_data_label with the curve's unit (if any) and description.\"\"\"\n    meta_labels = []\n    if self.data_vis_model.unit:\n        meta_labels.append(str(self.data_vis_model.unit))\n    if self.data_vis_model.description:\n        meta_labels.append(str(self.data_vis_model.description))\n    self.meta_data_label.setText(\", \".join(meta_labels))\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataInsightTool.combobox_to_curve","title":"<code>combobox_to_curve(combobox_ind)</code>","text":"<p>Convert an index for the pv_select_box combobox to the corresponding curve item from the curves model.</p> <p>Parameters:</p> Name Type Description Default <code>combobox_ind</code> <code>int</code> <p>The index for pv_select_box</p> required <p>Returns:</p> Type Description <code>ArchivePlotCurveItem</code> <p>The curve item that corresponds to the PV chosen on the combobox</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>def combobox_to_curve(self, combobox_ind: int) -&gt; ArchivePlotCurveItem:\n    \"\"\"Convert an index for the pv_select_box combobox to the corresponding\n    curve item from the curves model.\n\n    Parameters\n    ----------\n    combobox_ind : int\n        The index for pv_select_box\n\n    Returns\n    -------\n    ArchivePlotCurveItem\n        The curve item that corresponds to the PV chosen on the combobox\n    \"\"\"\n    if combobox_ind &lt; 0 or self.pv_select_box.count() &lt;= combobox_ind:\n        combobox_ind = self.pv_select_box.currentIndex()\n    return self.plot.curveAtIndex(combobox_ind)\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataInsightTool.update_pv_select_box","title":"<code>update_pv_select_box()</code>","text":"<p>Populate the pv_select_box with all curves in the plot. This is called when the plot is updated.</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>@Slot()\ndef update_pv_select_box(self) -&gt; None:\n    \"\"\"Populate the pv_select_box with all curves in the plot. This is called\n    when the plot is updated.\n    \"\"\"\n    self.pv_select_box.blockSignals(True)\n    self.pv_select_box.clear()\n    self.pv_select_box.blockSignals(False)\n    curve_names = [c.address for c in self.plot._curves if isinstance(c, ArchivePlotCurveItem)]\n    self.pv_select_box.addItems(curve_names)\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataInsightTool.export_data_to_file","title":"<code>export_data_to_file()</code>","text":"<p>Prompt the user to select a file to export data to then prompt the DataVisualizationModel to export its data to the selected file.</p> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>@Slot()\ndef export_data_to_file(self) -&gt; None:\n    \"\"\"Prompt the user to select a file to export data to then prompt the\n    DataVisualizationModel to export its data to the selected file.\n    \"\"\"\n    file_name, extension_filter = QFileDialog.getSaveFileName(\n        self,\n        \"Export Archive Data\",\n        Path(\".\").name,\n        \"Comma-Separated Values File (*.csv);;MAT-File (*.mat);;JSON File (*.json)\",\n    )\n    if not extension_filter:\n        return\n    extension = re.search(r\"\\*(.*?)\\)\", extension_filter).group(1)\n    file_name = Path(file_name).with_suffix(extension)\n\n    try:\n        self.data_vis_model.export_data(file_name, extension)\n    except (ValueError, IsADirectoryError) as e:\n        logger.error(str(e))\n        QMessageBox.critical(self, \"Error\", str(e))\n</code></pre>"},{"location":"reference/widgets/data_insight_tool/#widgets.data_insight_tool.DataInsightTool.get_data","title":"<code>get_data(combobox_index=-1)</code>","text":"<p>Prompt the DataVisualizationModel to fetch and save the data for the curve chosen by the user for the time range on the associated plot.</p> <p>Parameters:</p> Name Type Description Default <code>combobox_index</code> <code>int</code> <p>The index in the pv_select_box for the user selected curve, by default -1</p> <code>-1</code> Source code in <code>trace/widgets/data_insight_tool.py</code> <pre><code>@Slot()\n@Slot(int)\ndef get_data(self, combobox_index: int = -1) -&gt; None:\n    \"\"\"Prompt the DataVisualizationModel to fetch and save the data for the\n    curve chosen by the user for the time range on the associated plot.\n\n    Parameters\n    ----------\n    combobox_index : int, optional\n        The index in the pv_select_box for the user selected curve, by default -1\n    \"\"\"\n    if self.pv_select_box.count() &lt; 1:\n        logger.warning(\"Curves must be added to the main display before data can be requested.\")\n        return\n\n    curve_item = self.combobox_to_curve(combobox_index)\n    x_range = self.plot.getXAxis().range\n\n    self.data_vis_model.set_all_data(curve_item, x_range)\n    self.set_meta_data()\n    self.loading_label.show()\n</code></pre>"},{"location":"reference/widgets/elog_post_modal/","title":"E-Log Post Modal","text":""},{"location":"reference/widgets/elog_post_modal/#widgets.elog_post_modal.ElogPostModal","title":"<code>ElogPostModal(parent=None, image_bytes=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Modal widget for creating a new E-Log entry.</p> <p>This widget provides a comprehensive interface for creating a new E-Log entry.</p> Source code in <code>trace/widgets/elog_post_modal.py</code> <pre><code>def __init__(\n    self,\n    parent: QWidget = None,\n    image_bytes: bytes | None = None,\n):\n    super().__init__(parent)\n\n    self.setModal(True)\n\n    main_layout = QVBoxLayout()\n    self.setLayout(main_layout)\n\n    modal_label = SettingsTitle(self, \"New Elog Entry\", size=14)\n    main_layout.addWidget(modal_label)\n\n    if image_bytes is not None:\n        pixmap = QPixmap()\n        pixmap.loadFromData(image_bytes)\n        image_label = QLabel()\n        image_label.setPixmap(pixmap)\n        image_label.setScaledContents(True)\n        image_label.setFixedSize(400, 300)\n        main_layout.addWidget(image_label)\n\n    self.title_edit = QLineEdit(self)\n    self.title_edit.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n    self.title_edit.setMinimumWidth(250)\n    title_row = SettingsRowItem(self, \"Title\\n(required)\", self.title_edit)\n    main_layout.addLayout(title_row)\n\n    self.body_edit = QTextEdit(self)\n    body_row = SettingsRowItem(self, \"Body\\n(optional)\", self.body_edit)\n    main_layout.addLayout(body_row)\n\n    self.logbook_list = QListWidget(self)\n    self.logbook_list.setSelectionMode(QListWidget.MultiSelection)\n    logbook_row = SettingsRowItem(self, \"Logbooks\\n(required)\", self.logbook_list)\n    main_layout.addLayout(logbook_row)\n\n    self.logbook_readback = QLabel()\n    self.logbook_readback.setWordWrap(True)\n    self.logbook_readback.setMinimumWidth(250)\n    self.logbook_readback.setMaximumWidth(350)\n    logbook_readback_row = SettingsRowItem(self, \"Selected Logbooks\", self.logbook_readback)\n    self.logbook_list.itemSelectionChanged.connect(\n        lambda: self.logbook_readback.setText(\", \".join(item.text() for item in self.logbook_list.selectedItems()))\n    )\n    main_layout.addLayout(logbook_readback_row)\n\n    self.attach_config_checkbox = QCheckBox(self)\n    attach_config_row = SettingsRowItem(self, \"Attach Config\", self.attach_config_checkbox)\n    main_layout.addLayout(attach_config_row)\n\n    buttons = QDialogButtonBox()\n    send_button = buttons.addButton(\"Send\", QDialogButtonBox.AcceptRole)\n    cancel_button = buttons.addButton(QDialogButtonBox.Cancel)\n\n    cancel_button.clicked.connect(self.reject)\n    send_button.clicked.connect(self.on_submit)\n    main_layout.addWidget(buttons)\n</code></pre>"},{"location":"reference/widgets/elog_post_modal/#widgets.elog_post_modal.ElogPostModal.on_submit","title":"<code>on_submit()</code>","text":"<p>Handles the submission of the dialog. This method is called when the user clicks the 'Send' button. It retrieves the inputs, validates, and closes the dialog.</p> Source code in <code>trace/widgets/elog_post_modal.py</code> <pre><code>def on_submit(self) -&gt; None:\n    \"\"\"Handles the submission of the dialog. This method is called\n    when the user clicks the 'Send' button. It retrieves the inputs,\n    validates, and closes the dialog.\n    \"\"\"\n    title, _, logbooks, _ = self.get_inputs()\n    if not title:\n        QMessageBox.warning(self, \"Input Error\", \"Title is required.\")\n        return\n    if not logbooks:\n        QMessageBox.warning(self, \"Input Error\", \"At least one logbook must be selected.\")\n        return\n\n    self.accept()\n</code></pre>"},{"location":"reference/widgets/elog_post_modal/#widgets.elog_post_modal.ElogPostModal.get_inputs","title":"<code>get_inputs()</code>","text":"<p>Returns the inputs from the dialog as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[str, str, list[str], bool]</code> <p>The inputs from the dialog (title, body, logbooks, attach_config)</p> Source code in <code>trace/widgets/elog_post_modal.py</code> <pre><code>def get_inputs(self) -&gt; tuple[str, str, list[str], bool]:\n    \"\"\"Returns the inputs from the dialog as a tuple.\n\n    Returns\n    -------\n    tuple[str, str, list[str], bool]\n        The inputs from the dialog (title, body, logbooks, attach_config)\n    \"\"\"\n    title = self.title_edit.text().strip()\n    body = self.body_edit.toPlainText().strip()\n    logbooks = [item.text() for item in self.logbook_list.selectedItems()]\n    attach_config = self.attach_config_checkbox.isChecked()\n    return title, body, logbooks, attach_config\n</code></pre>"},{"location":"reference/widgets/elog_post_modal/#widgets.elog_post_modal.ElogPostModal.maybe_create","title":"<code>maybe_create(parent=None, image_bytes=None)</code>  <code>classmethod</code>","text":"<p>Creates and shows the ElogPostModal dialog if the logbook list can be populated. If the logbook list cannot be populated, an error message is shown and None is returned.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> <code>None</code> <code>image_bytes</code> <code>bytes</code> <p>The image bytes to be attached to the entry</p> <code>None</code> <p>Returns:</p> Type Description <code>ElogPostModal | None</code> <p>The ElogPostModal dialog if the logbook list can be populated, None otherwise</p> Source code in <code>trace/widgets/elog_post_modal.py</code> <pre><code>@classmethod\ndef maybe_create(cls, parent: QWidget = None, image_bytes: bytes | None = None) -&gt; \"ElogPostModal | None\":\n    \"\"\"Creates and shows the ElogPostModal dialog if the logbook list\n    can be populated. If the logbook list cannot be populated, an error\n    message is shown and None is returned.\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        The parent widget\n    image_bytes : bytes, optional\n        The image bytes to be attached to the entry\n\n    Returns\n    -------\n    ElogPostModal | None\n        The ElogPostModal dialog if the logbook list can be populated, None otherwise\n    \"\"\"\n    status_code, logbooks = get_logbooks()\n    if status_code != 200:\n        QMessageBox.critical(\n            parent,\n            \"Elog Access Error\",\n            f\"Unable to fetch logbooks. \\n\\nError code: {status_code}\",\n        )\n        return None\n\n    modal = cls(parent, image_bytes=image_bytes)\n    modal.logbook_list.addItems(logbooks)\n    return modal\n</code></pre>"},{"location":"reference/widgets/formula_dialog/","title":"Formula Dialog","text":""},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.FormulaDialog","title":"<code>FormulaDialog(parent)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>A QDialog that provides a user-friendly interface for creating mathematical formulas using existing curves as variables. It includes a calculator-style button layout and a table showing available curve variables.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QObject</code> <p>The parent object</p> required Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>def __init__(self, parent: QObject):\n    \"\"\"Initialize the formula dialog.\n\n    Parameters\n    ----------\n    parent : QObject\n        The parent object\n    \"\"\"\n    super().__init__(parent)\n    self.setWindowTitle(\"Formula Input\")\n\n    layout = QVBoxLayout(self)\n\n    layout.addSpacerItem(QSpacerItem(0, 0, QSizePolicy.Minimum, QSizePolicy.Expanding))\n\n    self.field = QLineEdit(self)\n    self.curve_model = CurveModel(parent)\n\n    self.pv_list = QTableView(self)\n    self.pv_list.setModel(self.curve_model)\n    self.pv_list.setEditTriggers(QAbstractItemView.EditTriggers(0))\n    self.pv_list.setMaximumWidth(1000)\n    self.pv_list.setMaximumHeight(1000)\n\n    # Hide all columns unused. Leave one to add a button to\n    header = self.pv_list.horizontalHeader()\n    header.setSectionResizeMode(0, QHeaderView.ResizeToContents)\n    header.setStretchLastSection(True)\n\n    layout.addWidget(self.pv_list)\n    layout.addWidget(self.field)\n\n    self.pv_list.doubleClicked.connect(self.insert_pv_key)\n\n    # Define the list of calculator buttons.\n    # It's a bunch of preset buttons, but users can type other functions under math.\n    # fmt: off\n    buttons = [\n        \"7\",   \"8\",      \"9\",      \"+\",       \"(\",      \")\",\n        \"4\",   \"5\",      \"6\",      \"-\",       \"^2\",     \"sqrt()\",\n        \"1\",   \"2\",      \"3\",      \"*\",       \"^-1\",    \"ln()\",\n        \"0\",   \"e\",      \"pi\",     \"/\",       \"sin()\",  \"asin()\",\n        \".\",   \"abs()\",  \"min()\",  \"^\",       \"cos()\",  \"acos()\",\n        \"PV\",  \"Clear\",  \"max()\",  \"mean()\",  \"tan()\",  \"atan()\",\n    ]\n    # fmt: on\n\n    # Create the calculator buttons and connect them to the input field\n    grid_layout = QGridLayout()\n    for i, button_text in enumerate(buttons):\n        button = QPushButton(button_text, self)\n        row = i // 6\n        col = i % 6\n        grid_layout.addWidget(button, row, col)\n        # Connect the button clicked signal to the appropriate action\n        # PV currently does nothing, this is a remnant\n        # From when we would have the pv_list open in a new window\n        if button_text == \"PV\":\n            self.PVButton = button\n            self.PVButton.setCheckable(True)\n            self.PVButton.setChecked(True)\n            self.PVButton.clicked.connect(self.showPVList)\n        elif button_text == \"Clear\":\n            button.clicked.connect(lambda _: self.field.clear())\n        else:\n            button.clicked.connect(lambda _, text=button_text: self.field.insert(text))\n    layout.addLayout(grid_layout)\n\n    # Add an \"OK\" button to accept the formula and close the dialog\n    ok_button = QPushButton(\"Add Formula Curve\", self)\n    ok_button.clicked.connect(self.accept_formula)\n    layout.addWidget(ok_button)\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.FormulaDialog.keyPressEvent","title":"<code>keyPressEvent(e)</code>","text":"<p>Handle key press events for formula submission.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>QKeyEvent</code> <p>The key press event</p> required Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>def keyPressEvent(self, e: QKeyEvent) -&gt; None:\n    \"\"\"Handle key press events for formula submission.\n\n    Parameters\n    ----------\n    e : QKeyEvent\n        The key press event\n    \"\"\"\n    if e.key() == Qt.Key_Return or e.key() == Qt.Key_Enter:\n        self.accept_formula()\n    return super().keyPressEvent(e)\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.FormulaDialog.showPVList","title":"<code>showPVList()</code>","text":"<p>Hide or show the PV list on PVButton click.</p> Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>@Slot()\ndef showPVList(self):\n    \"\"\"Hide or show the PV list on PVButton click.\"\"\"\n    show = self.PVButton.isChecked()\n    if show:\n        self.pv_list.show()\n    else:\n        self.pv_list.hide()\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.FormulaDialog.accept_formula","title":"<code>accept_formula()</code>","text":"<p>Accept the entered formula and emit the formula_accepted signal.</p> Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>@Slot()\ndef accept_formula(self) -&gt; None:\n    \"\"\"Accept the entered formula and emit the formula_accepted signal.\"\"\"\n    formula = \"f://\" + self.field.text()\n    formula = re.sub(r\"\\s+\", \"\", formula)\n\n    self.formula_accepted.emit(formula)\n    self.field.setText(\"\")\n    self.accept()\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.FormulaDialog.insert_pv_key","title":"<code>insert_pv_key(index)</code>","text":"<p>Insert the variable name into the formula field when a row is double-clicked.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>QModelIndex</code> <p>The index of the double-clicked row</p> required Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>@Slot(QModelIndex)\ndef insert_pv_key(self, index: QModelIndex) -&gt; None:\n    \"\"\"Insert the variable name into the formula field when a row is double-clicked.\n\n    Parameters\n    ----------\n    index : QModelIndex\n        The index of the double-clicked row\n    \"\"\"\n    if index.isValid():\n        key = self.curve_model.row_to_key(index.row())\n        if key:\n            current_text = self.field.text()\n            cursor_pos = self.field.cursorPosition()\n            # Add the variable with curly braces\n            new_text = current_text[:cursor_pos] + \"{\" + key + \"}\" + current_text[cursor_pos:]\n            self.field.setText(new_text)\n            # Move cursor after the inserted variable (key length + 2 characters for braces)\n            self.field.setCursorPosition(cursor_pos + len(key) + 2)\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.CurveModel","title":"<code>CurveModel(control_panel)</code>","text":"<p>               Bases: <code>QAbstractTableModel</code></p> <p>Table model for displaying available curves in the formula dialog. It provides a two-column view of available curves with their variable names and curve names for use in formula creation.</p> <p>Parameters:</p> Name Type Description Default <code>control_panel</code> <code>ControlPanel</code> <p>The control panel containing the curve dictionary</p> required Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>def __init__(self, control_panel):\n    \"\"\"Initialize the curve model.\n\n    Parameters\n    ----------\n    control_panel : ControlPanel\n        The control panel containing the curve dictionary\n    \"\"\"\n    super().__init__()\n    self.control_panel = control_panel\n    self._headers = [\"Variable Name\", \"Curve Name\"]\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.CurveModel.rowCount","title":"<code>rowCount(parent=QModelIndex())</code>","text":"<p>Return the number of rows in the model.</p> Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>def rowCount(self, parent=QModelIndex()) -&gt; int:\n    \"\"\"Return the number of rows in the model.\"\"\"\n    if hasattr(self.control_panel, \"curve_dict\"):\n        return len(self.control_panel.curve_dict)\n    return 0\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.CurveModel.columnCount","title":"<code>columnCount(parent=QModelIndex())</code>","text":"<p>Return the number of columns in the model.</p> Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>def columnCount(self, parent=QModelIndex()) -&gt; int:\n    \"\"\"Return the number of columns in the model.\"\"\"\n    return len(self._headers)\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.CurveModel.data","title":"<code>data(index, role=Qt.DisplayRole)</code>","text":"<p>Return the data for the given index and role.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>QModelIndex</code> <p>The model index</p> required <code>role</code> <code>int</code> <p>The data role</p> <code>DisplayRole</code> <p>Returns:</p> Type Description <code>Any</code> <p>The data for the given index and role</p> Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>def data(self, index, role=Qt.DisplayRole) -&gt; Any:\n    \"\"\"Return the data for the given index and role.\n\n    Parameters\n    ----------\n    index : QModelIndex\n        The model index\n    role : int\n        The data role\n\n    Returns\n    -------\n    Any\n        The data for the given index and role\n    \"\"\"\n    if not index.isValid():\n        return None\n\n    if not hasattr(self.control_panel, \"curve_dict\"):\n        return None\n\n    curve_dict = self.control_panel.curve_dict\n    if len(curve_dict) == 0:\n        return None\n\n    # Get the key at this row\n    keys = list(curve_dict.keys())\n    if index.row() &gt;= len(keys):\n        return None\n\n    key = keys[index.row()]\n    curve = curve_dict[key]\n\n    if role == Qt.DisplayRole:\n        if index.column() == 0:\n            return key\n        elif index.column() == 1:\n            if hasattr(curve, \"name\") and callable(curve.name):\n                return curve.name()\n            elif hasattr(curve, \"name\"):\n                return curve.name\n            elif hasattr(curve, \"address\"):\n                return curve.address\n            return str(curve)\n    return None\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.CurveModel.headerData","title":"<code>headerData(section, orientation, role=Qt.DisplayRole)</code>","text":"<p>Return the header data for the given section.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>int</code> <p>The section index</p> required <code>orientation</code> <code>Orientation</code> <p>The orientation (horizontal or vertical)</p> required <code>role</code> <code>int</code> <p>The data role</p> <code>DisplayRole</code> <p>Returns:</p> Type Description <code>Any</code> <p>The header data</p> Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>def headerData(self, section, orientation, role=Qt.DisplayRole) -&gt; Any:\n    \"\"\"Return the header data for the given section.\n\n    Parameters\n    ----------\n    section : int\n        The section index\n    orientation : Qt.Orientation\n        The orientation (horizontal or vertical)\n    role : int\n        The data role\n\n    Returns\n    -------\n    Any\n        The header data\n    \"\"\"\n    if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n        return self._headers[section]\n    return None\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.CurveModel.row_to_key","title":"<code>row_to_key(row)</code>","text":"<p>Get the variable key for the given row index.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int</code> <p>Row index for the requested key.</p> required <p>Returns:</p> Type Description <code>str or None</code> <p>The variable key for the row, or None if invalid</p> Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>def row_to_key(self, row: int) -&gt; str:\n    \"\"\"Get the variable key for the given row index.\n\n    Parameters\n    ----------\n    row : int\n        Row index for the requested key.\n\n    Returns\n    -------\n    str or None\n        The variable key for the row, or None if invalid\n    \"\"\"\n    if not (0 &lt;= row &lt; self.rowCount()):\n        return None\n\n    curve_dict = self.control_panel.curve_dict\n    keys = list(curve_dict.keys())\n    return keys[row]\n</code></pre>"},{"location":"reference/widgets/formula_dialog/#widgets.formula_dialog.CurveModel.refresh","title":"<code>refresh()</code>","text":"<p>Force a refresh of the model data.</p> Source code in <code>trace/widgets/formula_dialog.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Force a refresh of the model data.\"\"\"\n    self.beginResetModel()\n    self.endResetModel()\n</code></pre>"},{"location":"reference/widgets/helper_widgets/","title":"Helper Widgets","text":""},{"location":"reference/widgets/helper_widgets/#color-button","title":"Color Button","text":"<p>The Color button is a button that allows users to select a color for properties in Trace. The button is shown as a blank button in its current color (may be determined by a color palette).</p> <p>Clicking the button will open a color selection dialog window in the style of the user's OS. Here is where they are able to select a new color.</p> <p>Right-clicking the button will reset the button's color to its \"default\" color, which was its initial color on creation.</p>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton","title":"<code>ColorButton(*args, color=None, index=-1, **kwargs)</code>","text":"<p>               Bases: <code>QPushButton</code></p> <p>Custom button to allow the user to select a color. The default color is a random bright color.</p> <p>Left-clicking opens a color dialog box to choose a color. Right-clicking resets the color to the default.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>QColor or str</code> <p>Default color for the button to use, by default None</p> <code>None</code> <code>index</code> <code>int</code> <p>A value used in determining a default color, by default -1</p> <code>-1</code> Source code in <code>trace/widgets/color_button.py</code> <pre><code>def __init__(self, *args: Any, color: QColor | str = None, index: int = -1, **kwargs) -&gt; None:\n    super().__init__(*args, **kwargs)\n    if not color:\n        if index &gt;= 0:\n            color = self.index_color(index)\n        else:\n            color = self.random_color()\n    elif not isinstance(color, QColor):\n        color = QColor(color)\n\n    self._color = None\n    self._default = color\n    self.dialog_box = QColorDialog(self)\n    self.dialog_box.setCurrentColor(color)\n\n    self.pressed.connect(self.dialog_box.show)\n    self.dialog_box.colorSelected.connect(lambda c: setattr(self, \"color\", c))\n\n    self.color = self._default\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton.color","title":"<code>color</code>  <code>property</code> <code>writable</code>","text":"<p>The current color as a QColor.</p>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton.mousePressEvent","title":"<code>mousePressEvent(e)</code>","text":"<p>Set the color to the default on right-click.</p> Source code in <code>trace/widgets/color_button.py</code> <pre><code>def mousePressEvent(self, e: QMouseEvent) -&gt; None:\n    \"\"\"Set the color to the default on right-click.\"\"\"\n    if e.button() == Qt.RightButton:\n        self.color = self._default\n        return\n\n    return super().mousePressEvent(e)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton.random_color","title":"<code>random_color()</code>  <code>staticmethod</code>","text":"<p>Pick a random color for the default color of each PV. This function ensures that the color is bright.</p> <p>Returns:</p> Type Description <code>QColor</code> <p>A random color that is guaranteed to be \"bright\"</p> Source code in <code>trace/widgets/color_button.py</code> <pre><code>@staticmethod\ndef random_color() -&gt; QColor:\n    \"\"\"Pick a random color for the default color of each PV. This\n    function ensures that the color is bright.\n\n    Returns\n    -------\n    QColor\n        A random color that is guaranteed to be \"bright\"\n    \"\"\"\n    hue = int(360 * random())\n    saturation = int(256 * (0.5 + random() / 2.0))\n    lightness = int(256 * (0.4 + random() / 5.0))\n    color = QColor()\n    color.setHsl(hue, saturation, lightness)\n    return color\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton.index_color","title":"<code>index_color(index, palette='default')</code>  <code>staticmethod</code>","text":"<p>Returns the color in the color palette at index. If the requested index is larger than the size of the color palette, then the palette is cycled through again, but darker by a factor of 35%. If palette str is not a key in color_palette dict from trace/config, it will be replaced with 'default'</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Requested index of color palette</p> required <code>palette</code> <code>str</code> <p>Name of selected palette</p> <code>'default'</code> Source code in <code>trace/widgets/color_button.py</code> <pre><code>@staticmethod\ndef index_color(index: int, palette: str = \"default\") -&gt; QColor:\n    \"\"\"Returns the color in the color palette at index. If the\n    requested index is larger than the size of the color palette, then\n    the palette is cycled through again, but darker by a factor of 35%.\n    If palette str is not a key in color_palette dict from trace/config,\n    it will be replaced with 'default'\n\n    Parameters\n    ----------\n    index : int\n        Requested index of color palette\n    palette : str\n        Name of selected palette\n    \"\"\"\n    if palette not in color_palette:\n        palette = \"default\"\n    modded_index = index % len(color_palette[palette])\n    color = color_palette[palette][modded_index]\n\n    dark_factor = (index // len(color_palette[palette])) * 35\n    return color.darker(100 + dark_factor)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#toggle-switch","title":"Toggle Switch","text":"<p>The Toggle is a widget that works the same as a checkbox, but is represented as a switch. This looks a bit nicer for the UI.</p>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch","title":"<code>ToggleSwitch(text='', parent=None, color=None)</code>","text":"<p>               Bases: <code>QCheckBox</code></p> <p>A custom toggle switch widget that looks like a modern mobile switch. This widget extends QCheckBox to create a toggle switch with animated transition between on and off states. The switch consists of a rounded rectangle track and a circular knob that moves horizontally.</p> <p>Attributes:</p> Name Type Description <code>TRACK_OFF</code> <code>QColor</code> <p>Color of the track when the switch is off.</p> <code>TRACK_ON</code> <code>QColor</code> <p>Color of the track when the switch is on.</p> <code>DIAMETER</code> <code>int</code> <p>Diameter of the circular knob in pixels.</p> <code>MARGIN</code> <code>int</code> <p>Margin between the knob and the track edge in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text label (for compatibility with QCheckBox, but not displayed)</p> <code>''</code> <code>parent</code> <code>QWidget</code> <p>The parent widget.</p> <code>None</code> <code>color</code> <code>QColor</code> <p>Custom color for the \"on\" state. If None, uses default blue.</p> <code>None</code> Source code in <code>trace/widgets/toggle.py</code> <pre><code>def __init__(self, text: str = \"\", parent: Optional[Any] = None, color: Optional[QColor] = None) -&gt; None:\n    \"\"\"Initialize the toggle switch widget.\n\n    Parameters\n    ----------\n    text : str, optional\n        The text label (for compatibility with QCheckBox, but not displayed)\n    parent : QWidget, optional\n        The parent widget.\n    color : QColor, optional\n        Custom color for the \"on\" state. If None, uses default blue.\n    \"\"\"\n    if isinstance(text, (type(None), object)) and not isinstance(text, str):\n        parent = text\n        text = \"\"\n    super().__init__(parent)\n    self.setFixedSize(46, 26)\n    self.setCursor(Qt.PointingHandCursor)\n    self._x = self.MARGIN\n    self._anim = QPropertyAnimation(self, b\"offset\", self)\n    self._anim.setDuration(120)\n\n    self._track_on_color = color if color is not None else self.TRACK_ON\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch.getOffset","title":"<code>getOffset()</code>","text":"<p>Get the current horizontal offset of the knob.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current x-coordinate of the knob.</p> Source code in <code>trace/widgets/toggle.py</code> <pre><code>def getOffset(self) -&gt; int:\n    \"\"\"Get the current horizontal offset of the knob.\n\n    Returns\n    -------\n    int\n        The current x-coordinate of the knob.\n    \"\"\"\n    return self._x\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch.setOffset","title":"<code>setOffset(x)</code>","text":"<p>Set the horizontal offset of the knob and update the widget.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The new x-coordinate for the knob.</p> required Source code in <code>trace/widgets/toggle.py</code> <pre><code>def setOffset(self, x: int) -&gt; None:\n    \"\"\"Set the horizontal offset of the knob and update the widget.\n\n    Parameters\n    ----------\n    x : int\n        The new x-coordinate for the knob.\n    \"\"\"\n    self._x = x\n    self.update()\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch.nextCheckState","title":"<code>nextCheckState()</code>","text":"<p>Handle the toggle state change and animate the knob movement. This method is called when the checkbox state changes and manages the animation of the knob from one position to another.</p> Source code in <code>trace/widgets/toggle.py</code> <pre><code>def nextCheckState(self) -&gt; None:\n    \"\"\"Handle the toggle state change and animate the knob movement.\n    This method is called when the checkbox state changes and\n    manages the animation of the knob from one position to another.\n    \"\"\"\n    super().nextCheckState()\n    start = self._x\n    end = self.width() - self.DIAMETER - self.MARGIN if self.isChecked() else self.MARGIN\n\n    self._anim.stop()\n    self._anim.setStartValue(start)\n    self._anim.setEndValue(end)\n    self._anim.start()\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch.setChecked","title":"<code>setChecked(checked)</code>","text":"<p>Override setChecked to handle programmatic state changes with animation.</p> Source code in <code>trace/widgets/toggle.py</code> <pre><code>def setChecked(self, checked: bool) -&gt; None:\n    \"\"\"Override setChecked to handle programmatic state changes with animation.\"\"\"\n    if self.isChecked() != checked:\n        super().setChecked(checked)\n        start = self._x\n        end = self.width() - self.DIAMETER - self.MARGIN if checked else self.MARGIN\n        self._anim.stop()\n        self._anim.setStartValue(start)\n        self._anim.setEndValue(end)\n        self._anim.start()\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch.setCheckState","title":"<code>setCheckState(state)</code>","text":"<p>Override setCheckState to handle Qt.CheckState enums properly in PySide6.</p> Source code in <code>trace/widgets/toggle.py</code> <pre><code>def setCheckState(self, state) -&gt; None:\n    \"\"\"Override setCheckState to handle Qt.CheckState enums properly in PySide6.\"\"\"\n    if isinstance(state, int):\n        checked = state != 0\n    else:\n        checked = state != Qt.Unchecked\n\n    self.setChecked(checked)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch.setColor","title":"<code>setColor(color)</code>","text":"<p>Set the color for the \"on\" state of the toggle switch.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>QColor</code> <p>The color to use when the toggle is in the \"on\" state</p> required Source code in <code>trace/widgets/toggle.py</code> <pre><code>def setColor(self, color: QColor) -&gt; None:\n    \"\"\"Set the color for the \"on\" state of the toggle switch.\n\n    Parameters\n    ----------\n    color : QColor\n        The color to use when the toggle is in the \"on\" state\n    \"\"\"\n    self._track_on_color = color\n    self.update()\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch.getColor","title":"<code>getColor()</code>","text":"<p>Get the current \"on\" state color.</p> <p>Returns:</p> Type Description <code>QColor</code> <p>The current color used for the \"on\" state</p> Source code in <code>trace/widgets/toggle.py</code> <pre><code>def getColor(self) -&gt; QColor:\n    \"\"\"Get the current \"on\" state color.\n\n    Returns\n    -------\n    QColor\n        The current color used for the \"on\" state\n    \"\"\"\n    return self._track_on_color\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch.paintEvent","title":"<code>paintEvent(_)</code>","text":"<p>Paint the toggle switch with the appropriate colors and position.</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>QPaintEvent</code> <p>The paint event (unused).</p> required Source code in <code>trace/widgets/toggle.py</code> <pre><code>def paintEvent(self, _: Any) -&gt; None:\n    \"\"\"Paint the toggle switch with the appropriate colors and position.\n\n    Parameters\n    ----------\n    _ : QPaintEvent\n        The paint event (unused).\n    \"\"\"\n    p = QPainter(self)\n    p.setRenderHint(QPainter.Antialiasing)\n\n    track_col = self._track_on_color if self.isChecked() else self.TRACK_OFF\n    p.setPen(Qt.NoPen)\n    p.setBrush(QColor(track_col))\n    p.drawRoundedRect(self.rect(), self.height() / 2, self.height() / 2)\n\n    # Draw the knob\n    knob_rect = QRect(self._x, self.MARGIN, self.DIAMETER, self.DIAMETER)\n    p.setBrush(Qt.white)\n    p.drawEllipse(knob_rect)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.toggle.ToggleSwitch.hitButton","title":"<code>hitButton(pos)</code>","text":"<p>Determine if the given position is on the button. This is overridden to make the entire widget clickable, not just the standard checkbox indicator area.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>QPoint</code> <p>The position to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the position is within the widget's area, False otherwise.</p> Source code in <code>trace/widgets/toggle.py</code> <pre><code>def hitButton(self, pos: Any) -&gt; bool:\n    \"\"\"Determine if the given position is on the button. This is\n    overridden to make the entire widget clickable, not just the\n    standard checkbox indicator area.\n\n    Parameters\n    ----------\n    pos : QPoint\n        The position to test.\n\n    Returns\n    -------\n    bool\n        True if the position is within the widget's area, False otherwise.\n    \"\"\"\n    return self.contentsRect().contains(pos)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#frozen-table-view","title":"Frozen Table View","text":"<p>The Frozen Table View is an object that will display tabular data while keeping the leftmost column visible on the table at all times. This prevents users from scrolling left-right and hiding the leftmost column.</p>"},{"location":"reference/widgets/helper_widgets/#widgets.frozen_table_view.FrozenTableView","title":"<code>FrozenTableView(model)</code>","text":"<p>               Bases: <code>QTableView</code></p> <p>QTableView with the leftmost column frozen so it always shows while the rest of the table is horizontally scrollable.</p> <p>Python version of Qt FreezeTableWidget example: https://doc.qt.io/qt-6/qtwidgets-itemviews-frozencolumn-example.html</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>QAbstractTableModel</code> <p>The data model for the table</p> required Source code in <code>trace/widgets/frozen_table_view.py</code> <pre><code>def __init__(self, model):\n    \"\"\"Initialize the frozen table view with the given model.\n\n    Parameters\n    ----------\n    model : QAbstractTableModel\n        The data model for the table\n    \"\"\"\n    super(FrozenTableView, self).__init__()\n    self.setModel(model)\n    self.frozenTableView = QTableView(self)\n    self.init()\n    self.horizontalHeader().sectionResized.connect(self.updateSectionWidth)\n    self.verticalHeader().hide()\n    self.frozenTableView.verticalScrollBar().valueChanged.connect(self.verticalScrollBar().setValue)\n    self.verticalScrollBar().valueChanged.connect(self.frozenTableView.verticalScrollBar().setValue)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.frozen_table_view.FrozenTableView.init","title":"<code>init()</code>","text":"<p>Initialize the frozen table view layout and properties.</p> Source code in <code>trace/widgets/frozen_table_view.py</code> <pre><code>def init(self) -&gt; None:\n    \"\"\"Initialize the frozen table view layout and properties.\"\"\"\n    self.frozenTableView.setModel(self.model())\n    self.frozenTableView.setFocusPolicy(Qt.NoFocus)\n    self.frozenTableView.verticalHeader().hide()\n    self.frozenTableView.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\n    self.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\n    self.viewport().stackUnder(self.frozenTableView)\n\n    self.setAlternatingRowColors(True)\n    self.frozenTableView.setAlternatingRowColors(True)\n    self.frozenTableView.setStyleSheet(\"QTableView {border: none; border-right: 1px solid lightGray}\")\n\n    self.setSelectionBehavior(QTableView.SelectRows)\n    self.frozenTableView.setSelectionBehavior(QTableView.SelectRows)\n    self.frozenTableView.setSelectionModel(self.selectionModel())\n    for col in range(1, self.model().columnCount()):\n        self.frozenTableView.setColumnHidden(col, True)\n    self.frozenTableView.setColumnWidth(0, self.columnWidth(0))\n    self.frozenTableView.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n    self.frozenTableView.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n    self.frozenTableView.show()\n    self.updateFrozenTableGeometry()\n    self.setHorizontalScrollMode(QAbstractItemView.ScrollMode.ScrollPerPixel)\n    self.setVerticalScrollMode(QAbstractItemView.ScrollMode.ScrollPerPixel)\n    self.frozenTableView.setVerticalScrollMode(QAbstractItemView.ScrollMode.ScrollPerPixel)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.frozen_table_view.FrozenTableView.updateSectionWidth","title":"<code>updateSectionWidth(logicalIndex, oldSize, newSize)</code>","text":"<p>Update the width of the frozen column when the main table column is resized.</p> <p>Parameters:</p> Name Type Description Default <code>logicalIndex</code> <code>int</code> <p>The logical index of the column being resized</p> required <code>oldSize</code> <code>int</code> <p>The previous width of the column, unused</p> required <code>newSize</code> <code>int</code> <p>The new width of the column</p> required Source code in <code>trace/widgets/frozen_table_view.py</code> <pre><code>def updateSectionWidth(self, logicalIndex, oldSize, newSize) -&gt; None:\n    \"\"\"Update the width of the frozen column when the main table column is resized.\n\n    Parameters\n    ----------\n    logicalIndex : int\n        The logical index of the column being resized\n    oldSize : int\n        The previous width of the column, unused\n    newSize : int\n        The new width of the column\n    \"\"\"\n    if logicalIndex == 0:\n        self.frozenTableView.setColumnWidth(0, newSize)\n        self.updateFrozenTableGeometry()\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.frozen_table_view.FrozenTableView.updateSectionHeight","title":"<code>updateSectionHeight(logicalIndex, oldSize, newSize)</code>","text":"<p>Update the height of a row in the frozen table.</p> <p>Parameters:</p> Name Type Description Default <code>logicalIndex</code> <code>int</code> <p>The logical index of the row being resized</p> required <code>oldSize</code> <code>int</code> <p>The previous height of the row, unused</p> required <code>newSize</code> <code>int</code> <p>The new height of the row</p> required Source code in <code>trace/widgets/frozen_table_view.py</code> <pre><code>def updateSectionHeight(self, logicalIndex, oldSize, newSize) -&gt; None:\n    \"\"\"Update the height of a row in the frozen table.\n\n    Parameters\n    ----------\n    logicalIndex : int\n        The logical index of the row being resized\n    oldSize : int\n        The previous height of the row, unused\n    newSize : int\n        The new height of the row\n    \"\"\"\n    self.frozenTableView.setRowHeight(logicalIndex, newSize)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.frozen_table_view.FrozenTableView.resizeEvent","title":"<code>resizeEvent(event)</code>","text":"<p>Handle resize events by updating the frozen table geometry.</p> Source code in <code>trace/widgets/frozen_table_view.py</code> <pre><code>def resizeEvent(self, event) -&gt; None:\n    \"\"\"Handle resize events by updating the frozen table geometry.\"\"\"\n    super(FrozenTableView, self).resizeEvent(event)\n    self.updateFrozenTableGeometry()\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.frozen_table_view.FrozenTableView.moveCursor","title":"<code>moveCursor(cursorAction, modifiers)</code>","text":"<p>Handle cursor movement with special logic for the frozen column.</p> <p>Parameters:</p> Name Type Description Default <code>cursorAction</code> <code>CursorAction</code> <p>The cursor action being performed</p> required <code>modifiers</code> <code>KeyboardModifiers</code> <p>Keyboard modifiers</p> required <p>Returns:</p> Type Description <code>QModelIndex</code> <p>The new cursor position</p> Source code in <code>trace/widgets/frozen_table_view.py</code> <pre><code>def moveCursor(self, cursorAction, modifiers) -&gt; QModelIndex:\n    \"\"\"Handle cursor movement with special logic for the frozen column.\n\n    Parameters\n    ----------\n    cursorAction : QAbstractItemView.CursorAction\n        The cursor action being performed\n    modifiers : Qt.KeyboardModifiers\n        Keyboard modifiers\n\n    Returns\n    -------\n    QModelIndex\n        The new cursor position\n    \"\"\"\n    current = super(FrozenTableView, self).moveCursor(cursorAction, modifiers)\n    if (\n        cursorAction == self.MoveLeft\n        and current.column() &gt; 0\n        and self.visualRect(current).topLeft().x() &lt; self.frozenTableView.columnWidth(0)\n    ):\n        newValue = (\n            self.horizontalScrollBar().value()\n            + self.visualRect(current).topLeft().x()\n            - self.frozenTableView.columnWidth(0)\n        )\n        self.horizontalScrollBar().setValue(newValue)\n    return current\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.frozen_table_view.FrozenTableView.scrollTo","title":"<code>scrollTo(index, hint)</code>","text":"<p>Scroll to the given index, but only if it's not in the frozen column.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>QModelIndex</code> <p>The index to scroll to</p> required <code>hint</code> <code>ScrollHint</code> <p>The scroll hint</p> required Source code in <code>trace/widgets/frozen_table_view.py</code> <pre><code>def scrollTo(self, index, hint):\n    \"\"\"Scroll to the given index, but only if it's not in the frozen column.\n\n    Parameters\n    ----------\n    index : QModelIndex\n        The index to scroll to\n    hint : QAbstractItemView.ScrollHint\n        The scroll hint\n    \"\"\"\n    if index.column() &gt; 0:\n        super(FrozenTableView, self).scrollTo(index, hint)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.frozen_table_view.FrozenTableView.updateFrozenTableGeometry","title":"<code>updateFrozenTableGeometry()</code>","text":"<p>Update the geometry of the frozen table to match the main table.</p> Source code in <code>trace/widgets/frozen_table_view.py</code> <pre><code>def updateFrozenTableGeometry(self) -&gt; None:\n    \"\"\"Update the geometry of the frozen table to match the main table.\"\"\"\n    self.frozenTableView.setGeometry(\n        self.verticalHeader().width() + self.frameWidth(),\n        self.frameWidth(),\n        self.columnWidth(0),\n        self.viewport().height() + self.horizontalHeader().height(),\n    )\n</code></pre>"},{"location":"reference/widgets/settings_popups/","title":"Settings Popups","text":""},{"location":"reference/widgets/settings_popups/#components","title":"Components","text":""},{"location":"reference/widgets/settings_popups/#widgets.settings_components.SettingsTitle","title":"<code>SettingsTitle(parent, text, size=None)</code>","text":"<p>               Bases: <code>QLabel</code></p> <p>A QLabel with bold formatting for use as section titles in settings dialogs.</p> <p>This widget provides a consistent title appearance across all settings dialogs with optional custom font size.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>text</code> <code>str</code> <p>The title text to display</p> required <code>size</code> <code>int</code> <p>Custom font size in pixels</p> <code>None</code> Source code in <code>trace/widgets/settings_components.py</code> <pre><code>def __init__(self, parent: QWidget, text: str, size: int = None):\n    \"\"\"Initialize the settings title.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget\n    text : str\n        The title text to display\n    size : int, optional\n        Custom font size in pixels\n    \"\"\"\n    super().__init__(text=text, parent=parent)\n    bold_font = QFont()\n    bold_font.setBold(True)\n    if size is not None:\n        bold_font.setPixelSize(size)\n    self.setFont(bold_font)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.settings_components.SettingsRowItem","title":"<code>SettingsRowItem(label_parent, label_txt, widget)</code>","text":"<p>               Bases: <code>QHBoxLayout</code></p> <p>A horizontal layout for settings rows with label and widget.</p> <p>This layout provides a consistent structure for settings rows with a label on the left, a spacer in the middle, and a widget on the right.</p> <p>Parameters:</p> Name Type Description Default <code>label_parent</code> <code>QWidget</code> <p>The parent widget for the label</p> required <code>label_txt</code> <code>str</code> <p>The text for the label</p> required <code>widget</code> <code>QWidget</code> <p>The widget to place on the right side</p> required Source code in <code>trace/widgets/settings_components.py</code> <pre><code>def __init__(self, label_parent: QWidget, label_txt: str, widget: QWidget):\n    \"\"\"Initialize the settings row item.\n\n    Parameters\n    ----------\n    label_parent : QWidget\n        The parent widget for the label\n    label_txt : str\n        The text for the label\n    widget : QWidget\n        The widget to place on the right side\n    \"\"\"\n    super().__init__()\n    label = QLabel(label_txt, label_parent)\n    self.addWidget(label)\n\n    spacer = QSpacerItem(40, 12, QSizePolicy.Expanding, QSizePolicy.Minimum)\n    self.addSpacerItem(spacer)\n\n    self.addWidget(widget)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.settings_components.ComboBoxWrapper","title":"<code>ComboBoxWrapper(parent, data_source, init_value=None)</code>","text":"<p>               Bases: <code>QComboBox</code></p> <p>A QComboBox wrapper that provides data mapping and custom signal emission.</p> <p>This widget extends QComboBox to support data source mapping and emits the mapped value rather than the display text when selection changes.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>data_source</code> <code>list, tuple, or dict</code> <p>Data source for the combo box items. If list/tuple, creates a mapping to itself. If dict, uses keys as display text and values as emitted values.</p> required <code>init_value</code> <code>int, str, or None</code> <p>Initial value to select</p> <code>None</code> Source code in <code>trace/widgets/settings_components.py</code> <pre><code>def __init__(self, parent: QWidget, data_source: list | tuple | dict, init_value: int | str | None = None):\n    \"\"\"Initialize the combo box wrapper.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget\n    data_source : list, tuple, or dict\n        Data source for the combo box items. If list/tuple, creates a\n        mapping to itself. If dict, uses keys as display text and values\n        as emitted values.\n    init_value : int, str, or None, optional\n        Initial value to select\n    \"\"\"\n    super().__init__(parent)\n    if isinstance(data_source, (list, tuple)):\n        data_source = {v: v for v in data_source}\n    self.data_source = data_source\n    self.addItems(self.data_source.keys())\n\n    if init_value is not None:\n        if str(init_value) in self.data_source:\n            self.setCurrentText(str(init_value))\n        else:\n            value_ind = list(self.data_source.values()).index(init_value)\n            self.setCurrentIndex(value_ind)\n\n    self.currentTextChanged.connect(self.clean_text_changed)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.settings_components.ComboBoxWrapper.clean_text_changed","title":"<code>clean_text_changed(inc_text)</code>","text":"<p>Handle text changes and emit the mapped value.</p> <p>Parameters:</p> Name Type Description Default <code>inc_text</code> <code>str</code> <p>The incoming text from the combo box</p> required Source code in <code>trace/widgets/settings_components.py</code> <pre><code>def clean_text_changed(self, inc_text: str) -&gt; None:\n    \"\"\"Handle text changes and emit the mapped value.\n\n    Parameters\n    ----------\n    inc_text : str\n        The incoming text from the combo box\n    \"\"\"\n    outgoing_text = inc_text\n    if inc_text in self.data_source:\n        outgoing_text = self.data_source[inc_text]\n\n    self.text_changed.emit(outgoing_text)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#plot-settings","title":"Plot Settings","text":""},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal","title":"<code>PlotSettingsModal(parent, plot)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Modal widget for configuring plot settings including title, legend, mouse mode, autoscroll interval, time range, crosshair, appearance, and gridlines.</p> <p>This widget provides a comprehensive interface for customizing the appearance and behavior of the PyDMArchiverTimePlot.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>plot</code> <code>PyDMArchiverTimePlot</code> <p>The plot widget to configure</p> required Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>def __init__(self, parent: QWidget, plot: PyDMArchiverTimePlot):\n    \"\"\"Initialize the plot settings modal.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget\n    plot : PyDMArchiverTimePlot\n        The plot widget to configure\n    \"\"\"\n    super().__init__(parent)\n    self.setWindowFlag(Qt.Popup)\n\n    self.plot = plot\n    main_layout = QVBoxLayout()\n    self.setLayout(main_layout)\n\n    title_label = SettingsTitle(self, \"Plot Settings\", size=14)\n    main_layout.addWidget(title_label)\n\n    self.plot_title_line_edit = QLineEdit()\n    self.plot_title_line_edit.setPlaceholderText(\"Enter Title\")\n    self.plot_title_line_edit.textChanged.connect(self.plot.setPlotTitle)\n    self.plot.plotItem.titleLabel.anchor((0.5, 0), (0.5, 0))  # Center title\n    plot_title_row = SettingsRowItem(self, \"Title\", self.plot_title_line_edit)\n    main_layout.addLayout(plot_title_row)\n\n    self.legend_checkbox = QCheckBox(self)\n    self.legend_checkbox.stateChanged.connect(self.set_show_legend)\n    self.legend_checkbox.setChecked(True)  # legend on by default\n    legend_row = SettingsRowItem(self, \"Show Legend\", self.legend_checkbox)\n    main_layout.addLayout(legend_row)\n\n    self.mouse_mode_combo = QComboBox(self)\n    self.mouse_mode_combo.addItems([\"Rect\", \"Pan\"])\n    self.mouse_mode_combo.currentTextChanged.connect(self.plot.plotItem.changeMouseMode)\n    mouse_mode_row = SettingsRowItem(self, \"Mouse Mode\", self.mouse_mode_combo)\n    main_layout.addLayout(mouse_mode_row)\n\n    self.as_interval_spinbox = QSpinBox(self)\n    self.as_interval_spinbox.setValue(5)\n    self.as_interval_spinbox.setMinimum(1)\n    self.as_interval_spinbox.setMaximum(60)\n    self.as_interval_spinbox.setSuffix(\" s\")\n    self.as_interval_spinbox.valueChanged.connect(self.auto_scroll_interval_change.emit)\n    as_interval_row = SettingsRowItem(self, \"Autoscroll Interval\", self.as_interval_spinbox)\n    main_layout.addLayout(as_interval_row)\n\n    self.start_datetime = QDateTimeEdit(self)\n    self.start_datetime.setDisplayFormat(\"yyyy-MM-dd HH:mm:ss\")\n    self.start_datetime.setCalendarPopup(True)\n    self.start_datetime.dateTimeChanged.connect(lambda qdt: self.set_time_axis_range((qdt, None)))\n    start_dt_row = SettingsRowItem(self, \"Start Time\", self.start_datetime)\n    main_layout.addLayout(start_dt_row)\n\n    self.end_datetime = QDateTimeEdit(self)\n    self.end_datetime.setDisplayFormat(\"yyyy-MM-dd HH:mm:ss\")\n    self.end_datetime.setCalendarPopup(True)\n    self.end_datetime.dateTimeChanged.connect(lambda qdt: self.set_time_axis_range((None, qdt)))\n    end_dt_row = SettingsRowItem(self, \"End Time\", self.end_datetime)\n    main_layout.addLayout(end_dt_row)\n\n    self.crosshair_checkbox = QCheckBox(self)\n    self.crosshair_checkbox.stateChanged.connect(self.set_crosshair)\n    crosshair_row = SettingsRowItem(self, \"Show Crosshair\", self.crosshair_checkbox)\n    main_layout.addLayout(crosshair_row)\n\n    appearance_label = SettingsTitle(self, \"Appearance\")\n    main_layout.addWidget(appearance_label)\n\n    self.background_button = ColorButton(parent=self, color=\"white\")\n    self.background_button.color_changed.connect(self.plot.setBackgroundColor)\n    background_row = SettingsRowItem(self, \"  Background Color\", self.background_button)\n    main_layout.addLayout(background_row)\n\n    self.palette_modal = CurveColorPaletteModal(self)\n    self.curve_palette_button = QPushButton(\"Select\")\n    self.curve_palette_button.clicked.connect(self.palette_modal.show)\n    self.palette_modal.sig_palette_changed.connect(self.sig_curve_palette_changed.emit)\n    palette_row = SettingsRowItem(self, \"  Curve Palette\", self.curve_palette_button)\n    main_layout.addLayout(palette_row)\n\n    axis_tick_font_size_spinbox = QSpinBox(self)\n    axis_tick_font_size_spinbox.setValue(12)\n    axis_tick_font_size_spinbox.setSuffix(\" pt\")\n    axis_tick_font_size_spinbox.valueChanged.connect(self.set_axis_tick_font_size)\n    axis_tick_font_size_row = SettingsRowItem(self, \"  Axis Tick Font Size\", axis_tick_font_size_spinbox)\n    main_layout.addLayout(axis_tick_font_size_row)\n\n    self.x_grid_checkbox = QCheckBox(self)\n    self.x_grid_checkbox.stateChanged.connect(self.show_x_grid)\n    x_grid_row = SettingsRowItem(self, \"  X Axis Gridline\", self.x_grid_checkbox)\n    main_layout.addLayout(x_grid_row)\n\n    self.y_grid_checkbox = QCheckBox(self)\n    self.y_grid_checkbox.stateChanged.connect(self.show_y_grid)\n    y_grid_row = SettingsRowItem(self, \"  All Y Axis Gridlines\", self.y_grid_checkbox)\n    main_layout.addLayout(y_grid_row)\n\n    self.grid_opacity_slider = QSlider(self)\n    self.grid_opacity_slider.setOrientation(Qt.Horizontal)\n    self.grid_opacity_slider.setMaximum(255)\n    self.grid_opacity_slider.setValue(127)\n    self.grid_opacity_slider.setSingleStep(32)\n    self.grid_opacity_slider.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n    self.grid_opacity_slider.valueChanged.connect(self.change_gridline_opacity)\n    grid_opacity_row = SettingsRowItem(self, \"  Gridline Opacity\", self.grid_opacity_slider)\n    main_layout.addLayout(grid_opacity_row)\n\n    plot_viewbox = self.plot.plotItem.vb\n    plot_viewbox.sigXRangeChanged.connect(self.set_axis_datetimes)\n    plot_viewbox.sigRangeChangedManually.connect(lambda *_: self.set_axis_datetimes())\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.auto_scroll_interval","title":"<code>auto_scroll_interval</code>  <code>property</code>","text":"<p>Get the autoscroll interval in milliseconds.</p>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.x_grid_visible","title":"<code>x_grid_visible</code>  <code>property</code>","text":"<p>Check if X-axis gridlines are visible.</p>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.gridline_opacity","title":"<code>gridline_opacity</code>  <code>property</code>","text":"<p>Get the current gridline opacity value (0-255).</p>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.show","title":"<code>show()</code>","text":"<p>Show the modal positioned relative to its parent widget.</p> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>def show(self):\n    \"\"\"Show the modal positioned relative to its parent widget.\"\"\"\n    parent_pos = self.parent().rect().bottomRight()\n    global_pos = self.parent().mapToGlobal(parent_pos)\n    self.move(global_pos)\n    super().show()\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_show_legend","title":"<code>set_show_legend(state)</code>","text":"<p>Set the legend visibility based on checkbox state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int or CheckState</code> <p>The checkbox state</p> required Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(int)\n@Slot(Qt.CheckState)\ndef set_show_legend(self, state: int | Qt.CheckState) -&gt; None:\n    \"\"\"Set the legend visibility based on checkbox state.\n\n    Parameters\n    ----------\n    state : int or Qt.CheckState\n        The checkbox state\n    \"\"\"\n    checked = Qt.CheckState(state) == Qt.Checked\n    self.plot.setShowLegend(checked)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_axis_tick_font_size","title":"<code>set_axis_tick_font_size(size)</code>","text":"<p>Set the font size for all axis tick labels.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The font size in pixels</p> required Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(int)\ndef set_axis_tick_font_size(self, size: int) -&gt; None:\n    \"\"\"Set the font size for all axis tick labels.\n\n    Parameters\n    ----------\n    size : int\n        The font size in pixels\n    \"\"\"\n    font = QFont()\n    font.setPixelSize(size)\n\n    all_axes = self.plot.plotItem.getAxes()\n    for axis in all_axes:\n        axis.setStyle(tickFont=font)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_time_axis_range","title":"<code>set_time_axis_range(raw_range=(None, None))</code>","text":"<p>PyQT Slot to set the plot's X-Axis range. This slot should be triggered on QDateTimeEdit value change.</p> <p>Parameters:</p> Name Type Description Default <code>raw_range</code> <code>tuple[QDateTime, QDateTime]</code> <p>Takes in a tuple of 2 values, where one is a QDateTime and the other is None. The positioning changes either the plot's min or max range value. By default (None, None)</p> <code>(None, None)</code> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(object)\ndef set_time_axis_range(self, raw_range: tuple[QDateTime, QDateTime] = (None, None)) -&gt; None:\n    \"\"\"PyQT Slot to set the plot's X-Axis range. This slot should be\n    triggered on QDateTimeEdit value change.\n\n    Parameters\n    ----------\n    raw_range : tuple[QDateTime, QDateTime], optional\n        Takes in a tuple of 2 values, where one is a QDateTime and\n        the other is None. The positioning changes either the plot's\n        min or max range value. By default (None, None)\n    \"\"\"\n    # Disable Autoscroll if enabled\n    # self.ui.cursor_scale_btn.click()\n    self.disable_autoscroll.emit()\n\n    proc_range = [None, None]\n    for ind, val in enumerate(raw_range):\n        # Values that are QDateTime are converted to a float timestamp\n        if isinstance(val, QDateTime):\n            proc_range[ind] = val.toSecsSinceEpoch()\n        # Values that are None use the existing range value\n        elif not val:\n            proc_range[ind] = self.plot.getXAxis().range[ind]\n    proc_range.sort()\n\n    logger.debug(f\"Setting plot's X-Axis range to {proc_range}\")\n    self.plot.plotItem.vb.blockSignals(True)\n    self.plot.plotItem.setXRange(*proc_range, padding=0)\n    self.plot.plotItem.vb.blockSignals(False)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_crosshair","title":"<code>set_crosshair(state)</code>","text":"<p>Enable or disable the crosshair on the plot.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int or CheckState</code> <p>The checkbox state</p> required Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(int)\n@Slot(Qt.CheckState)\ndef set_crosshair(self, state: int | Qt.CheckState) -&gt; None:\n    \"\"\"Enable or disable the crosshair on the plot.\n\n    Parameters\n    ----------\n    state : int or Qt.CheckState\n        The checkbox state\n    \"\"\"\n    checked = Qt.CheckState(state) == Qt.Checked\n    self.plot.enableCrosshair(checked, 100, 100)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_axis_datetimes","title":"<code>set_axis_datetimes(_=None, time_range=None)</code>","text":"<p>Slot used to update the QDateTimeEdits on the Axis tab. This slot is called when the plot's X-Axis range changes values.</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>ViewBox</code> <p>The ViewBox on which the range is changing. This is unused</p> <code>None</code> <code>time_range</code> <code>Tuple[float, float]</code> <p>The new range values for the QDateTimeEdits, by default None</p> <code>None</code> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(object, object)\ndef set_axis_datetimes(self, _: ViewBox = None, time_range: tuple[float, float] = None) -&gt; None:\n    \"\"\"Slot used to update the QDateTimeEdits on the Axis tab. This\n    slot is called when the plot's X-Axis range changes values.\n\n    Parameters\n    ----------\n    _ : ViewBox, optional\n        The ViewBox on which the range is changing. This is unused\n    time_range : Tuple[float, float], optional\n        The new range values for the QDateTimeEdits, by default None\n    \"\"\"\n    if not time_range:\n        time_range = self.plot.getXAxis().range\n    if min(time_range) &lt;= 0:\n        return\n\n    time_range = [datetime.fromtimestamp(f) for f in time_range]\n\n    edits = (self.start_datetime, self.end_datetime)\n    for ind, qdt in enumerate(edits):\n        if qdt.hasFocus():\n            continue\n        qdt.blockSignals(True)\n        qdt.setDateTime(QDateTime(time_range[ind]))\n        qdt.blockSignals(False)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.show_x_grid","title":"<code>show_x_grid(state)</code>","text":"<p>Show or hide the X-Axis gridlines.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int or CheckState</code> <p>The checkbox state</p> required Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(int)\n@Slot(Qt.CheckState)\ndef show_x_grid(self, state: int | Qt.CheckState) -&gt; None:\n    \"\"\"Show or hide the X-Axis gridlines.\n\n    Parameters\n    ----------\n    state : int or Qt.CheckState\n        The checkbox state\n    \"\"\"\n    visible = Qt.CheckState(state) == Qt.Checked\n    opacity = self.gridline_opacity\n    self.set_plot_gridlines(visible, opacity)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.show_y_grid","title":"<code>show_y_grid(state)</code>","text":"<p>Show or hide all Y-axis gridlines.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int or CheckState</code> <p>The checkbox state</p> required Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(int)\n@Slot(Qt.CheckState)\ndef show_y_grid(self, state: int | Qt.CheckState) -&gt; None:\n    \"\"\"Show or hide all Y-axis gridlines.\n\n    Parameters\n    ----------\n    state : int or Qt.CheckState\n        The checkbox state\n    \"\"\"\n    visible = Qt.CheckState(state) == Qt.Checked\n    self.set_all_y_axis_gridlines.emit(visible)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.change_gridline_opacity","title":"<code>change_gridline_opacity(opacity)</code>","text":"<p>Change the opacity of the gridlines for both X and Y axes.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>int</code> <p>The opacity value (0-255)</p> required Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(int)\ndef change_gridline_opacity(self, opacity: int):\n    \"\"\"Change the opacity of the gridlines for both X and Y axes.\n\n    Parameters\n    ----------\n    opacity : int\n        The opacity value (0-255)\n    \"\"\"\n    visible = self.x_grid_visible\n    self.set_plot_gridlines(visible, opacity)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_plot_gridlines","title":"<code>set_plot_gridlines(visible, opacity)</code>","text":"<p>Set the plot's gridlines visibility and opacity for both X and Y axes.</p> <p>Parameters:</p> Name Type Description Default <code>visible</code> <code>bool</code> <p>Whether gridlines should be visible</p> required <code>opacity</code> <code>int</code> <p>The opacity value (0-255)</p> required Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>def set_plot_gridlines(self, visible: bool, opacity: int):\n    \"\"\"Set the plot's gridlines visibility and opacity for both X and Y axes.\n\n    Parameters\n    ----------\n    visible : bool\n        Whether gridlines should be visible\n    opacity : int\n        The opacity value (0-255)\n    \"\"\"\n    normalized_opacity = opacity / 255\n    self.plot.setShowXGrid(visible, normalized_opacity)\n    self.grid_alpha_change.emit(opacity)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.plot_setup","title":"<code>plot_setup(config)</code>","text":"<p>Configure the plot settings from a configuration dictionary.</p> <p>This method reads configuration values and updates the corresponding widgets, which will emit signals to update the plot.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Configuration dictionary containing plot settings</p> required Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(dict)\ndef plot_setup(self, config: dict):\n    \"\"\"Configure the plot settings from a configuration dictionary.\n\n    This method reads configuration values and updates the corresponding\n    widgets, which will emit signals to update the plot.\n\n    Parameters\n    ----------\n    config : dict\n        Configuration dictionary containing plot settings\n    \"\"\"\n    if \"title\" in config:\n        self.plot_title_line_edit.setText(str(config[\"title\"]))\n    if \"legend\" in config:\n        self.legend_checkbox.setChecked(bool(config[\"legend\"]))\n    if \"mouseMode\" in config:\n        mouse_mode_index = int(config[\"mouseMode\"] / 3)\n        self.mouse_mode_combo.setCurrentIndex(mouse_mode_index)\n    if \"refreshInterval\" in config:\n        self.as_interval_spinbox.setValue(int(config[\"refreshInterval\"] / 1000))\n    if \"crosshair\" in config:\n        self.crosshair_checkbox.setChecked(bool(config[\"crosshair\"]))\n    if \"backgroundColor\" in config:\n        self.background_button.color = QColor(config[\"backgroundColor\"])\n    if \"xGrid\" in config:\n        self.x_grid_checkbox.setChecked(bool(config[\"xGrid\"]))\n    if \"yGrid\" in config:\n        self.y_grid_checkbox.setChecked(bool(config[\"yGrid\"]))\n    if \"gridOpacity\" in config:\n        self.grid_opacity_slider.setValue(int(config[\"gridOpacity\"]))\n</code></pre>"},{"location":"reference/widgets/settings_popups/#axis-settings","title":"Axis Settings","text":""},{"location":"reference/widgets/settings_popups/#widgets.axis_settings.AxisSettingsModal","title":"<code>AxisSettingsModal(parent, plot, axis)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Modal widget for configuring individual axis settings including orientation, log mode, and gridline visibility.</p> <p>This widget provides an interface for customizing the appearance and behavior of a single axis on the plot.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>plot</code> <code>PyDMArchiverTimePlot</code> <p>The plot widget containing the axis</p> required <code>axis</code> <code>BasePlotAxisItem</code> <p>The axis to configure</p> required Source code in <code>trace/widgets/axis_settings.py</code> <pre><code>def __init__(self, parent: QWidget, plot: PyDMArchiverTimePlot, axis: BasePlotAxisItem):\n    \"\"\"Initialize the axis settings modal.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget\n    plot : PyDMArchiverTimePlot\n        The plot widget containing the axis\n    axis : BasePlotAxisItem\n        The axis to configure\n    \"\"\"\n    super().__init__(parent)\n    self.setWindowFlag(Qt.Popup)\n\n    self.plot = plot\n    self.axis = axis\n    main_layout = QVBoxLayout()\n    self.setLayout(main_layout)\n\n    title_label = SettingsTitle(self, \"Axis Settings\", size=14)\n    main_layout.addWidget(title_label)\n\n    orientation_combo = QComboBox(self)\n    orientation_combo.addItems([\"Left\", \"Right\"])\n    orientation_combo.currentTextChanged.connect(self.set_axis_orientation)\n    orientation_combo.setCurrentText(\"Right\" if self.axis.orientation == \"right\" else \"Left\")\n    orientation_row = SettingsRowItem(self, \"Orientation\", orientation_combo)\n    main_layout.addLayout(orientation_row)\n\n    log_checkbox = QCheckBox(self)\n    log_checkbox.setChecked(self.axis.log_mode)\n    log_checkbox.stateChanged.connect(self.set_axis_log_mode)\n    log_mode_row = SettingsRowItem(self, \"Log Mode\", log_checkbox)\n    main_layout.addLayout(log_mode_row)\n\n    self.grid_checkbox = QCheckBox(self)\n    self.grid_checkbox.setChecked(bool(self.axis.grid))\n    self.grid_checkbox.stateChanged.connect(self.show_grid)\n    y_grid_row = SettingsRowItem(self, \"Y Axis Gridline\", self.grid_checkbox)\n    main_layout.addLayout(y_grid_row)\n\n    self.palette_modal = CurveColorPaletteModal(self)\n    self.curve_palette_button = QPushButton(\"Select\")\n    self.curve_palette_button.clicked.connect(self.palette_modal.show)\n    self.palette_modal.sig_palette_changed.connect(self.sig_curve_palette_changed.emit)\n    palette_row = SettingsRowItem(self, \"Curve Palette\", self.curve_palette_button)\n    main_layout.addLayout(palette_row)\n\n    self.trace_display = self.parent()\n    while self.trace_display is not None and not isinstance(self.trace_display, Display):\n        self.trace_display = self.trace_display.parent()\n    if self.trace_display is not None:\n        self.trace_display.gridline_opacity_change.connect(self.change_gridline_opacity)\n        self.trace_display.set_all_y_axis_gridlines.connect(self.grid_checkbox.setChecked)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.axis_settings.AxisSettingsModal.grid_visible","title":"<code>grid_visible</code>  <code>property</code>","text":"<p>Check if gridlines are visible for this axis.</p>"},{"location":"reference/widgets/settings_popups/#widgets.axis_settings.AxisSettingsModal.show","title":"<code>show()</code>","text":"<p>Show the modal positioned relative to its parent widget.</p> Source code in <code>trace/widgets/axis_settings.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the modal positioned relative to its parent widget.\"\"\"\n    parent_pos = self.parent().rect().bottomRight()\n    global_pos = self.parent().mapToGlobal(parent_pos)\n    self.move(global_pos)\n    super().show()\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.axis_settings.AxisSettingsModal.set_axis_orientation","title":"<code>set_axis_orientation(orientation)</code>","text":"<p>Set the axis orientation (Left or Right).</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>str</code> <p>The orientation string (\"Left\" or \"Right\")</p> required Source code in <code>trace/widgets/axis_settings.py</code> <pre><code>@Slot(str)\ndef set_axis_orientation(self, orientation: str) -&gt; None:\n    \"\"\"Set the axis orientation (Left or Right).\n\n    Parameters\n    ----------\n    orientation : str\n        The orientation string (\"Left\" or \"Right\")\n    \"\"\"\n    if orientation not in [\"Left\", \"Right\"]:\n        return\n    self.axis.orientation = orientation.lower()\n    self.plot.plotItem.rebuildLayout()\n    if self.axis.isVisible():\n        self.axis.show()\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.axis_settings.AxisSettingsModal.set_axis_log_mode","title":"<code>set_axis_log_mode(state)</code>","text":"<p>Enable or disable logarithmic scale for the axis.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int or CheckState</code> <p>The checkbox state</p> required Source code in <code>trace/widgets/axis_settings.py</code> <pre><code>@Slot(int)\n@Slot(Qt.CheckState)\ndef set_axis_log_mode(self, state: int | Qt.CheckState) -&gt; None:\n    \"\"\"Enable or disable logarithmic scale for the axis.\n\n    Parameters\n    ----------\n    state : int or Qt.CheckState\n        The checkbox state\n    \"\"\"\n    checked = Qt.CheckState(state) == Qt.Checked\n    self.axis.log_mode = checked\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.axis_settings.AxisSettingsModal.show_grid","title":"<code>show_grid(state)</code>","text":"<p>Show or hide gridlines for the axis.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int or CheckState</code> <p>The checkbox state</p> required Source code in <code>trace/widgets/axis_settings.py</code> <pre><code>@Slot(int)\n@Slot(Qt.CheckState)\ndef show_grid(self, state: int | Qt.CheckState) -&gt; None:\n    \"\"\"Show or hide gridlines for the axis.\n\n    Parameters\n    ----------\n    state : int or Qt.CheckState\n        The checkbox state\n    \"\"\"\n    checked = Qt.CheckState(state) == Qt.Checked\n    if not checked:\n        self.axis.setGrid(False)\n    else:\n        try:\n            opacity = self.trace_display.gridline_opacity\n        except AttributeError:\n            logger.debug(\"No trace display found, defaulting to full opacity\")\n            opacity = 255\n        self.axis.setGrid(opacity)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.axis_settings.AxisSettingsModal.change_gridline_opacity","title":"<code>change_gridline_opacity(opacity)</code>","text":"<p>Change the opacity of gridlines for this axis.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>int</code> <p>The opacity value (0-255)</p> required Source code in <code>trace/widgets/axis_settings.py</code> <pre><code>@Slot(int)\ndef change_gridline_opacity(self, opacity: int) -&gt; None:\n    \"\"\"Change the opacity of gridlines for this axis.\n\n    Parameters\n    ----------\n    opacity : int\n        The opacity value (0-255)\n    \"\"\"\n    if not self.grid_visible:\n        return\n    self.axis.setGrid(opacity)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#curve-settings","title":"Curve Settings","text":""},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal","title":"<code>CurveSettingsModal(parent, plot, curve)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Modal widget for configuring individual curve settings including name, color, data bins, live/archive connections, line properties, and symbol properties.</p> <p>This widget provides a comprehensive interface for customizing the appearance and behavior of a single curve on the plot.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>plot</code> <code>PyDMArchiverTimePlot</code> <p>The plot widget containing the curve</p> required <code>curve</code> <code>TimePlotCurveItem</code> <p>The curve to configure</p> required Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>def __init__(self, parent: QWidget, plot: PyDMArchiverTimePlot, curve: TimePlotCurveItem):\n    \"\"\"Initialize the curve settings modal.\n\n    Parameters\n    ----------\n    parent : QWidget\n        The parent widget\n    plot : PyDMArchiverTimePlot\n        The plot widget containing the curve\n    curve : TimePlotCurveItem\n        The curve to configure\n    \"\"\"\n    super().__init__(parent)\n    self.setWindowFlag(Qt.Popup)\n\n    self.legend = plot._legend\n    self.curve = curve\n    main_layout = QVBoxLayout()\n    self.setLayout(main_layout)\n\n    title_label = SettingsTitle(self, \"Curve Settings\", size=14)\n    main_layout.addWidget(title_label)\n\n    name_edit = QLineEdit(curve.name(), self)\n    name_edit.editingFinished.connect(self.set_curve_name)\n    name_row = SettingsRowItem(self, \"Curve Name\", name_edit)\n    main_layout.addLayout(name_row)\n\n    color_button = ColorButton(parent=self, color=curve.color_string)\n    color_button.color_changed.connect(self.set_curve_color)\n    color_row = SettingsRowItem(self, \"Color\", color_button)\n    main_layout.addLayout(color_row)\n\n    self.bin_count_line_edit = None\n    if hasattr(curve, \"setOptimizedDataBins\"):\n        self.bin_count_line_edit = bin_count_line_edit = QLineEdit()\n        bin_count_line_edit.setMaximumWidth(65)\n        bin_count_line_edit.returnPressed.connect(self.set_curve_data_bins)\n        optimized_bin_count = SettingsRowItem(self, \"Optimized bin count\", bin_count_line_edit)\n        bin_count = curve.optimized_data_bins\n        if not bin_count:\n            bin_count = plot.optimized_data_bins\n        bin_count_line_edit.setPlaceholderText(str(bin_count))\n        main_layout.addLayout(optimized_bin_count)\n\n    self.live_toggle = QCheckBox(\"\")\n    self.live_toggle.setCheckState(Qt.Checked if self.curve.liveData else Qt.Unchecked)\n    self.live_toggle.stateChanged.connect(self.set_live_data_connection)\n    live_toggle_row = SettingsRowItem(self, \"Connect to Live\", self.live_toggle)\n    main_layout.addLayout(live_toggle_row)\n\n    self.archive_toggle = QCheckBox(\"\")\n    self.archive_toggle.setCheckState(Qt.Checked if self.curve.use_archive_data else Qt.Unchecked)\n    self.archive_toggle.stateChanged.connect(self.set_archive_data_connection)\n    archive_toggle_row = SettingsRowItem(self, \"Connect to Archive\", self.archive_toggle)\n    main_layout.addLayout(archive_toggle_row)\n\n    line_title_label = SettingsTitle(self, \"Line\")\n    main_layout.addWidget(line_title_label)\n\n    init_curve_type = \"Step\" if curve.stepMode in [\"left\", \"right\", \"center\"] else \"Direct\"\n    type_combo = ComboBoxWrapper(self, {\"Direct\": None, \"Step\": \"right\"}, init_curve_type)\n    type_combo.text_changed.connect(self.set_curve_type)\n    type_row = SettingsRowItem(self, \"  Type\", type_combo)\n    main_layout.addLayout(type_row)\n\n    style_combo = ComboBoxWrapper(self, TimePlotCurveItem.lines, curve.lineStyle)\n    style_combo.text_changed.connect(self.set_curve_style)\n    style_row = SettingsRowItem(self, \"  Style\", style_combo)\n    main_layout.addLayout(style_row)\n\n    width_options = {f\"{i}px\": i for i in range(1, 6)}\n    width_combo = ComboBoxWrapper(self, width_options, curve.lineWidth)\n    width_combo.text_changed.connect(self.set_curve_width)\n    width_row = SettingsRowItem(self, \"  Width\", width_combo)\n    main_layout.addLayout(width_row)\n\n    extension_option = QCheckBox(self)\n    extension_option.stateChanged.connect(self.set_extension_option)\n    extension_option_row = SettingsRowItem(self, \"  Line Extension\", extension_option)\n    main_layout.addLayout(extension_option_row)\n\n    symbol_title_label = SettingsTitle(self, \"Symbol\")\n    main_layout.addWidget(symbol_title_label)\n\n    shape_combo = ComboBoxWrapper(self, TimePlotCurveItem.symbols, curve.symbol)\n    shape_combo.text_changed.connect(self.set_symbol_shape)\n    shape_row = SettingsRowItem(self, \"  Shape\", shape_combo)\n    main_layout.addLayout(shape_row)\n\n    size_options = {f\"{i}px\": i for i in range(5, 26, 5)}\n    size_combo = ComboBoxWrapper(self, size_options, curve.symbolSize)\n    size_combo.text_changed.connect(self.set_symbol_size)\n    size_row = SettingsRowItem(self, \"  Size\", size_combo)\n    main_layout.addLayout(size_row)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_curve_data_bins","title":"<code>set_curve_data_bins()</code>","text":"<p>Set the optimized data bins for the curve based on user input.</p> <p>Validates the input and updates the curve's bin count if valid. Shows visual feedback for invalid input.</p> Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>def set_curve_data_bins(self) -&gt; None:\n    \"\"\"Set the optimized data bins for the curve based on user input.\n\n    Validates the input and updates the curve's bin count if valid.\n    Shows visual feedback for invalid input.\n    \"\"\"\n    n_bins = self.bin_count_line_edit.text()\n    if not n_bins.isdigit() or int(n_bins) &lt; 1:\n        self.bin_count_line_edit.setStyleSheet(\"border: 2px solid #d32f2f\")\n        logger.warning(\"Invalid bin count entered. Please enter a postive integer.\")\n        return\n    else:\n        self.bin_count_line_edit.setStyleSheet(\"\")\n    try:\n        n_bins = int(n_bins)\n        self.curve.setOptimizedDataBins(n_bins)\n        self.bin_count_line_edit.setPlaceholderText(str(n_bins))\n    except (AttributeError, ValueError) as e:\n        logger.warning(f\"Unable to set data bins: {e}\")\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_live_data_connection","title":"<code>set_live_data_connection(state)</code>","text":"<p>Enable or disable live data connection for the curve.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>CheckState</code> <p>The checkbox state</p> required Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>def set_live_data_connection(self, state: Qt.CheckState) -&gt; None:\n    \"\"\"Enable or disable live data connection for the curve.\n\n    Parameters\n    ----------\n    state : Qt.CheckState\n        The checkbox state\n    \"\"\"\n    self.curve.liveData = state == Qt.Checked\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_archive_data_connection","title":"<code>set_archive_data_connection(state)</code>","text":"<p>Enable or disable archive data connection for the curve.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>CheckState</code> <p>The checkbox state</p> required Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>def set_archive_data_connection(self, state: Qt.CheckState) -&gt; None:\n    \"\"\"Enable or disable archive data connection for the curve.\n\n    Parameters\n    ----------\n    state : Qt.CheckState\n        The checkbox state\n    \"\"\"\n    self.curve.use_archive_data = state == Qt.Checked\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.show","title":"<code>show()</code>","text":"<p>Show the modal positioned relative to its parent widget.</p> Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the modal positioned relative to its parent widget.\"\"\"\n    # Reset Bin Count LineEdit if it exists\n    if self.bin_count_line_edit:\n        self.bin_count_line_edit.setStyleSheet(\"\")\n        self.bin_count_line_edit.setText(\"\")\n\n    parent_pos = self.parent().rect().bottomRight()\n    global_pos = self.parent().mapToGlobal(parent_pos)\n    self.move(global_pos)\n    super().show()\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_curve_name","title":"<code>set_curve_name()</code>","text":"<p>Set the curve name based on user input.</p> <p>If the name is empty, reverts to the original name. Updates both the curve data and legend label.</p> Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>@Slot()\ndef set_curve_name(self) -&gt; None:\n    \"\"\"Set the curve name based on user input.\n\n    If the name is empty, reverts to the original name.\n    Updates both the curve data and legend label.\n    \"\"\"\n    sender = self.sender()\n    name = sender.text()\n\n    if not name:\n        sender.blockSignals(True)\n        sender.setText(self.curve.name())\n        sender.blockSignals(False)\n    elif name != self.curve.name():\n        legend_label = self.legend.getLabel(self.curve)\n        legend_label.setText(name)\n\n        x, y = self.curve.getData()\n        self.curve.setData(name=name, x=x, y=y)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_curve_color","title":"<code>set_curve_color(color)</code>","text":"<p>Set the curve color and emit the color changed signal.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>QColor</code> <p>The new color for the curve</p> required Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>@Slot(QColor)\ndef set_curve_color(self, color: QColor) -&gt; None:\n    \"\"\"Set the curve color and emit the color changed signal.\n\n    Parameters\n    ----------\n    color : QColor\n        The new color for the curve\n    \"\"\"\n    self.curve.color = color\n    self.color_changed.emit(color)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_curve_type","title":"<code>set_curve_type(curve_type=None)</code>","text":"<p>Set the curve step mode (Direct or Step).</p> <p>Parameters:</p> Name Type Description Default <code>curve_type</code> <code>str or None</code> <p>The step mode type, or None for direct plotting</p> <code>None</code> Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>@Slot(object)\ndef set_curve_type(self, curve_type: str | None = None) -&gt; None:\n    \"\"\"Set the curve step mode (Direct or Step).\n\n    Parameters\n    ----------\n    curve_type : str or None\n        The step mode type, or None for direct plotting\n    \"\"\"\n    self.curve.stepMode = curve_type\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_curve_style","title":"<code>set_curve_style(style)</code>","text":"<p>Set the line style for the curve.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>int</code> <p>The line style index</p> required Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>@Slot(object)\ndef set_curve_style(self, style: int) -&gt; None:\n    \"\"\"Set the line style for the curve.\n\n    Parameters\n    ----------\n    style : int\n        The line style index\n    \"\"\"\n    self.curve.lineStyle = style\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_curve_width","title":"<code>set_curve_width(width)</code>","text":"<p>Set the line width for the curve.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The line width in pixels</p> required Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>@Slot(object)\ndef set_curve_width(self, width: int) -&gt; None:\n    \"\"\"Set the line width for the curve.\n\n    Parameters\n    ----------\n    width : int\n        The line width in pixels\n    \"\"\"\n    self.curve.lineWidth = width\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_extension_option","title":"<code>set_extension_option(state)</code>","text":"<p>Enable or disable line extension for the curve.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int or CheckState</code> <p>The checkbox state</p> required Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>@Slot(int)\n@Slot(Qt.CheckState)\ndef set_extension_option(self, state: int | Qt.CheckState) -&gt; None:\n    \"\"\"Enable or disable line extension for the curve.\n\n    Parameters\n    ----------\n    state : int or Qt.CheckState\n        The checkbox state\n    \"\"\"\n    enable = Qt.CheckState(state) == Qt.Checked\n\n    self.curve.show_extension_line = enable\n    self.curve.getViewBox().addItem(self.curve._extension_line)\n    self.curve.redrawCurve()\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_symbol_shape","title":"<code>set_symbol_shape(shape)</code>","text":"<p>Set the symbol shape for the curve.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>str</code> <p>The symbol shape name</p> required Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>@Slot(object)\ndef set_symbol_shape(self, shape: str) -&gt; None:\n    \"\"\"Set the symbol shape for the curve.\n\n    Parameters\n    ----------\n    shape : str\n        The symbol shape name\n    \"\"\"\n    self.curve.symbol = shape\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_symbol_size","title":"<code>set_symbol_size(size)</code>","text":"<p>Set the symbol size for the curve.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The symbol size in pixels</p> required Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>@Slot(object)\ndef set_symbol_size(self, size: int) -&gt; None:\n    \"\"\"Set the symbol size for the curve.\n\n    Parameters\n    ----------\n    size : int\n        The symbol size in pixels\n    \"\"\"\n    self.curve.symbolSize = size\n</code></pre>"},{"location":"tools/data_insight/","title":"Data Insight Tool","text":""},{"location":"tools/data_insight/#overview","title":"Overview","text":"<p>The Data Insight Tool (DIT) lets you inspect and export all data for a single curve on the current plot within the plot's time range. It aggregates both live samples already shown on the plot and archived samples fetched from the Archiver Appliance for the same time window.</p>"},{"location":"tools/data_insight/#what-you-can-do","title":"What you can do","text":"<ul> <li>View data: See a combined table of timestamps, values, severities, and whether each row came from Live or Archive.</li> <li>Inspect metadata: See the curve's unit and description (fetched from <code>&lt;PV&gt;.EGU</code> and <code>&lt;PV&gt;.DESC</code>).</li> <li>Refresh: Re-query data for the current plot time range.</li> <li>Export: Save the combined dataset to CSV, MAT, or JSON with metadata.</li> </ul>"},{"location":"tools/data_insight/#prerequisites","title":"Prerequisites","text":"<ul> <li>The main plot must contain at least one <code>ArchivePlotCurveItem</code> (a curve with a valid PV address).</li> <li>To fetch archived data, set the environment variable <code>PYDM_ARCHIVER_URL</code> to your Archiver Appliance URL (for example, <code>http://lcls-archapp.slac.stanford.edu</code>). Without this, only live data already in the plot will be shown.</li> </ul>"},{"location":"tools/data_insight/#open-the-tool","title":"Open the tool","text":"<p>The tool can be opened with from the Trace menu or with <code>Ctrl+D</code>. It appears as a separate window alongside Trace. The tool has these features:</p> <ul> <li>A PV selection dropdown</li> <li>A loading indicator</li> <li>Export and Refresh buttons</li> <li>A metadata label (unit and description)</li> <li>A data table</li> </ul>"},{"location":"tools/data_insight/#using-the-tool","title":"Using the tool","text":"<ol> <li>Select a PV: Use the dropdown to choose the curve (PV) of interest. The list includes curves currently on the plot.</li> <li>Time range: The DIT always uses the plot's current X-axis range. Adjust the plot window to change what the DIT loads.</li> <li>Loading: A \"Loading\u2026\" label is shown while the tool fetches archived data.</li> <li>Combined data: The table shows four columns:<ul> <li>Datetime</li> <li>Value</li> <li>Severity</li> <li>Source (\"Live\" for plot buffer samples within range, \"Archive\" for data fetched from the Archiver)</li> <li>Note: Rows with Source \"Live\" currently show Severity as <code>NaN</code>. Capturing severity for live data is planned for a future update.</li> </ul> </li> <li>Metadata: The label above the table displays the curve's unit (if any) and the description fetched from <code>&lt;PV&gt;.DESC</code>.</li> <li>Refresh: Click \"Refresh Data\" to re-fetch for the current plot range.</li> </ol> <p>DIT with data loaded</p>"},{"location":"tools/data_insight/#exporting-data","title":"Exporting data","text":"<p>Click Export to File to save the displayed dataset. Choose a filename and one of the formats:</p> <ul> <li>CSV (<code>*.csv</code>)</li> <li>MAT (<code>*.mat</code>)</li> <li>JSON (<code>*.json</code>)</li> </ul> <p>Export dialog with format options</p> <p>Export behavior:</p> <ul> <li>The exported file includes metadata: Address, Unit, and Description.</li> <li>Timestamps are written as seconds since epoch in the data section.</li> <li>If there is no data yet (table is empty), the tool will show an error and skip export.</li> </ul>"},{"location":"tools/data_insight/#notes-and-troubleshooting","title":"Notes and troubleshooting","text":"<ul> <li>No curves on plot: Add curves to the main display first; otherwise the PV dropdown will be empty.</li> <li>No archiver URL: If <code>PYDM_ARCHIVER_URL</code> is not set, archived data will not be fetched. Only live samples currently buffered in the plot for the selected PV (within the time range) will be shown.</li> <li>Gaps in data: If the plot time window includes ranges where neither live nor archived data exist, those portions will not produce rows.</li> </ul>"},{"location":"tools/elog_entry/","title":"E-Log Entry Tool","text":""},{"location":"tools/elog_entry/#overview","title":"Overview","text":"<p>The E-Log Entry Tool allows you to create and submit entries to the E-Log system directly from Trace. You can attach a screenshot of your current plot and optionally include your configuration file with the entry.</p>"},{"location":"tools/elog_entry/#prerequisites","title":"Prerequisites","text":"<p>Before using the E-Log Entry Tool, you must set up the following environment variables:</p> <ul> <li><code>SWAPPS_TRACE_ELOG_API_URL</code>: The base URL for the E-Log API</li> <li><code>SWAPPS_TRACE_ELOG_API_KEY</code>: Your API key for authenticating with the E-Log system</li> </ul>"},{"location":"tools/elog_entry/#opening-the-tool","title":"Opening the Tool","text":"<p>The E-Log Entry Tool can be accessed through the Trace menu or with <code>Ctrl+E</code>. When opened, it displays a modal dialog with the following components:</p> <p>E-Log Entry Tool interface</p>"},{"location":"tools/elog_entry/#using-the-tool","title":"Using the Tool","text":""},{"location":"tools/elog_entry/#1-screenshot-of-the-plot","title":"1. Screenshot of the Plot","text":"<ul> <li>A screenshot is taken of the plot on startup and is displayed at the top of the dialog</li> <li>The image is scaled to fit within a 400x300 pixel area</li> <li>This screenshot will be attached to your E-Log entry in PNG format</li> </ul>"},{"location":"tools/elog_entry/#2-title-required","title":"2. Title (Required)","text":"<ul> <li>Enter a descriptive title for your E-Log entry</li> <li>This field is mandatory and must not be empty</li> </ul>"},{"location":"tools/elog_entry/#3-body-optional","title":"3. Body (Optional)","text":"<ul> <li>Provide additional details about your entry in the text area</li> <li>Use this space to describe what you observed, any issues, or relevant context</li> </ul>"},{"location":"tools/elog_entry/#4-logbooks-required","title":"4. Logbooks (Required)","text":"<ul> <li>Select one or more logbooks from the available list<ul> <li>At least one logbook must be selected to submit the entry</li> </ul> </li> <li>You can select multiple logbooks using <code>Ctrl+click</code> or <code>Shift+click</code></li> <li>The selected logbooks are displayed in the \"Selected Logbooks\" field below</li> </ul>"},{"location":"tools/elog_entry/#5-attach-config-optional","title":"5. Attach Config (Optional)","text":"<ul> <li>Check this box if you want to include your current Trace configuration file</li> <li>The configuration file will be attached as an additional file to the entry</li> <li>This is useful for sharing your exact plot settings with others</li> </ul>"},{"location":"tools/elog_entry/#6-submit-the-entry","title":"6. Submit the Entry","text":"<ul> <li>Click Send to submit your entry to the E-Log</li> <li>Click Cancel to close the dialog without saving</li> </ul>"},{"location":"tools/elog_entry/#validation-and-error-handling","title":"Validation and Error Handling","text":"<p>The tool performs several validation checks before allowing submission:</p> <ul> <li>Title validation: If the title field is empty, you'll see a warning: \"Title is required.\"</li> <li>Logbook validation: If no logbooks are selected, you'll see a warning: \"At least one logbook must be selected.\"</li> <li>API connectivity: If the E-Log API is unreachable, you'll see an error dialog with the specific error code</li> </ul>"},{"location":"tools/elog_entry/#what-gets-posted","title":"What Gets Posted","text":"<p>When you submit an entry, the following data is sent to the E-Log API:</p> <ul> <li>Entry metadata: Title, body text, and selected logbooks</li> <li>Plot screenshot: Automatically attached as <code>trace_plot.png</code></li> <li>Configuration file: If \"Attach Config\" is checked, your current <code>.trc</code> configuration file is included</li> </ul>"},{"location":"tools/elog_entry/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tools/elog_entry/#common-issues","title":"Common Issues","text":"<ul> <li>\"Elog Access Error\": This indicates the E-Log API is unreachable or your API credentials are invalid<ul> <li>Verify your <code>SWAPPS_TRACE_ELOG_API_URL</code> and <code>SWAPPS_TRACE_ELOG_API_KEY</code> environment variables</li> <li>Check your network connection to the E-Log server</li> </ul> </li> <li>Empty logbook list: The tool couldn't fetch available logbooks from the API<ul> <li>Ensure your API key has the necessary permissions</li> <li>Check that the E-Log API is running and accessible</li> </ul> </li> </ul>"},{"location":"tools/elog_entry/#environment-setup","title":"Environment Setup","text":"<p>Make sure these environment variables are properly set: <pre><code>export SWAPPS_TRACE_ELOG_API_URL=\"https://your-elog-server.com\"\nexport SWAPPS_TRACE_ELOG_API_KEY=\"your-api-key-here\"\n</code></pre></p>"},{"location":"tools/elog_entry/#technical-details","title":"Technical Details","text":"<ul> <li>The tool uses the E-Log API v2 for posting entries</li> <li>Images are sent as PNG format</li> <li>Configuration files are attached as binary data with <code>application/octet-stream</code> MIME type</li> <li>The API requires authentication via the <code>x-vouch-idp-accesstoken</code> header</li> </ul>"},{"location":"tools/file_converter/","title":"CLI File Converter Tool","text":"<p>Included in this application is a tool for converting files from the Archive Viewer's format or StripTool's format into Trace's format.</p> <p>It is located at <code>trace/file_io/trace_file_converter.py</code> and can be called directly from the command-line. This allows users to convert their files without having to open Trace.</p>"},{"location":"tools/file_converter/#help-message","title":"Help Message","text":"<pre><code>trace/file_io/trace_file_convert.py --help\n&gt;  usage: Trace File Converter [-h] [--output_file [OUTPUT_FILE ...]]\n&gt;                              [--overwrite] [--clean]\n&gt;                              [input_file ...]\n&gt;\n&gt;  Convert files used by the Java Archive Viewer or StripTool to a file format\n&gt;  that can be used with Trace.\n&gt;\n&gt;  positional arguments:\n&gt;    input_file            Path to the file(s) to be converted\n&gt;\n&gt;  options:\n&gt;    -h, --help            show this help message and exit\n&gt;    --output_file [OUTPUT_FILE ...], -o [OUTPUT_FILE ...]\n&gt;                          Path to the output file(s) (defaults to input file\n&gt;                          name); The number of output_files must match the\n&gt;                          number of input_files if any are provided\n&gt;    --overwrite, -w       Overwrite the target file if it exists\n&gt;    --clean               Remove the input file after successful conversion\n</code></pre>"},{"location":"tools/file_converter/#positional-arguments","title":"Positional Arguments","text":""},{"location":"tools/file_converter/#input-file","title":"Input File","text":"<pre><code>trace_file_convert.py examples/xml_conversion.xml\n</code></pre> <pre><code>trace_file_convert.py stp_files/*.stp\n</code></pre> <p>The only positional argument is the file to be converted, labeled <code>input_file</code>. This should be provided as a path to the file, either relative or absolute. Users can also provide multiple files to be converted at once.</p> <p>If any file(s) fail the conversion, individual error messages are provided so that users know which to look at. Some causes of failure are:</p> <ul> <li>The file does not exist</li> <li>The file does not use the <code>.xml</code> or <code>.stp</code> file extension</li> <li>The file is incorrectly formatted</li> </ul>"},{"location":"tools/file_converter/#optional-arguments","title":"Optional Arguments","text":""},{"location":"tools/file_converter/#output-file","title":"Output File","text":"<p><code>-o OUTPUT_FILE</code> or <code>--output_file OUTPUT_FILE</code></p> <pre><code>python trace_file_convert.py xml_conversion.xml -o xml_conversion.trc\n</code></pre> <p>Users can use this argument to pass the name and path the converted file should be saved as. If not provided, the converter defaults to the name of the input file with the <code>.trc</code> file extension.</p> <p>Users don't need to include a file extension for the output file name. The conversion fails if the provided output file name has a file extension and it is not <code>.trc</code>.</p> <p>If converting a batch of files, the user can provide multiple output file names to use.</p>"},{"location":"tools/file_converter/#overwrite","title":"Overwrite","text":"<p><code>-w</code> or <code>--overwrite</code></p> <p>The conversion will fail if a file already exists with the new file name (provided or default). Using the overwrite flag ignores the interrupt, allowing the tool to replace the existing file with the new file.</p> <pre><code>python trace_file_convert.py xml_conversion.xml -o xml_conversion.trc\n\n&gt;  [ERROR] - Failed: xml_conversion.xml --&gt; xml_conversion.trc:\n&gt;    Output file exists but overwrite not enabled: /path/to/xml_conversion.trc\n\npython trace_file_convert.py xml_conversion.xml -o xml_conversion.trc -w\n</code></pre>"},{"location":"tools/file_converter/#clean","title":"Clean","text":"<p><code>--clean</code></p> <p>This flag results in the conversion tool removing the input file after the conversion has been made.</p> <pre><code>python trace_file_convert.py examples/FormulaExample.trc --clean\n</code></pre>"},{"location":"tools/formula_maker/","title":"Formula Maker Tool","text":"<p>The Formula Maker Tool can help users construct [formula traces] for their plot. The tool can be opened by clicking the  button in the top of the configuration section.</p> <p>This tool is for ease of use, as users can also create formula traces by creating a trace that's prefixed with <code>f://</code>.</p>"},{"location":"tools/formula_maker/#variable-list","title":"Variable List","text":"<p>The top of the tool consists of a list of traces on the plot that users can use in their formula. The left column contains a variable name for each curve. To use a variable in the formula it should be surrounded by brackets <code>{}</code>.</p> <p><code>Double-clicking</code> a row will add the variable to the formula.</p>"},{"location":"tools/formula_maker/#calculator-like-section","title":"Calculator-like Section","text":"<p>The bottom part of the tool consists of a text box that users can type a formula in as well as buttons that users can use to build their formula.</p> <p>When the user is finished making their formula, they can either hit <code>Enter</code> or click the button labeled \"Add Formula Curve\".</p> <p>Formulas can include all basic arithmetic and binary operations, as well as <code>mean</code> and all functions in Python's standard math library.</p>"},{"location":"tools/search/","title":"PV Search Tool","text":"<p>The PV Search Tool can help users find PVs easier. The button labeled \"Search PV\" at the top of the configuration section opens a PV search tool.</p>"},{"location":"tools/search/#wildcard-characters","title":"Wildcard Characters","text":"<p>Users can make searches using a number of wildcard characters. All wildcards will represent 1+ characters regardless of the wildcard (equivalent of <code>*.</code> in Regular Expression).</p> <p>For example, the picture above shows a search for <code>KLYS:LI22:*:KVAC</code>. The results include all PVs that have that address with any character in the <code>*</code> position.</p>"},{"location":"tools/search/#selecting-pvs","title":"Selecting PVs","text":"<p>Use <code>Ctrl + Click</code> to toggle separate PVs as selected or not, and <code>Shift + Click</code> will select a range of PVs. <code>Double-Click</code> a PV or click the button labeled \"Add PVs\" to add them to Trace. New traces will be added to the last axis of the configuration section.</p>"}]}