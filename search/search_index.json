{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trace","text":"<p>Trace is a PyDM-based application developed at SLAC National Accelerator Laboratory.</p> <p>The motivation behind trace is as a replacement for the StripTool and Java Archive Viewer applications used to plot EPICS data. It is a flexible, modern application for plotting live data (Channel Access or PV Access), and historical data from the EPICS Archive Appliance.</p> <p>With built in conveniences like an archived PV search, and designed to be easily launched from PyDM widgets, files, or the command line, Trace will provide an improved user experience for accelerator staff.</p> <p>Trace is open-source and in active development, so don't hesitate to request features or report bugs.</p>"},{"location":"arguments/","title":"Input Arguments &amp; Macros","text":"<p>Trace supports several optional startup arguments and macros that allow users to customize its behavior at launch. These arguments let you specify input files, define process variables (PVs) to display, apply macro replacements, and access help or version information.</p> <p>Below, you'll find a detailed overview of each available argument and example usage to help you configure Trace to fit your workflow.</p>"},{"location":"arguments/#config-file","title":"Config File","text":"<p><code>-i INPUT_FILE</code> or <code>--input_file INPUT_FILE</code></p> <p>This argument allows users to import Trace config files, providing a way to recover a previous state of Trace. To make use of it, users should provide a filepath for the config file they want to use. The path can be either relative or absolute.</p> <pre><code>pydm trace/main.py -i trace/examples/FormulaExample.trc\n</code></pre>"},{"location":"arguments/#startup-pvs","title":"Startup PVs","text":"<p><code>-p PV1 PV2 ...</code> or <code>--pvs PV1 PV2 ...</code></p> <p>Users are able to provide a list of PVs to show traces for on startup. Each PV passed here will be represented by a curve on the plot.</p> <pre><code>pydm trace/main.py -p FOO:BAR:CHANNEL SOME:OTHER:CHANNEL\n</code></pre>"},{"location":"arguments/#macros","title":"Macros","text":"<p><code>-m MACRO</code> or <code>--macro MACRO</code></p> <p>Use PyDM's macro substitution system as another way of adding PVs or startup files to Trace. Adding PVs via macros is equivalent to adding them as an argument. This setup allows users to add traces from other PyDM widgets, such as the PyDMRelatedDisplayButton.</p> <pre><code>pydm trace/main.py -m '{\"PVS\": [\"FOO:BAR:CHANNEL\", \"SOME:OTHER:CHANNEL\"]}'\npydm trace/main.py -m \"INPUT_FILE = trace/examples/FormulaExample.trc\"\n</code></pre>"},{"location":"arguments/#help-message","title":"Help Message","text":"<p><code>-h</code> or <code>--help</code></p> <p>Shows Trace's help message, which outlines the available arguments for users.</p>"},{"location":"arguments/#version-number","title":"Version Number","text":"<p><code>-v</code> or <code>--version</code></p> <p>Show Trace's current version/release number.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or newer</li> <li>pip (Python package manager)</li> <li>(Optional) conda for environment management</li> </ul>"},{"location":"installation/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/slaclab/trace.git\n</code></pre>"},{"location":"installation/#create-and-activate-a-virtual-environment-recommended","title":"Create and Activate a Virtual Environment (Recommended)","text":"<p>Using <code>venv</code>: <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\n</code></pre></p> <p>Or using <code>conda</code>: <pre><code>conda env create -f environment.yml\nconda activate trace\n</code></pre></p>"},{"location":"installation/#install-dependencies","title":"Install Dependencies","text":"<p>If using pip: <pre><code>pip install -r requirements.txt\n</code></pre></p> <p>Or with <code>conda</code> (if you created the environment above, dependencies are already installed): <pre><code>conda env update -f environment.yml\n</code></pre></p>"},{"location":"installation/#running-trace","title":"Running Trace","text":"<p>The main startup file for trace is located at <code>trace/main.py</code>.</p> <p>Trace can be launched using PyDM, and users can pass in additional arguments and macros.</p> <pre><code>pydm trace/main.py\n</code></pre>"},{"location":"io/","title":"Import &amp; Export","text":"<p>Trace allows users to export their current configuration of the application into a save file so that it can be imported later. The exported files include the archiver URL used, plot's configuration, the X-axis' time range, all of the Y-axes, and all of the traces.</p> <p>The importing and exporting features can be found in the menu bar at the top of the application under the Action menu. Alternatively, users can export their current configuration with <code>Ctrl+S</code> or import a file with <code>Ctrl+L</code>.</p> <p>Files can also be imported on startup using the <code>-i</code> flag followed by the path to the file. Find more information on application arguments here.</p>"},{"location":"io/#save-files","title":"Save Files","text":"<p>Trace's save files are in JSON format as to be human readable/writeable and they use their own file extension: <code>.trc</code>.</p>"},{"location":"io/#java-save-files","title":"Java Save Files","text":"<p>Save files for the Java-based Archive Viewer can also be imported into Trace. They can be found in the import tool's file selection tool along with Trace's save files. Users can show only Java Archive Viewer files by changing the file format filter at the bottom of the dialog window.</p> <p>Trace will not save new files in the Java-based Archive Viewer's format, only as <code>.trc</code> files.</p> <p>Files can be converted en masse from the Java-based file format to Trace's formate using the CLI file converter tool.</p>"},{"location":"io/#striptool-save-files","title":"StripTool Save Files","text":"<p>Save files for the StripTool can be converted using the same tool or imported directly into Trace. They can be found in the import tool's file selection tool alongside Trace's save files and the Java Archive Viewer's save files. Users can show only StripTool files by changing the file format filter at the bottom of the dialog window.</p> <p>Trace will not save new files in the Java-based Archive Viewer's format, only as <code>.trc</code> files.</p> <p>Files can be converted en masse from the StripTool file format to Trace's formate using the file converter tool.</p>"},{"location":"io/#note-about-colors","title":"Note About Colors","text":"<p>Colors in the save file will typically be represented as RGB values in hexidecimal format. Since the string will be passed into a QColor when loaded, these strings can be names of colors as well e.g. \"red\", \"blue\", \"white\", etc.</p>"},{"location":"overview/","title":"Interface Layout &amp; Sections","text":"<p>Trace is a PyDM application used to plot value data for given PVs. The application is capable of plotting both live and archived data, as well as formulas containing PVs as variables.</p> <p>The application consists of two main parts:</p> <ul> <li>Plot Section on the left</li> <li>Configuration Section on the right</li> <li>Footer at the bottom</li> </ul> <p>Users are able to control the size of these two sections by clicking and dragging the vertical white splitter in the center of the application. The configuration section can be completely collapsed so that the application only shows the plot.</p>"},{"location":"plot_config/","title":"Configuring the Plot","text":"<p>The Plot configuration tab is where users get to customize the look of their plot. Plot configuration will be included in the Trace save files, meaning that the customizations can be imported by the user. Customizing the plot can be useful when taking a screenshot of the plot to share.</p> <p>Below is a brief description of each of the properties that can be customized.</p>"},{"location":"plot_config/#plot-title","title":"Plot Title","text":"<p>Allows the user to set the title of their plot to whatever text they want. By default, the plot has no title.</p>"},{"location":"plot_config/#grid-lines","title":"Grid Lines","text":"<p>Show/hide horizontal and/or vertical grid lines. Both are off by default.</p>"},{"location":"plot_config/#legend","title":"Legend","text":"<p>Show or hide the plot's legend. The legend will show a list of all traces' labels on the plot and their associated color. There is no customization for the legend yet. The legend is hidden by default.</p>"},{"location":"plot_config/#font-size","title":"Font Size","text":"<p>Control the size of the font on the X-Axis. Shrinking the font will show labels for more tick marks, and increasing it will show fewer. The size can be set within the range [1, 99], and defaults to 12.</p>"},{"location":"plot_config/#autoscroll-refresh-rate","title":"Autoscroll Refresh Rate","text":"<p>Controls how long the autoscroll feature will wait before shifting the plot's timerange to the right. Default is 5 seconds.</p>"},{"location":"plot_config/#background-color","title":"Background Color","text":"<p>Allows the user to set the plot's background color. Default is white.</p>"},{"location":"plot_config/#mouse-mode","title":"Mouse Mode","text":"<p>Users can choose to change the plot's mouse mode when clicking and dragging. The options are Rect (default) or Pan. Rect draws a rectangle between where the mouse is pressed and released, and zooms to show that rectangle. Pan will pan the X and Y axes whichever way the user moves the mouse.</p>"},{"location":"plot_config/#opacity","title":"Opacity","text":"<p>Controls the opacity of the plot's grid lines. Defaults to about 50%.</p>"},{"location":"plot_config/#crosshair","title":"Crosshair","text":"<p>Shows a yellow crosshair where the user is mousing over the plot. Disabled by default.</p>"},{"location":"traces/","title":"Traces","text":"<p>Traces, sometimes called curves, are the lines that are shown on the application's plot. They show both live and archive data for the given channel.</p> <p>The properties of each trace can be controlled by the user through interaction with the configuration section of the application.</p>"},{"location":"traces/#adding-traces","title":"Adding Traces","text":"<p>Users can add traces to the plot by adding them to the configuration section. This can be done by entering a channel into the text box at the top of the section and hitting <code>Enter</code> or clicking the button labeled \"Plot\". Once a channel is added, the trace will be added to the plot and both live and archived data will be shown. Traces can also be added using the PV Search tool.</p> <p>When adding new traces, they will be attached to the last y-axis in the configuration section. If no axes exist, a new one will be created for the new trace.</p>"},{"location":"traces/#planned-for-future-development","title":"Planned for Future Development","text":"<p>When adding new traces, they will be attached to a y-axis with the same unit. If no such axis exists, a new one will be created for the channel's unit. If the channel has no units, a new axis will be created with no associated units.</p>"},{"location":"traces/#hiding-traces","title":"Hiding Traces","text":"<p>Users can hide or show individual traces on the plot without removing them. This can be done by unchecking the box labeled \"Active\".</p>"},{"location":"traces/#removing-traces","title":"Removing Traces","text":"<p>Users can remove traces from the plot by clicking the  button for the associated trace. This will remove the row from the configuration section and remove the trace from the plot at the same time.</p>"},{"location":"traces/#moving-traces","title":"Moving Traces","text":"<p>When a trace is created it is attached to the last Y-axis in the configuration section, as mentioned above in Adding Traces. If users want to move a trace to a different Y-axis, they can click and hold the handle marked with a  symbol.</p>"},{"location":"traces/#formula-traces","title":"Formula Traces","text":"<p>Users can add formulas to the plot by entering their formula to be calculated as the trace's channel. The formula should be prepended with <code>f://</code> to signify that the channel is a formula. Formulas can also be added using the formula input tool by clicking the  button.</p> <p>Other traces the formula uses are represented by their unique variable name in a set of curly brackets, e.g. <code>{x1}</code>, <code>{x4}</code>, <code>{fx3}</code>. Formulas can include all basic arithmetic and binary operations, as well as <code>mean</code> and all functions in Python's standard math library.</p> <p>As an example, if we have 2 PVs with the variable names <code>x1</code> and <code>x2</code>, then we may have the formulas:</p> <ul> <li><code>f://{x1} + {x2}</code></li> <li><code>f://min({x1}, {x2})</code></li> <li><code>f://{x1} ^ {x2}</code></li> </ul>"},{"location":"traces/#trace-settings","title":"Trace Settings","text":"<p>Users can change a trace's settings by clicking the associated  button on the right side of the configuration section. This will open a pop-up window that allows for a lot of customization of individual traces.</p>"},{"location":"traces/#curve-name","title":"Curve Name","text":"<p>This setting lets users change the name of the on the plot's legend. The default value is the trace's channel or formula.</p>"},{"location":"traces/#color","title":"Color","text":"<p>The color the curve should show up as on the plot &amp; legend. Sets the color for both the trace and its symbols.</p> <p>Clicking this button will open the default PyQT color selector dialog window. Once the color has been changed, right clicking the button will set it back to its initial color.</p>"},{"location":"traces/#optimized-bin-count","title":"Optimized Bin Count","text":"<p>This setting allows users to set the resolution of historical data gathered from the archiver appliance. This only applies when the user requests around 5 hours or more worth of archive data. The default value is 5000 data points.</p>"},{"location":"traces/#live-data-archive-data","title":"Live Data &amp; Archive Data","text":"<p>The user can determine what kind of data should be fetched. Live data will be added to the trace on the channel's value change. If Live data fetching is disabled and then later reenabled, then archiver data will be fetched to backfill the missing section. By default, both Live data and Archive data fetching are enabled.</p>"},{"location":"traces/#line-type","title":"Line Type","text":"<p>A dropdown menu containing 2 options: Direct and Step. The Direct option draws sloped lines directly between points on the plot. The Step option draws the trace as horizontal lines to the right of their points and continue until a new point on the plot.</p>"},{"location":"traces/#line-style-line-width","title":"Line Style &amp; Line Width","text":"<p>Controls the style and size of the trace on the plot. The styles include no line, solid (-----), dash (- - -), dot (...), dash dot (-.-.-), and dash dot dot (-..-..).</p> <p>The widths are limited to 1px - 5px, with 1px being the default.</p>"},{"location":"traces/#line-extension","title":"Line Extension","text":"<p>Checking this box will result in a line being drawn from the last point into the future. This can be used if a curve doesn't have as recent an archived point as the other, then this line will could be used to show the last value of the curve in the past.</p>"},{"location":"traces/#symbol-symbol-size","title":"Symbol &amp; Symbol Size","text":"<p>Controls what symbols should be shown at each point on the trace.</p> <p>By default no symbols are shown, but users have many shapes they can choose from including circles, triangles, squares, etc. Users can also choose the size of the symbol at 5px, 10px, 15px, or 20px with 10px being the default.</p>"},{"location":"y_axes/","title":"Y-Axes","text":"<p>Users are able to manage the axes on their plot in the configuration section. From adding/removing axes, hiding axes, or changing an axis' properties, users have plenty of control over the Y-Axes of their plot.</p>"},{"location":"y_axes/#adding-axes","title":"Adding Axes","text":"<p>Users can create new Y-axes to organize traces by clicking the button labeled \"New Axis\" at the bottom of the configuration section. The new axis won't have any associated traces on creation, but the can be added and configured.</p>"},{"location":"y_axes/#renaming-axes","title":"Renaming Axes","text":"<p>By default, new Y-axes are names \"Y-Axis &lt;#&gt;\" where <code>&lt;#&gt;</code> is an incrementing number. Users are able to rename an axis by editing the text in the associate text box.</p>"},{"location":"y_axes/#deleting-axes","title":"Deleting Axes","text":"<p>Users can remove axes by clicking the  button for the given axis on the right side of the section. Deleting an axis will remove the axis from both the table and the plot, as well as all of the traces attached to that axis.</p>"},{"location":"y_axes/#hiding-axes","title":"Hiding Axes","text":"<p>Users have the option to hide/show Y-axes on the plot using the checkbox labeled \"Active\" on the right side of the section. Hiding a Y-axis will hide all traces attached to it as well.</p>"},{"location":"y_axes/#axis-settings","title":"Axis Settings","text":"<p>Users can change an axis' vertical range and settings on an axis-by-axis basis.</p> <p>Some of an axis' settings can be configured by clicking the associated  button on the right side of the section. This will open a pop-up window that allows for a lot of customization of the axis. It looks like this.</p>"},{"location":"y_axes/#vertical-range","title":"Vertical Range","text":"<p>An axis' range can be changed in a few different ways. By default, an axis will automatically scale its range to show all data for its traces. This feature can be enabled/disabled using the checkbox labeled \"Auto\". It will also be automatically disabled if the user changes the range manually in one of the following ways.</p> <p>Another, more common way for users to change the range is by scrolling/dragging on the plot. This can be done on individual axes or on all axes at once. See Mouse Controls for more details.</p> <p>Finally, users also have the option to set the range manually by altering the values in the text boxes labeled <code>min, max</code> in the configuration section. This will result in the Y-axis being locked at that range, even if trace data isn't in that range.</p>"},{"location":"y_axes/#orientation","title":"Orientation","text":"<p>Sets if the axis is displayed on the left or right side of the plot. This doesn't affect the data or the plot and is purely a cosmetic change.</p>"},{"location":"y_axes/#log-mode","title":"Log Mode","text":"<p>Sets if the axis is on a linear scale or a logarithmic scale.</p>"},{"location":"y_axes/#y-axis-gridline","title":"Y-Axis Gridline","text":"<p>Sets if gridlines are shown on the plot. These will be horizontal lines at all major ticks on the Y-axis.</p> <p>Gridlines can be enabled/disabled individually here, or enabled/disabled for all axes in the plot settings pop-up.</p>"},{"location":"overview/config_section/","title":"Configuration Section","text":"<p>The configuration section is where users are able to add axes and traces to the plot as well as configure their appearances.</p>"},{"location":"overview/config_section/#adding-traces","title":"Adding Traces","text":"<p>To add traces to the plot, users can type a PV address into the line edit at the top of the section and hit enter or click the \"Plot\" button. This will create a trace for the PV and add it to the Y-axis listed last in the configuration section.</p> <p>Users are able to search for PV(s) by clicking the button labeled \"Search PVs\" to open the Archive Search Tool. More information on the tool can be found here.</p> <p>Users are also able to add formula traces by using the Formula Maker Tool. The tool can be opened by clicking the  button in the top of this section.</p>"},{"location":"overview/config_section/#adding-axes","title":"Adding Axes","text":"<p>Users are also able to create new Y-axes using the large button at the bottom of the section labeled \"New Axis\". Clicking this will add a new axis to both the plot and the configuration section.</p>"},{"location":"overview/config_section/#hiding-axes-traces","title":"Hiding Axes &amp; Traces","text":"<p>Users are able to hide traces or axes on the plot without deleting them from the application. This could be useful if users want to visualize the plot without individual traces, or if there is a lot of clutter.</p>"},{"location":"overview/config_section/#from-the-section","title":"From the Section","text":"<p>Axes and all of their curves can be collapsed in the configuration section by clicking the  next to them on the left side of the section. All of the traces will still appear on the plot.</p>"},{"location":"overview/config_section/#from-the-plot","title":"From the Plot","text":"<p>Both axes and individual traces can be shown/hidden from the plot by toggling the checkboxes labeled \"Active\".</p>"},{"location":"overview/footer/","title":"Footer","text":"<p>At the very bottom of the screen is a footer containing some information that may be useful to users.</p> <p>The left side of the footer displays some information about the application itself. Here is what the footer displays, listed from left to right: - Server that Trace is running on - Archiver URL used by PyDM to fetch archiver data - Imported config file (if a file was imported/exported; more information here)</p> <p>The current date and time is displayed on the right side of the footer. This can be useful if users take a screenshot to share around.</p>"},{"location":"overview/plot_section/","title":"Plot Section &amp; Mouse Interaction","text":"<p>The plot section is primarily for viewing the plot, but also has some control over the plot's settings. It displays whatever traces, axes, or other properties the user sets.</p>"},{"location":"overview/plot_section/#mouse-controls","title":"Mouse Controls","text":"<p>The plot's axes can be controlled using the mouse. Users can scroll up to zoom in, or scroll down to zoom out. If this is done over a single axis, then just the one axis is affected. However, if the user scrolls in the plotting area, then the X-Axis and all Y-Axes will zoom in the corresponding direction.</p> <p>Users are able to pan along a single axis by clicking and dragging it. This works on both X and Y-Axes. Clicking and dragging in the plotting area has a different functionality. A box will be drawn between where the mouse button was pressed and where it was released, and then the plot will zoom in to show the selected range.</p>"},{"location":"overview/plot_section/#time-span-buttons","title":"Time Span Buttons","text":"<p>Above the plotting section are a few buttons for quickly toggling between common time spans (30s, 1m, 1h, 1w, 1M). Clicking these will cause the plot to consistently update to show that time range. For instance, toggling the 1h button will result in the last hour of data being shown, and every 5 seconds the plot will shift to the right to update.</p>"},{"location":"overview/plot_section/#plot-settings","title":"Plot Settings","text":"<p>Users can change the settings of the plot using the settings button in the top left corner of the plot marked with a  icon. Clicking this button opens a pop-up window with controls over the plot's configuration such as background color, time-range, show gridlines, etc.</p>"},{"location":"reference/","title":"Developer Reference","text":"<p>Welcome to the Trace Developer Reference. This section provides comprehensive documentation for the internal Python modules, classes, and functions that make up the Trace application. Here you will find detailed descriptions of each component, including their parameters, return values, and usage examples.</p> <p>Use this reference to:</p> <ul> <li>Understand the structure and functionality of Trace\u2019s codebase</li> <li>Integrate or extend Trace with your own scripts or plugins</li> <li>Explore available widgets, file I/O utilities, and service modules</li> </ul> <p>Browse the subpages for specific modules and components. For guidance on using the application, see the user documentation in the main sections.</p>"},{"location":"reference/trace/","title":"Main","text":""},{"location":"reference/trace/#main.TraceDisplay","title":"<code>TraceDisplay</code>","text":"<p>               Bases: <code>Display</code></p> Source code in <code>trace/main.py</code> <pre><code>class TraceDisplay(Display):\n    gridline_opacity_change = Signal(int)\n    set_all_y_axis_gridlines = Signal(bool)\n\n    def __init__(self, parent=None, args=None, macros=None) -&gt; None:\n        super(TraceDisplay, self).__init__(parent=parent, args=args, macros=macros, ui_filename=None)\n        self.build_ui()\n        self.configure_app()\n        self.resize(1000, 600)\n\n        # Set plot's timerange after the UI is built\n        default_button = self.timespan_buttons.button(3600)\n        default_button.setChecked(True)\n\n        input_file, startup_pvs = self.parse_cli_args(args, macros)\n        if input_file:\n            self.file_handler.open_file(input_file)\n        for pv in startup_pvs:\n            self.layout().itemAt(0).widget().widget(1).add_curve(pv)\n\n    @property\n    def gridline_opacity(self) -&gt; int:\n        \"\"\"Get the current gridline opacity value from the plot settings\"\"\"\n        return self.plot_settings.gridline_opacity\n\n    def minimumSizeHint(self):\n        return QSize(700, 350)\n\n    def build_ui(self) -&gt; None:\n        # Set window title\n        self.setWindowTitle(\"Trace\")\n        # Create main layout\n        main_layout = QVBoxLayout()\n        self.setLayout(main_layout)\n\n        # Create the plotting and control widgets\n        plot_side_widget = self.build_plot_side(self)\n        self.control_panel = ControlPanel()\n        self.control_panel.layout().setContentsMargins(8, 0, 0, 0)\n        self.control_panel.plot = self.plot\n        self.control_panel.curve_list_changed.connect(self.data_insight_tool.update_pv_select_box)\n\n        # Create main splitter\n        main_splitter = QSplitter(self)\n        main_splitter.addWidget(plot_side_widget)\n        main_splitter.addWidget(self.control_panel)\n        main_splitter.setCollapsible(0, False)\n        main_splitter.setStretchFactor(0, 1)\n        main_splitter.setHandleWidth(10)\n        main_splitter.setStyleSheet(\n            \"\\n\".join(\n                [\n                    \"QSplitter::handle {\",\n                    \"  background-color: white;\",\n                    \"}\",\n                ]\n            )\n        )\n        main_layout.addWidget(main_splitter)\n\n        # Create the footer section of the app\n        footer_widget = self.build_footer(self)\n        main_layout.addWidget(footer_widget)\n\n    def build_plot_side(self, parent):\n        plot_side_widget = QWidget(parent)\n        plot_side_layout = QVBoxLayout()\n        plot_side_layout.setContentsMargins(0, 0, 8, 0)\n        plot_side_widget.setLayout(plot_side_layout)\n\n        toolbar = self.build_toolbar(plot_side_widget)\n        plot_side_layout.addWidget(toolbar)\n\n        # Create plot\n        self.plot = PyDMArchiverTimePlot(\n            plot_side_widget,\n            background=\"white\",\n            optimized_data_bins=5000,\n            cache_data=False,\n            show_all=False,\n        )\n\n        multi_axis_plot = self.plot.plotItem\n        multi_axis_plot.vb.menu = None\n        multi_axis_plot.sigXRangeChangedManually.connect(self.disable_auto_scroll_button.click)\n        plot_side_layout.addWidget(self.plot)\n\n        self.data_insight_tool = DataInsightTool(self)\n        self.data_insight_tool.plot = self.plot\n\n        self.settings_button = QPushButton(self.plot)\n        self.settings_button.setIcon(qta.icon(\"msc.settings-gear\"))\n        self.settings_button.setFlat(True)\n\n        self.plot_settings = PlotSettingsModal(self.settings_button, self.plot)\n        self.plot_settings.auto_scroll_interval_change.connect(self.set_auto_scroll_interval)\n        self.plot_settings.grid_alpha_change.connect(self.gridline_opacity_change.emit)\n        self.plot_settings.set_all_y_axis_gridlines.connect(self.plot.setShowYGrid)\n        self.plot_settings.set_all_y_axis_gridlines.connect(self.set_all_y_axis_gridlines.emit)\n        self.plot_settings.disable_autoscroll.connect(self.disable_auto_scroll_button.click)\n        self.settings_button.clicked.connect(self.plot_settings.show)\n\n        return plot_side_widget\n\n    def build_toolbar(self, parent):\n        toolbar_widget = QWidget(parent)\n        # Create tool layout\n        tool_layout = QHBoxLayout()\n        tool_layout.setContentsMargins(0, 0, 0, 0)\n        toolbar_widget.setLayout(tool_layout)\n\n        tool_spacer = QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)\n        tool_layout.addSpacerItem(tool_spacer)\n\n        timespan_buttons = self.build_timespan_buttons(toolbar_widget)\n        tool_layout.addWidget(timespan_buttons)\n\n        return toolbar_widget\n\n    def build_timespan_buttons(self, parent: QWidget):\n        timespan_button_widget = QWidget(parent)\n        timespan_button_layout = QHBoxLayout()\n        timespan_button_layout.setContentsMargins(0, 0, 0, 0)\n        timespan_button_widget.setLayout(timespan_button_layout)\n\n        self.timespan_buttons = QButtonGroup(timespan_button_widget)\n        self.timespan_buttons.setExclusive(True)\n\n        timespan_button_data = (\n            (\"1m\", 60),\n            (\"1h\", 3600),\n            (\"1d\", 86400),\n            (\"1w\", 604800),\n            (\"1M\", 2628300),\n            (\"Disable AutoScroll\", DISABLE_AUTO_SCROLL),\n        )\n\n        for text, id in timespan_button_data:\n            timespan_button = QPushButton(text, timespan_button_widget)\n            timespan_button.setMaximumWidth(35)\n            timespan_button.setCheckable(True)\n            timespan_button_layout.addWidget(timespan_button)\n            self.timespan_buttons.addButton(timespan_button, id)\n\n        self.disable_auto_scroll_button = self.timespan_buttons.button(DISABLE_AUTO_SCROLL)\n        self.disable_auto_scroll_button.hide()\n\n        self.timespan_buttons.buttonToggled.connect(self.set_auto_scroll_span)\n\n        return timespan_button_widget\n\n    def build_footer(self, parent: QWidget):\n        self.footer_label_font = QFont()\n        self.footer_label_font.setPointSize(8)\n\n        footer_widget = QWidget(parent)\n        footer_widget.setFixedHeight(12)\n        footer_layout = QHBoxLayout()\n        footer_layout.setContentsMargins(0, 0, 0, 0)\n        footer_widget.setLayout(footer_layout)\n\n        # Left side of footer, with various info labels\n        self.footer_info_widget = QWidget(footer_widget)\n        footer_layout.addWidget(self.footer_info_widget)\n        footer_info_layout = QHBoxLayout(self.footer_info_widget)\n        footer_info_layout.setContentsMargins(0, 0, 0, 0)\n\n        footer_label_data = (\n            (gethostname(), \"Node Name\"),\n            (os.getenv(\"PYDM_ARCHIVER_URL\"), \"Archiver URL\"),\n        )\n\n        for text, tooltip in footer_label_data:\n            label = QLabel(text, self.footer_info_widget)\n            label.setFont(self.footer_label_font)\n            label.setToolTip(tooltip)\n            label.setAlignment(Qt.AlignBottom)\n            footer_info_layout.addWidget(label)\n            footer_info_layout.addWidget(BreakerLabel(self.footer_info_widget))\n\n        last_breaker = self.footer_info_widget.children()[-1]\n        footer_info_layout.removeWidget(last_breaker)\n\n        footer_spacer = QSpacerItem(40, 12, QSizePolicy.Expanding, QSizePolicy.Minimum)\n        footer_layout.addSpacerItem(footer_spacer)\n\n        self.time_label = PyDMLabel(footer_widget, f\"ca://{datetime_pv}\")\n        self.time_label.setAlignment(Qt.AlignBottom)\n        footer_layout.addWidget(self.time_label)\n\n        return footer_widget\n\n    def set_file_indicator(self, file_path: str) -&gt; None:\n        \"\"\"Set the file indicator label to the given file path.\"\"\"\n        if not file_path:\n            return\n        filename = os.path.basename(file_path)\n        if hasattr(self, \"file_label\") and self.file_label is not None:\n            self.file_label.setText(filename)\n        else:\n            self.footer_info_widget.layout().addWidget(BreakerLabel(self.footer_info_widget))\n            self.file_label = QLabel(filename, self.footer_info_widget)\n            self.file_label.setFont(self.footer_label_font)\n            self.file_label.setToolTip(\"Currently loaded file\")\n            self.footer_info_widget.layout().addWidget(self.file_label)\n\n    def configure_app(self):\n        \"\"\"UI changes to be made to the PyDMApplication\"\"\"\n        app = QApplication.instance()\n        if not app.main_window:\n            return\n\n        # Hide navigation bar by default (can be shown in menu bar)\n        app.main_window.toggle_nav_bar(False)\n        app.main_window.ui.actionShow_Navigation_Bar.setChecked(False)\n\n        # Hide status bar by default (can be shown in menu bar)\n        app.main_window.toggle_status_bar(False)\n        app.main_window.ui.actionShow_Status_Bar.setChecked(False)\n\n        # Create a TraceFileController instance for handling file I/O operations\n        self.file_handler = TraceFileHandler(self.plot, self)\n        self.file_handler.axes_signal.connect(self.control_panel.set_axes)\n        self.file_handler.curves_signal.connect(self.control_panel.set_curves)\n        self.file_handler.plot_settings_signal.connect(self.plot_settings.plot_setup)\n        self.file_handler.auto_scroll_span_signal.connect(self.set_auto_scroll_span)\n        self.file_handler.timerange_signal.connect(self.set_plot_timerange)\n        self.file_handler.file_loaded_signal.connect(self.set_file_indicator)\n\n        # Remove shortcut from the \"Open File\" menu action\n        open_file_action = app.main_window.ui.actionOpen_File\n        open_file_action.setText(\"Open PyDM File...\")\n        open_file_action.setShortcut(QKeySequence())\n\n        # Create a custom menu for the application\n        menu_bar: QMenuBar = app.main_window.ui.menubar\n        first_menu = app.main_window.ui.menuFile.menuAction()\n        trace_menu = self.construct_trace_menu(menu_bar)\n        menu_bar.insertMenu(first_menu, trace_menu)\n\n    def construct_trace_menu(self, parent: QMenuBar) -&gt; QMenu:\n        \"\"\"Create the menu for the application.\"\"\"\n        menu = QMenu(\"Trace\", parent)\n        save = menu.addAction(\"Save\", self.file_handler.save_file)\n        save.setShortcut(QKeySequence(\"Ctrl+S\"))\n        save_as = menu.addAction(\"Save As...\", self.file_handler.save_as)\n        save_as.setShortcut(QKeySequence(\"Ctrl+Shift+S\"))\n        load = menu.addAction(\"Open Trace Config...\", self.file_handler.open_file)\n        load.setShortcut(QKeySequence(\"Ctrl+O\"))\n        menu.addSeparator()\n\n        save_image = menu.addAction(\"Save Plot Image...\", self.save_plot_image)\n        save_image.setShortcut(QKeySequence(\"Ctrl+I\"))\n        save_elog = menu.addAction(\"Save ELOG Entry...\", self.elog_button_clicked)\n        save_elog.setShortcut(QKeySequence(\"Ctrl+E\"))\n        menu.addSeparator()\n\n        fetch_archive = menu.addAction(\"Fetch Archive Data\", self.fetch_archive)\n        fetch_archive.setShortcut(QKeySequence(\"Ctrl+F\"))\n        dit_action = menu.addAction(\"Data Insight Tool...\", self.data_insight_tool.show)\n        dit_action.setShortcut(QKeySequence(\"Ctrl+D\"))\n\n        return menu\n\n    @Slot()\n    def save_plot_image(self) -&gt; None:\n        \"\"\"Saves current plot as an image. Opens file dialog to allow user to\n        set custom location.\"\"\"\n        exporter = ImageExporter(self.plot.plotItem)\n        default_filename = datetime.now().strftime(f\"{getuser()}_trace_%Y%m%d_%H%M%S.png\")\n        usr_home_dir = os.path.expanduser(\"~\")\n        file_path, _ = QFileDialog.getSaveFileName(\n            None,\n            \"Save Plot Image\",\n            os.path.join(usr_home_dir, default_filename),\n            \"PNG Files (*.png);;JPEG Files (*.jpg);;All Files (*)\",\n        )\n        if file_path:\n            try:\n                exporter.export(file_path)\n                logger.info(f\"Saved image file to: {file_path}\")\n            except Exception as e:\n                logger.error(f\"Failed to save image: {e}\")\n\n    @Slot()\n    def elog_button_clicked(self) -&gt; bool:\n        \"\"\"Takes a snapshot of the plot and posts it to the Elog API.\n\n        :return: True if the post was successful, False otherwise.\"\"\"\n        # Test if API is reachable\n        status_code, _ = get_user()\n        if status_code != 200:\n            error_dialog = QMessageBox()\n            error_dialog.setIcon(QMessageBox.Warning)\n            error_dialog.setWindowTitle(\"Connection Error\")\n            error_dialog.setText(\"Failed to connect to the Elog API.\")\n            error_dialog.setInformativeText(\n                f\"\"\"No entry was posted. If this issue persists, please report it in the\n                #elog-general Slack channel. \\n\\nError Code: {status_code}\"\"\"\n            )\n            error_dialog.setStandardButtons(QMessageBox.Ok)\n            error_dialog.exec_()\n            return False\n\n        # Form the request info\n        # Use ImageExporter to take a snapshot of the plot\n        exporter = ImageExporter(self.plot.plotItem)\n        img: QImage = exporter.export(toBytes=True)\n        # Convert Qimage to bytes\n        buffer = QBuffer()\n        buffer.open(QIODevice.ReadWrite)\n        img.save(buffer, \"PNG\")\n        image_bytes = buffer.data()\n        # Get entry info from user\n        dialog = ElogPostModal.maybe_create(self, image_bytes=image_bytes)\n        if dialog is not None and dialog.exec_() == QDialog.Accepted:\n            title, body, logbooks, attach_config = dialog.get_inputs()\n        else:\n            return False\n\n        config_file_path = None\n        if attach_config:\n            self.file_handler.save_file()\n            config_file_path = self.file_handler.current_file\n\n        # Post the request to the Elog API\n        status_code, _ = post_entry(title, body, logbooks, image_bytes, config_file_path)\n\n        # Check if the request was successful\n        if status_code == 201:\n            success_dialog = QMessageBox()\n            success_dialog.setIcon(QMessageBox.Information)\n            success_dialog.setWindowTitle(\"Elog Entry Posted\")\n            success_dialog.setText(\"Elog entry posted successfully!\")\n            success_dialog.setStandardButtons(QMessageBox.Ok)\n            success_dialog.exec_()\n            return True\n        else:\n            error_dialog = QMessageBox()\n            error_dialog.setIcon(QMessageBox.Warning)\n            error_dialog.setWindowTitle(\"Connection Error\")\n            error_dialog.setText(\"Failed to connect to the Elog API.\")\n            error_dialog.setInformativeText(\n                f\"No entry was posted. If this issue persists, please report it in the \\\n                #elog-general Slack channel. \\n\\nError Code: {status_code}\"\n            )\n            error_dialog.setStandardButtons(QMessageBox.Ok)\n            error_dialog.exec_()\n            return False\n\n    @Slot()\n    def fetch_archive(self) -&gt; None:\n        \"\"\"Triggers a fetch to the archive\"\"\"\n        if not (self.plot._archive_request_queued):\n            logger.info(\"Requesting data from archiver\")\n            self.plot.requestDataFromArchiver()\n        else:\n            logger.info(\"Archive fetch is already queued\")\n\n    @Slot(tuple)\n    def set_plot_timerange(self, timerange: tuple[float, float]) -&gt; None:\n        \"\"\"Set the plot's timerange to the given start and end datetimes.\"\"\"\n        self.disable_auto_scroll_button.click()\n        self.plot.setXRange(*timerange)\n        logger.debug(f\"Plot timerange set to {timerange[0]} - {timerange[1]}\")\n\n    @Slot()\n    @Slot(float)\n    def set_auto_scroll_span(self, timespan: float = None) -&gt; None:\n        \"\"\"Slot to be called when a timespan setting button is pressed.\n        This will enable autoscrolling along the x-axis and disable mouse\n        controls. If the \"Cursor\" button is pressed, then autoscrolling is\n        disabled and mouse controls are enabled.\n        \"\"\"\n        if timespan is None:\n            timespan = self.timespan_buttons.checkedId()\n            enable_scroll = timespan != DISABLE_AUTO_SCROLL\n        else:\n            enable_scroll = True\n            self.disable_auto_scroll_button.click()\n\n        if enable_scroll:\n            logger.debug(f\"Enabling plot autoscroll for {timespan}s\")\n        else:\n            logger.debug(\"Disabling plot autoscroll, using mouse controls\")\n        self.autoScroll(enable=enable_scroll, timespan=timespan)\n\n    @Slot(int)\n    def set_auto_scroll_interval(self, inteval: int) -&gt; None:\n        \"\"\"Set the auto scroll interval for the plot\"\"\"\n        timespan = self.timespan_buttons.checkedId()\n        enable_scroll = timespan != DISABLE_AUTO_SCROLL\n\n        self.plot.setAutoScroll(enable_scroll, timespan, refresh_rate=inteval)\n\n    @Slot(bool)\n    @Slot(bool, float)\n    def autoScroll(self, enable: bool, timespan: float = None):\n        if timespan is None:\n            timespan = self.timespan_buttons.checkedId()\n            if timespan &lt; 0:\n                return\n\n        refresh_interval = self.plot_settings.auto_scroll_interval\n        self.plot.setAutoScroll(enable, timespan, refresh_rate=refresh_interval)\n\n    @staticmethod\n    def git_version():\n        \"\"\"Get the current git tag for the project\"\"\"\n        project_directory = __file__.rsplit(\"/\", 1)[0]\n        git_cmd = subprocess.run(\n            f\"cd {project_directory} &amp;&amp; git describe --tags\", text=True, shell=True, capture_output=True\n        )\n        return git_cmd.stdout.strip()\n\n    def parse_cli_args(self, args, macros):\n        \"\"\"\"\"\"\n        args = args or []\n        macros = macros or {}\n\n        parser = argparse.ArgumentParser(\n            prog=\"trace\",\n            description=\"Trace\\nThis is a PyDM application used to display archived and live pv data.\",\n            epilog=\"\\n\\t\".join(\n                [\n                    \"Examples:\",\n                    \"pydm $PHYSICS_TOP/trace/main.py\"\n                    \"bash $PHYSICS_TOP/trace/launch_trace.bash\"\n                    \"%(prog)s\"\n                    \"%(prog)s -i some_input_file.trc\"\n                    \"%(prog)s -p SOME:PV:TO:PLOT OTHER:PV:TO:PLOT\"\n                    '%(prog)s -m \\'{\"PVS\": [\"FOO:CHANNEL\", \"BAR:CHANNEL\", \"f://{A}+{B}\"]}\\''\n                    '%(prog)s -m \"INPUT_FILE = trace/examples/FormulaExample.trc\"',\n                ]\n            ),\n            formatter_class=argparse.RawTextHelpFormatter,\n        )\n\n        parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s \" + self.git_version())\n        parser.add_argument(\n            \"-i\",\n            \"--input_file\",\n            action=PathAction,\n            nargs=\"?\",\n            default=[],\n            help=\"Absolute file path to import from\\nAlternatively can be provided as INPUT_FILE macro\",\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--pvs\",\n            nargs=\"*\",\n            default=[],\n            help=\"\\n\".join(\n                [\n                    \"Space-separated list of PVs to show on startup\",\n                    \"Formulas should be passed without spaces: f://{A}+{B}\",\n                    \"Alternatively can be provided as PV or PVS macros\",\n                ]\n            ),\n        )\n        parser.add_argument(\n            \"-m\",\n            \"--macro\",\n            default=\"\",\n            help=\"\\n\\t\".join(\n                [\n                    \"Mimic PyDM macro replacements to use. Should be in JSON object format.\",\n                    \"ON Formatting Reminder:\",\n                    \"JSON requires double quotes for strings, so you should wrap this\",\n                    \"whole argument in single quotes.\",\n                    \"--or--\",\n                    \"Specify macro replacements as KEY=value pairs using a comma as a\",\n                    \"delimiter. If you want to uses spaces after the delimiters or around\",\n                    \"the '=' signs, wrap the entire set with quotes.\",\n                ]\n            ),\n        )\n\n        # Parse arguments and ignore unknowns\n        known, unknown = parser.parse_known_args(args)\n        for arg in unknown:\n            if arg:\n                logger.warning(f\"Not using unknown argument: {arg}\")\n\n        # Parse any macros passed into trace\n        if known.macro:\n            parsed_macros = parse_macro_string(known.macro)\n            macros.update(**parsed_macros)\n\n        # Get the file to import from if one is provided. Prioritize args over macro\n        try:\n            # Need to unpack as PathAction returns a list\n            input_file = known.input_file[0]\n        except IndexError:\n            input_file = macros.get(\"INPUT_FILE\", \"\")\n\n        # Get the list of PVs to show on startup\n        startup_pvs = []\n        for key in (\"PV\", \"PVS\"):\n            if key in macros:\n                val = macros[key]\n                if isinstance(val, str):\n                    startup_pvs.append(val)\n                elif isinstance(val, list):\n                    startup_pvs.extend(val)\n        startup_pvs += known.pvs\n\n        # Remove duplicates from startup_pvs\n        startup_pvs = list(dict.fromkeys(startup_pvs))\n\n        return (input_file, startup_pvs)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.gridline_opacity","title":"<code>gridline_opacity</code>  <code>property</code>","text":"<p>Get the current gridline opacity value from the plot settings</p>"},{"location":"reference/trace/#main.TraceDisplay.configure_app","title":"<code>configure_app()</code>","text":"<p>UI changes to be made to the PyDMApplication</p> Source code in <code>trace/main.py</code> <pre><code>def configure_app(self):\n    \"\"\"UI changes to be made to the PyDMApplication\"\"\"\n    app = QApplication.instance()\n    if not app.main_window:\n        return\n\n    # Hide navigation bar by default (can be shown in menu bar)\n    app.main_window.toggle_nav_bar(False)\n    app.main_window.ui.actionShow_Navigation_Bar.setChecked(False)\n\n    # Hide status bar by default (can be shown in menu bar)\n    app.main_window.toggle_status_bar(False)\n    app.main_window.ui.actionShow_Status_Bar.setChecked(False)\n\n    # Create a TraceFileController instance for handling file I/O operations\n    self.file_handler = TraceFileHandler(self.plot, self)\n    self.file_handler.axes_signal.connect(self.control_panel.set_axes)\n    self.file_handler.curves_signal.connect(self.control_panel.set_curves)\n    self.file_handler.plot_settings_signal.connect(self.plot_settings.plot_setup)\n    self.file_handler.auto_scroll_span_signal.connect(self.set_auto_scroll_span)\n    self.file_handler.timerange_signal.connect(self.set_plot_timerange)\n    self.file_handler.file_loaded_signal.connect(self.set_file_indicator)\n\n    # Remove shortcut from the \"Open File\" menu action\n    open_file_action = app.main_window.ui.actionOpen_File\n    open_file_action.setText(\"Open PyDM File...\")\n    open_file_action.setShortcut(QKeySequence())\n\n    # Create a custom menu for the application\n    menu_bar: QMenuBar = app.main_window.ui.menubar\n    first_menu = app.main_window.ui.menuFile.menuAction()\n    trace_menu = self.construct_trace_menu(menu_bar)\n    menu_bar.insertMenu(first_menu, trace_menu)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.construct_trace_menu","title":"<code>construct_trace_menu(parent)</code>","text":"<p>Create the menu for the application.</p> Source code in <code>trace/main.py</code> <pre><code>def construct_trace_menu(self, parent: QMenuBar) -&gt; QMenu:\n    \"\"\"Create the menu for the application.\"\"\"\n    menu = QMenu(\"Trace\", parent)\n    save = menu.addAction(\"Save\", self.file_handler.save_file)\n    save.setShortcut(QKeySequence(\"Ctrl+S\"))\n    save_as = menu.addAction(\"Save As...\", self.file_handler.save_as)\n    save_as.setShortcut(QKeySequence(\"Ctrl+Shift+S\"))\n    load = menu.addAction(\"Open Trace Config...\", self.file_handler.open_file)\n    load.setShortcut(QKeySequence(\"Ctrl+O\"))\n    menu.addSeparator()\n\n    save_image = menu.addAction(\"Save Plot Image...\", self.save_plot_image)\n    save_image.setShortcut(QKeySequence(\"Ctrl+I\"))\n    save_elog = menu.addAction(\"Save ELOG Entry...\", self.elog_button_clicked)\n    save_elog.setShortcut(QKeySequence(\"Ctrl+E\"))\n    menu.addSeparator()\n\n    fetch_archive = menu.addAction(\"Fetch Archive Data\", self.fetch_archive)\n    fetch_archive.setShortcut(QKeySequence(\"Ctrl+F\"))\n    dit_action = menu.addAction(\"Data Insight Tool...\", self.data_insight_tool.show)\n    dit_action.setShortcut(QKeySequence(\"Ctrl+D\"))\n\n    return menu\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.elog_button_clicked","title":"<code>elog_button_clicked()</code>","text":"<p>Takes a snapshot of the plot and posts it to the Elog API.</p> <p>:return: True if the post was successful, False otherwise.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot()\ndef elog_button_clicked(self) -&gt; bool:\n    \"\"\"Takes a snapshot of the plot and posts it to the Elog API.\n\n    :return: True if the post was successful, False otherwise.\"\"\"\n    # Test if API is reachable\n    status_code, _ = get_user()\n    if status_code != 200:\n        error_dialog = QMessageBox()\n        error_dialog.setIcon(QMessageBox.Warning)\n        error_dialog.setWindowTitle(\"Connection Error\")\n        error_dialog.setText(\"Failed to connect to the Elog API.\")\n        error_dialog.setInformativeText(\n            f\"\"\"No entry was posted. If this issue persists, please report it in the\n            #elog-general Slack channel. \\n\\nError Code: {status_code}\"\"\"\n        )\n        error_dialog.setStandardButtons(QMessageBox.Ok)\n        error_dialog.exec_()\n        return False\n\n    # Form the request info\n    # Use ImageExporter to take a snapshot of the plot\n    exporter = ImageExporter(self.plot.plotItem)\n    img: QImage = exporter.export(toBytes=True)\n    # Convert Qimage to bytes\n    buffer = QBuffer()\n    buffer.open(QIODevice.ReadWrite)\n    img.save(buffer, \"PNG\")\n    image_bytes = buffer.data()\n    # Get entry info from user\n    dialog = ElogPostModal.maybe_create(self, image_bytes=image_bytes)\n    if dialog is not None and dialog.exec_() == QDialog.Accepted:\n        title, body, logbooks, attach_config = dialog.get_inputs()\n    else:\n        return False\n\n    config_file_path = None\n    if attach_config:\n        self.file_handler.save_file()\n        config_file_path = self.file_handler.current_file\n\n    # Post the request to the Elog API\n    status_code, _ = post_entry(title, body, logbooks, image_bytes, config_file_path)\n\n    # Check if the request was successful\n    if status_code == 201:\n        success_dialog = QMessageBox()\n        success_dialog.setIcon(QMessageBox.Information)\n        success_dialog.setWindowTitle(\"Elog Entry Posted\")\n        success_dialog.setText(\"Elog entry posted successfully!\")\n        success_dialog.setStandardButtons(QMessageBox.Ok)\n        success_dialog.exec_()\n        return True\n    else:\n        error_dialog = QMessageBox()\n        error_dialog.setIcon(QMessageBox.Warning)\n        error_dialog.setWindowTitle(\"Connection Error\")\n        error_dialog.setText(\"Failed to connect to the Elog API.\")\n        error_dialog.setInformativeText(\n            f\"No entry was posted. If this issue persists, please report it in the \\\n            #elog-general Slack channel. \\n\\nError Code: {status_code}\"\n        )\n        error_dialog.setStandardButtons(QMessageBox.Ok)\n        error_dialog.exec_()\n        return False\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.fetch_archive","title":"<code>fetch_archive()</code>","text":"<p>Triggers a fetch to the archive</p> Source code in <code>trace/main.py</code> <pre><code>@Slot()\ndef fetch_archive(self) -&gt; None:\n    \"\"\"Triggers a fetch to the archive\"\"\"\n    if not (self.plot._archive_request_queued):\n        logger.info(\"Requesting data from archiver\")\n        self.plot.requestDataFromArchiver()\n    else:\n        logger.info(\"Archive fetch is already queued\")\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.git_version","title":"<code>git_version()</code>  <code>staticmethod</code>","text":"<p>Get the current git tag for the project</p> Source code in <code>trace/main.py</code> <pre><code>@staticmethod\ndef git_version():\n    \"\"\"Get the current git tag for the project\"\"\"\n    project_directory = __file__.rsplit(\"/\", 1)[0]\n    git_cmd = subprocess.run(\n        f\"cd {project_directory} &amp;&amp; git describe --tags\", text=True, shell=True, capture_output=True\n    )\n    return git_cmd.stdout.strip()\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.parse_cli_args","title":"<code>parse_cli_args(args, macros)</code>","text":"Source code in <code>trace/main.py</code> <pre><code>def parse_cli_args(self, args, macros):\n    \"\"\"\"\"\"\n    args = args or []\n    macros = macros or {}\n\n    parser = argparse.ArgumentParser(\n        prog=\"trace\",\n        description=\"Trace\\nThis is a PyDM application used to display archived and live pv data.\",\n        epilog=\"\\n\\t\".join(\n            [\n                \"Examples:\",\n                \"pydm $PHYSICS_TOP/trace/main.py\"\n                \"bash $PHYSICS_TOP/trace/launch_trace.bash\"\n                \"%(prog)s\"\n                \"%(prog)s -i some_input_file.trc\"\n                \"%(prog)s -p SOME:PV:TO:PLOT OTHER:PV:TO:PLOT\"\n                '%(prog)s -m \\'{\"PVS\": [\"FOO:CHANNEL\", \"BAR:CHANNEL\", \"f://{A}+{B}\"]}\\''\n                '%(prog)s -m \"INPUT_FILE = trace/examples/FormulaExample.trc\"',\n            ]\n        ),\n        formatter_class=argparse.RawTextHelpFormatter,\n    )\n\n    parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s \" + self.git_version())\n    parser.add_argument(\n        \"-i\",\n        \"--input_file\",\n        action=PathAction,\n        nargs=\"?\",\n        default=[],\n        help=\"Absolute file path to import from\\nAlternatively can be provided as INPUT_FILE macro\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--pvs\",\n        nargs=\"*\",\n        default=[],\n        help=\"\\n\".join(\n            [\n                \"Space-separated list of PVs to show on startup\",\n                \"Formulas should be passed without spaces: f://{A}+{B}\",\n                \"Alternatively can be provided as PV or PVS macros\",\n            ]\n        ),\n    )\n    parser.add_argument(\n        \"-m\",\n        \"--macro\",\n        default=\"\",\n        help=\"\\n\\t\".join(\n            [\n                \"Mimic PyDM macro replacements to use. Should be in JSON object format.\",\n                \"ON Formatting Reminder:\",\n                \"JSON requires double quotes for strings, so you should wrap this\",\n                \"whole argument in single quotes.\",\n                \"--or--\",\n                \"Specify macro replacements as KEY=value pairs using a comma as a\",\n                \"delimiter. If you want to uses spaces after the delimiters or around\",\n                \"the '=' signs, wrap the entire set with quotes.\",\n            ]\n        ),\n    )\n\n    # Parse arguments and ignore unknowns\n    known, unknown = parser.parse_known_args(args)\n    for arg in unknown:\n        if arg:\n            logger.warning(f\"Not using unknown argument: {arg}\")\n\n    # Parse any macros passed into trace\n    if known.macro:\n        parsed_macros = parse_macro_string(known.macro)\n        macros.update(**parsed_macros)\n\n    # Get the file to import from if one is provided. Prioritize args over macro\n    try:\n        # Need to unpack as PathAction returns a list\n        input_file = known.input_file[0]\n    except IndexError:\n        input_file = macros.get(\"INPUT_FILE\", \"\")\n\n    # Get the list of PVs to show on startup\n    startup_pvs = []\n    for key in (\"PV\", \"PVS\"):\n        if key in macros:\n            val = macros[key]\n            if isinstance(val, str):\n                startup_pvs.append(val)\n            elif isinstance(val, list):\n                startup_pvs.extend(val)\n    startup_pvs += known.pvs\n\n    # Remove duplicates from startup_pvs\n    startup_pvs = list(dict.fromkeys(startup_pvs))\n\n    return (input_file, startup_pvs)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.save_plot_image","title":"<code>save_plot_image()</code>","text":"<p>Saves current plot as an image. Opens file dialog to allow user to set custom location.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot()\ndef save_plot_image(self) -&gt; None:\n    \"\"\"Saves current plot as an image. Opens file dialog to allow user to\n    set custom location.\"\"\"\n    exporter = ImageExporter(self.plot.plotItem)\n    default_filename = datetime.now().strftime(f\"{getuser()}_trace_%Y%m%d_%H%M%S.png\")\n    usr_home_dir = os.path.expanduser(\"~\")\n    file_path, _ = QFileDialog.getSaveFileName(\n        None,\n        \"Save Plot Image\",\n        os.path.join(usr_home_dir, default_filename),\n        \"PNG Files (*.png);;JPEG Files (*.jpg);;All Files (*)\",\n    )\n    if file_path:\n        try:\n            exporter.export(file_path)\n            logger.info(f\"Saved image file to: {file_path}\")\n        except Exception as e:\n            logger.error(f\"Failed to save image: {e}\")\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.set_auto_scroll_interval","title":"<code>set_auto_scroll_interval(inteval)</code>","text":"<p>Set the auto scroll interval for the plot</p> Source code in <code>trace/main.py</code> <pre><code>@Slot(int)\ndef set_auto_scroll_interval(self, inteval: int) -&gt; None:\n    \"\"\"Set the auto scroll interval for the plot\"\"\"\n    timespan = self.timespan_buttons.checkedId()\n    enable_scroll = timespan != DISABLE_AUTO_SCROLL\n\n    self.plot.setAutoScroll(enable_scroll, timespan, refresh_rate=inteval)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.set_auto_scroll_span","title":"<code>set_auto_scroll_span(timespan=None)</code>","text":"<p>Slot to be called when a timespan setting button is pressed. This will enable autoscrolling along the x-axis and disable mouse controls. If the \"Cursor\" button is pressed, then autoscrolling is disabled and mouse controls are enabled.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot()\n@Slot(float)\ndef set_auto_scroll_span(self, timespan: float = None) -&gt; None:\n    \"\"\"Slot to be called when a timespan setting button is pressed.\n    This will enable autoscrolling along the x-axis and disable mouse\n    controls. If the \"Cursor\" button is pressed, then autoscrolling is\n    disabled and mouse controls are enabled.\n    \"\"\"\n    if timespan is None:\n        timespan = self.timespan_buttons.checkedId()\n        enable_scroll = timespan != DISABLE_AUTO_SCROLL\n    else:\n        enable_scroll = True\n        self.disable_auto_scroll_button.click()\n\n    if enable_scroll:\n        logger.debug(f\"Enabling plot autoscroll for {timespan}s\")\n    else:\n        logger.debug(\"Disabling plot autoscroll, using mouse controls\")\n    self.autoScroll(enable=enable_scroll, timespan=timespan)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.set_file_indicator","title":"<code>set_file_indicator(file_path)</code>","text":"<p>Set the file indicator label to the given file path.</p> Source code in <code>trace/main.py</code> <pre><code>def set_file_indicator(self, file_path: str) -&gt; None:\n    \"\"\"Set the file indicator label to the given file path.\"\"\"\n    if not file_path:\n        return\n    filename = os.path.basename(file_path)\n    if hasattr(self, \"file_label\") and self.file_label is not None:\n        self.file_label.setText(filename)\n    else:\n        self.footer_info_widget.layout().addWidget(BreakerLabel(self.footer_info_widget))\n        self.file_label = QLabel(filename, self.footer_info_widget)\n        self.file_label.setFont(self.footer_label_font)\n        self.file_label.setToolTip(\"Currently loaded file\")\n        self.footer_info_widget.layout().addWidget(self.file_label)\n</code></pre>"},{"location":"reference/trace/#main.TraceDisplay.set_plot_timerange","title":"<code>set_plot_timerange(timerange)</code>","text":"<p>Set the plot's timerange to the given start and end datetimes.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot(tuple)\ndef set_plot_timerange(self, timerange: tuple[float, float]) -&gt; None:\n    \"\"\"Set the plot's timerange to the given start and end datetimes.\"\"\"\n    self.disable_auto_scroll_button.click()\n    self.plot.setXRange(*timerange)\n    logger.debug(f\"Plot timerange set to {timerange[0]} - {timerange[1]}\")\n</code></pre>"},{"location":"reference/widgets/control_panel/","title":"Control Panel","text":""},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem","title":"<code>AxisItem</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>class AxisItem(QtWidgets.QWidget):\n    curves_list_changed = QtCore.Signal()\n\n    def __init__(self, plot_axis_item: BasePlotAxisItem, control_panel=None):\n        super().__init__()\n        self.source = plot_axis_item\n        self.control_panel_ref = control_panel\n        self.setLayout(QtWidgets.QVBoxLayout())\n        self.setAcceptDrops(True)\n\n        self.header_layout = QtWidgets.QHBoxLayout()\n        self.layout().addLayout(self.header_layout)\n\n        self._expanded = False\n        self.expand_button = QtWidgets.QPushButton()\n        self.expand_button.setIcon(qta.icon(\"msc.chevron-right\"))\n        self.expand_button.setFlat(True)\n        self.expand_button.clicked.connect(self.toggle_expand)\n        self.header_layout.addWidget(self.expand_button)\n\n        layout = QtWidgets.QVBoxLayout()\n        self.header_layout.addLayout(layout)\n        self.top_settings_layout = QtWidgets.QHBoxLayout()\n        layout.addLayout(self.top_settings_layout)\n        self.axis_label = QtWidgets.QLineEdit()\n        self.axis_label.setText(self.source.name)\n        self.axis_label.editingFinished.connect(self.set_axis_name)\n        self.axis_label.returnPressed.connect(self.axis_label.clearFocus)\n        self.top_settings_layout.addWidget(self.axis_label)\n        self.settings_button = QtWidgets.QPushButton()\n        self.settings_button.setIcon(qta.icon(\"msc.settings-gear\"))\n        self.settings_button.setFlat(True)\n        self.settings_modal = None\n        self.settings_button.clicked.connect(self.show_settings_modal)\n        self.top_settings_layout.addWidget(self.settings_button)\n        self.delete_button = QtWidgets.QPushButton()\n        self.delete_button.setIcon(qta.icon(\"msc.trash\"))\n        self.delete_button.setFlat(True)\n        self.delete_button.clicked.connect(self.close)\n        self.top_settings_layout.addWidget(self.delete_button)\n        self.bottom_settings_layout = QtWidgets.QHBoxLayout()\n        layout.addLayout(self.bottom_settings_layout)\n        self.auto_range_checkbox = QtWidgets.QCheckBox(\"Auto\")\n        self.auto_range_checkbox.setCheckState(QtCore.Qt.Checked if self.source.auto_range else QtCore.Qt.Unchecked)\n        self.auto_range_checkbox.stateChanged.connect(self.set_auto_range)\n        self.source.linkedView().sigRangeChangedManually.connect(self.disable_auto_range)\n        self.bottom_settings_layout.addWidget(self.auto_range_checkbox)\n        self.bottom_settings_layout.addWidget(QtWidgets.QLabel(\"min, max\"))\n        self.min_range_line_edit = QtWidgets.QLineEdit()\n        self.min_range_line_edit.editingFinished.connect(self.set_min_range)\n        self.min_range_line_edit.editingFinished.connect(self.disable_auto_range)\n        self.min_range_line_edit.setMinimumWidth(self.min_range_line_edit.font().pointSize() * 8)\n        self.bottom_settings_layout.addWidget(self.min_range_line_edit)\n        self.bottom_settings_layout.addWidget(QtWidgets.QLabel(\",\"))\n        self.max_range_line_edit = QtWidgets.QLineEdit()\n        self.max_range_line_edit.editingFinished.connect(self.set_max_range)\n        self.max_range_line_edit.editingFinished.connect(self.disable_auto_range)\n        self.max_range_line_edit.setMinimumWidth(self.max_range_line_edit.font().pointSize() * 8)\n        self.bottom_settings_layout.addWidget(self.max_range_line_edit)\n        self.source.sigYRangeChanged.connect(self.handle_range_change)\n\n        self.active_toggle = QtWidgets.QCheckBox(\"Active\")\n        self.active_toggle.setCheckState(QtCore.Qt.Checked if self.source.isVisible() else QtCore.Qt.Unchecked)\n        self.active_toggle.stateChanged.connect(self.set_active)\n        self.header_layout.addWidget(self.active_toggle)\n\n        self.placeholder = QtWidgets.QWidget(self)\n        self.placeholder.hide()\n        self.placeholder.setStyleSheet(\"background-color: lightgrey;\")\n\n    @property\n    def plot(self):\n        return self.parent().parent().parent().parent().plot\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get the name of the axis.\"\"\"\n        return self.source.name\n\n    def add_curve(self, pv: str, channel_args: dict = None) -&gt; \"CurveItem\":\n        plot = self.plot\n        index = len(plot._curves)\n        color = ColorButton.index_color(index)\n\n        args = {\n            \"y_channel\": pv,\n            \"name\": pv,\n            \"color\": color,\n            \"useArchiveData\": True,\n            \"yAxisName\": self.source.name,\n        }\n        if channel_args is not None:\n            args.update(channel_args)\n\n        try:\n            plot.addYChannel(**args)\n        except TypeError as e:\n            logger.error(f\"Failed to add curve: {e}\")\n            return None\n\n        plot_curve_item = plot._curves[-1]\n\n        control_panel = self.control_panel\n        while control_panel and not hasattr(control_panel, \"_curve_dict\"):\n            control_panel = control_panel.parent()\n\n        variable_name = \"x?\"\n        if control_panel:\n            variable_name = control_panel._generate_pv_key(\"pv\")\n            control_panel._curve_dict[variable_name] = plot_curve_item\n\n        curve_item = CurveItem(plot_curve_item, variable_name=variable_name)\n        curve_item.curve_deleted.connect(self.curves_list_changed.emit)\n        curve_item.curve_deleted.connect(lambda curve: self.handle_curve_deleted(curve))\n        self.layout().addWidget(curve_item)\n\n        if not self._expanded:\n            self.toggle_expand()\n\n        self.curves_list_changed.emit()\n        return curve_item\n\n    def add_formula_curve(self, formula):\n        control_panel = self.control_panel\n        while control_panel and not hasattr(control_panel, \"_curve_dict\"):\n            control_panel = control_panel.parent()\n\n        if not control_panel:\n            raise RuntimeError(\"Could not find ControlPanel\")\n\n        plot = control_panel.plot\n        var_names = re.findall(r\"{(.+?)}\", formula)\n        var_dict = {}\n\n        for var_name in var_names:\n            if var_name not in control_panel._curve_dict:\n                available_vars = list(control_panel._curve_dict.keys())\n                raise ValueError(f\"{var_name} is an invalid variable name. Available: {available_vars}\")\n            var_dict[var_name] = control_panel._curve_dict[var_name]\n\n        expr_body = formula[4:]\n        if var_names:\n            python_expr, allowed = sanitize_for_validation(expr_body)\n            validate_formula(python_expr, allowed_symbols=allowed)\n        else:\n            validate_formula(expr_body, allowed_symbols=set())\n\n        index = len(plot._curves)\n        color = ColorButton.index_color(index)\n\n        formula_curve_item = plot.addFormulaChannel(\n            formula=formula, name=formula, pvs=var_dict, color=color, useArchiveData=True, yAxisName=self.source.name\n        )\n\n        if hasattr(formula_curve_item, \"formula_invalid_signal\"):\n            formula_curve_item.formula_invalid_signal.connect(\n                lambda: self.auto_hide_invalid_formula(formula_curve_item)\n            )\n\n        variable_name = control_panel._generate_pv_key(\"formula\")\n        control_panel._curve_dict[variable_name] = formula_curve_item\n\n        curve_item = CurveItem(formula_curve_item, variable_name=variable_name)\n        curve_item.curve_deleted.connect(self.curves_list_changed.emit)\n        curve_item.curve_deleted.connect(lambda curve: self.handle_curve_deleted(curve))\n        curve_item.active_toggle.setCheckState(self.active_toggle.checkState())\n\n        self.layout().addWidget(curve_item)\n        self.curves_list_changed.emit()\n\n        if not self._expanded:\n            self.toggle_expand()\n\n        return curve_item\n\n    def auto_hide_invalid_formula(self, formula_curve):\n        \"\"\"Automatically hide a formula when it becomes invalid\"\"\"\n        formula_curve.setVisible(False)\n\n        curve_item = self.find_curve_item_for_curve(formula_curve)\n        if curve_item and hasattr(curve_item, \"active_toggle\"):\n            curve_item.active_toggle.setChecked(False)\n            if hasattr(curve_item, \"show_invalid_icon\"):\n                curve_item.show_invalid_icon(True)\n\n    def toggle_expand(self):\n        if self._expanded:\n            for index in range(1, self.layout().count()):\n                self.layout().itemAt(index).widget().hide()\n            self.expand_button.setIcon(qta.icon(\"msc.chevron-right\"))\n        else:\n            for index in range(1, self.layout().count()):\n                self.layout().itemAt(index).widget().show()\n            self.expand_button.setIcon(qta.icon(\"msc.chevron-down\"))\n        self._expanded = not self._expanded\n\n    def set_active(self, state: QtCore.Qt.CheckState):\n        if state == QtCore.Qt.Unchecked:\n            self.source.hide()\n        else:\n            self.source.show()\n        for i in range(1, self.layout().count()):\n            self.layout().itemAt(i).widget().active_toggle.setCheckState(state)\n\n    def set_auto_range(self, state: QtCore.Qt.CheckState):\n        self.source.auto_range = state == QtCore.Qt.Checked\n\n    def disable_auto_range(self):\n        self.auto_range_checkbox.setCheckState(QtCore.Qt.Unchecked)\n\n    def handle_range_change(self, _, range):\n        self.min_range_line_edit.setText(f\"{range[0]:.3g}\")\n        self.max_range_line_edit.setText(f\"{range[1]:.3g}\")\n\n    def handle_curve_deleted(self, curve):\n        self.curves_list_changed.emit()\n        control_panel = self.control_panel\n        curve_key_to_delete = None\n\n        for key, value in control_panel.curve_dict.items():\n            if value == curve:\n                curve_key_to_delete = key\n                break\n\n        if curve_key_to_delete:\n            dependent_formulas = []\n\n            for key, other_curve in control_panel.curve_dict.items():\n                if hasattr(other_curve, \"pvs\") and curve_key_to_delete in other_curve.pvs:\n                    dependent_formulas.append(key)\n\n                    other_curve.setVisible(False)\n\n                    curve_item = self.find_curve_item_for_curve(other_curve)\n                    if curve_item and hasattr(curve_item, \"active_toggle\"):\n                        curve_item.active_toggle.setChecked(False)\n\n                    logger.debug(f\"Hiding invalid formula: {key} (depends on deleted {curve_key_to_delete})\")\n\n                    if hasattr(curve_item, \"show_invalid_icon\") and curve_item is not None:\n                        curve_item.show_invalid_icon(True)\n\n            if dependent_formulas:\n                logger.debug(f\"Hidden {len(dependent_formulas)} formulas that depended on {curve_key_to_delete}\")\n\n            del control_panel.curve_dict[curve_key_to_delete]\n\n    def find_curve_item_for_curve(self, target_curve):\n        \"\"\"Find the CurveItem widget that corresponds to a given curve\"\"\"\n        for i in range(self.layout().count()):\n            widget = self.layout().itemAt(i).widget()\n            if hasattr(widget, \"source\") and widget.source == target_curve:\n                return widget\n\n        control_panel = self.control_panel\n        for i in range(control_panel.axis_list.count() - 1):  # -1 for stretch\n            axis_item = control_panel.axis_list.itemAt(i).widget()\n            if hasattr(axis_item, \"layout\"):\n                for j in range(axis_item.layout().count()):\n                    widget = axis_item.layout().itemAt(j).widget()\n                    if hasattr(widget, \"source\") and widget.source == target_curve:\n                        return widget\n\n        return None\n\n    @QtCore.Slot()\n    def set_min_range(self, value: float = None):\n        if value is None:\n            value = float(self.sender().text())\n        else:\n            self.min_range_line_edit.setText(f\"{value:.3g}\")\n        logger.debug(f\"Setting min range for axis {self.source.name}: {value}\")\n        self.source.min_range = value\n\n    @QtCore.Slot()\n    def set_max_range(self, value: float = None):\n        if value is None:\n            value = float(self.sender().text())\n        else:\n            self.max_range_line_edit.setText(f\"{value:.3g}\")\n        logger.debug(f\"Setting max range for axis {self.source.name}: {value}\")\n        self.source.max_range = value\n\n    @QtCore.Slot()\n    def set_axis_name(self, name: str = None):\n        if name is None and self.sender():\n            name = self.sender().text()\n        self.source.name = name\n        self.source.label_text = name\n\n    @QtCore.Slot()\n    def show_settings_modal(self):\n        if self.settings_modal is None:\n            self.settings_modal = AxisSettingsModal(self.settings_button, self.plot, self.source)\n        self.settings_modal.show()\n\n    def dragEnterEvent(self, event: QtGui.QDragEnterEvent):\n        if event.possibleActions() &amp; QtCore.Qt.MoveAction:\n            event.acceptProposedAction()\n            self.placeholder.setMinimumSize(event.source().size())\n            self.placeholder.show()\n            if not self._expanded:\n                self.toggle_expand()\n\n    def dragMoveEvent(self, event: QtGui.QDragMoveEvent):\n        item = self.childAt(event.position().toPoint())\n        if item != self.placeholder:\n            self.layout().removeWidget(self.placeholder)\n            index = self.layout().indexOf(item) + 1  # drop below target row\n            index = max(1, index)  # don't drop above axis detail row\n            self.layout().insertWidget(index, self.placeholder)\n\n    def dragLeaveEvent(self, event: QtGui.QDragLeaveEvent):\n        event.accept()\n        self.layout().removeWidget(self.placeholder)\n        self.placeholder.hide()\n\n    def dropEvent(self, event: QtGui.QDropEvent):\n        event.accept()\n        curve_item = event.source()\n        curve_item.curve_deleted.disconnect()\n        curve_item.curve_deleted.connect(self.curves_list_changed.emit)\n        curve_item.active_toggle.setCheckState(self.active_toggle.checkState())\n        self.plot.plotItem.unlinkDataFromAxis(curve_item.source)\n        self.plot.plotItem.linkDataToAxis(curve_item.source, self.source.name)\n        curve_item.source.y_axis_name = self.source.name\n\n        self.layout().removeWidget(curve_item)  # in case we're reordering within an AxisItem\n        self.layout().replaceWidget(self.placeholder, curve_item)\n        self.placeholder.hide()\n        if not self._expanded:\n            self.toggle_expand()\n        self.curves_list_changed.emit()\n\n    def clear_curves(self) -&gt; None:\n        \"\"\"Clear all curves from this axis item.\"\"\"\n        for i in range(self.layout().count() - 1, -1, -1):\n            item = self.layout().itemAt(i).widget()\n            if isinstance(item, CurveItem):\n                item.close()\n\n    def close(self) -&gt; bool:\n        self.clear_curves()\n        self.source.sigYRangeChanged.disconnect(self.handle_range_change)\n        self.source.linkedView().sigRangeChangedManually.disconnect(self.disable_auto_range)\n        index = self.plot._axes.index(self.source)\n        self.plot.removeAxisAtIndex(index)\n        self.setParent(None)\n        self.deleteLater()\n        return super().close()\n\n    @property\n    def control_panel(self):\n        if self.control_panel_ref is None:\n            parent = self.parent().parent().parent().parent()\n            while parent and not isinstance(parent, ControlPanel):\n                parent = parent.parent()\n            self.control_panel_ref = parent.control_panel\n        return self.control_panel_ref\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the axis.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.auto_hide_invalid_formula","title":"<code>auto_hide_invalid_formula(formula_curve)</code>","text":"<p>Automatically hide a formula when it becomes invalid</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def auto_hide_invalid_formula(self, formula_curve):\n    \"\"\"Automatically hide a formula when it becomes invalid\"\"\"\n    formula_curve.setVisible(False)\n\n    curve_item = self.find_curve_item_for_curve(formula_curve)\n    if curve_item and hasattr(curve_item, \"active_toggle\"):\n        curve_item.active_toggle.setChecked(False)\n        if hasattr(curve_item, \"show_invalid_icon\"):\n            curve_item.show_invalid_icon(True)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.clear_curves","title":"<code>clear_curves()</code>","text":"<p>Clear all curves from this axis item.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def clear_curves(self) -&gt; None:\n    \"\"\"Clear all curves from this axis item.\"\"\"\n    for i in range(self.layout().count() - 1, -1, -1):\n        item = self.layout().itemAt(i).widget()\n        if isinstance(item, CurveItem):\n            item.close()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.AxisItem.find_curve_item_for_curve","title":"<code>find_curve_item_for_curve(target_curve)</code>","text":"<p>Find the CurveItem widget that corresponds to a given curve</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def find_curve_item_for_curve(self, target_curve):\n    \"\"\"Find the CurveItem widget that corresponds to a given curve\"\"\"\n    for i in range(self.layout().count()):\n        widget = self.layout().itemAt(i).widget()\n        if hasattr(widget, \"source\") and widget.source == target_curve:\n            return widget\n\n    control_panel = self.control_panel\n    for i in range(control_panel.axis_list.count() - 1):  # -1 for stretch\n        axis_item = control_panel.axis_list.itemAt(i).widget()\n        if hasattr(axis_item, \"layout\"):\n            for j in range(axis_item.layout().count()):\n                widget = axis_item.layout().itemAt(j).widget()\n                if hasattr(widget, \"source\") and widget.source == target_curve:\n                    return widget\n\n    return None\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel","title":"<code>ControlPanel</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>class ControlPanel(QtWidgets.QWidget):\n    curve_list_changed = QtCore.Signal()\n\n    def __init__(self):\n        super().__init__()\n        self.setLayout(QtWidgets.QVBoxLayout())\n        self.setStyleSheet(\"background-color: white;\")\n\n        self._curve_dict = {}\n        self._next_pv_number = 1\n        self._next_formula_number = 1\n\n        # Create pv plotter layout\n        pv_plotter_layout = QtWidgets.QHBoxLayout()\n        self.layout().addLayout(pv_plotter_layout)\n        self.search_button = QtWidgets.QPushButton(\"Search PV\")\n        self.search_button.clicked.connect(self.search_pv)\n        pv_plotter_layout.addWidget(self.search_button)\n\n        self.calc_button = QtWidgets.QPushButton()\n        self.calc_button.setIcon(qta.icon(\"fa6s.calculator\"))\n        self.calc_button.setFlat(True)\n        self.calc_button.clicked.connect(self.show_formula_dialog)\n        pv_plotter_layout.addWidget(self.calc_button)\n\n        self.pv_line_edit = QtWidgets.QLineEdit()\n        self.pv_line_edit.setPlaceholderText(\"Enter PV\")\n        self.pv_line_edit.returnPressed.connect(self.add_curve_from_line_edit)\n        pv_plotter_layout.addWidget(self.pv_line_edit)\n        pv_plot_button = QtWidgets.QPushButton(\"Plot\")\n        pv_plot_button.clicked.connect(self.add_curve_from_line_edit)\n        pv_plotter_layout.addWidget(pv_plot_button)\n\n        self.axis_list = QtWidgets.QVBoxLayout()\n        frame = QtWidgets.QFrame()\n        frame.setLayout(self.axis_list)\n        scrollarea = QtWidgets.QScrollArea()\n        scrollarea.setWidgetResizable(True)\n        scrollarea.setWidget(frame)\n        self.layout().addWidget(scrollarea)\n        self.axis_list.addStretch()\n\n        new_axis_button = QtWidgets.QPushButton(\"New Axis\")\n        new_axis_button.clicked.connect(self.add_empty_axis)\n        self.layout().addWidget(new_axis_button)\n\n        self.archive_search = ArchiveSearchWidget()\n\n        self.formula_dialog = FormulaDialog(self)\n        self.formula_dialog.formula_accepted.connect(self.handle_formula_accepted)\n        self.curve_list_changed.connect(self.formula_dialog.curve_model.refresh)\n\n    def minimumSizeHint(self) -&gt; QtCore.QSize:\n        inner_size = self.axis_list.minimumSize()\n        buffer = self.pv_line_edit.font().pointSize() * 3\n        return QtCore.QSize(inner_size.width() + buffer, inner_size.height())\n\n    def add_curve_from_line_edit(self) -&gt; None:\n        pv = self.pv_line_edit.text()\n        self.add_curve(pv)\n        self.pv_line_edit.clear()\n\n    @property\n    def plot(self):\n        if not self._plot:\n            parent = self.parent()\n            while not hasattr(parent, \"plot\"):\n                parent = parent.parent()\n            self._plot = parent.plot\n        return self._plot\n\n    @plot.setter\n    def plot(self, plot):\n        self._plot = plot\n\n    def search_pv(self) -&gt; None:\n        if not hasattr(self, \"archive_search\") or not self.archive_search.isVisible():\n            self.archive_search.append_PVs_requested.connect(self.add_curves)\n            self.archive_search.show()\n        else:\n            self.archive_search.raise_()\n            self.archive_search.activateWindow()\n\n    def show_formula_dialog(self):\n        \"\"\"Show the formula dialog pop-up.\"\"\"\n        if not hasattr(self, \"formula_dialog\") or not self.formula_dialog.isVisible():\n            self.formula_dialog.show()\n        else:\n            self.formula_dialog.raise_()\n            self.formula_dialog.activateWindow()\n\n    @QtCore.Slot(str)\n    def handle_formula_accepted(self, formula: str) -&gt; None:\n        \"\"\"Handle the formula accepted from the formula dialog.\"\"\"\n        self.add_curve(formula)\n        self.cleanup_duplicate_curves()\n\n    def cleanup_duplicate_curves(self):\n        \"\"\"Remove duplicate entries in curve dictionary\"\"\"\n        seen_curves = {}\n        to_remove = []\n\n        for key, curve in self._curve_dict.items():\n            curve_id = id(curve)\n            if curve_id in seen_curves:\n                to_remove.append(key)\n            else:\n                seen_curves[curve_id] = key\n\n        for key in to_remove:\n            del self._curve_dict[key]\n\n        if to_remove:\n            self.curve_list_changed.emit()\n\n    @property\n    def curve_dict(self):\n        \"\"\"Return dictionary of curves with PV keys\"\"\"\n        return self._curve_dict\n\n    def _generate_pv_key(self, curve_type=\"pv\") -&gt; str:\n        \"\"\"Generate a unique PV key based on curve type\"\"\"\n        if curve_type == \"formula\":\n            while True:\n                key = f\"fx{self._next_formula_number}\"\n                self._next_formula_number += 1\n                if key not in self._curve_dict:\n                    return key\n        else:\n            while True:\n                key = f\"x{self._next_pv_number}\"\n                self._next_pv_number += 1\n                if key not in self._curve_dict:\n                    return key\n\n    def add_curves(self, pvs: list[str]) -&gt; None:\n        for pv in pvs:\n            self.add_curve(pv)\n\n    def add_empty_axis(self, name: str = \"\") -&gt; \"AxisItem\":\n        logger.debug(\"Adding new empty axis to the plot\")\n        if not name:\n            counter = len(self.plot.plotItem.axes) - 2\n            while (name := f\"Y-Axis {counter}\") in self.plot.plotItem.axes:\n                counter += 1\n\n        self.plot.addAxis(plot_data_item=None, name=name, orientation=\"left\", label=name)\n        new_axis = self.plot._axes[-1]\n        new_axis.setLabel(name, color=\"black\")\n\n        return self.add_axis_item(new_axis)\n\n    def add_axis_item(self, axis: BasePlotAxisItem) -&gt; \"AxisItem\":\n        \"\"\"Add an existing AxisItem to the plot.\"\"\"\n        self.match_axis_tick_font(axis)\n        axis_item = AxisItem(axis, control_panel=self)\n        axis_item.curves_list_changed.connect(self.curve_list_changed.emit)\n        self.axis_list.insertWidget(self.axis_list.count() - 1, axis_item)\n        logger.debug(f\"Added axis {axis.name} to plot\")\n        self.updateGeometry()\n\n        return axis_item\n\n    def match_axis_tick_font(self, axis: BasePlotAxisItem) -&gt; None:\n        \"\"\"Matches the axis' tick font to the X-Axis of the plot. Only necessary\n        if the user has changed the tick font of the plot's axes.\n\n        Parameters\n        ----------\n        axis : BasePlotAxisItem\n            The axis to match the tick font for.\"\"\"\n        x_axis = self.plot.getAxis(\"bottom\")\n        if x_axis is not None:\n            axis.setTickFont(x_axis.style[\"tickFont\"])\n\n    def get_axis_item(self, axis_name: str) -&gt; \"AxisItem\":\n        \"\"\"Get an AxisItem by its name.\"\"\"\n        for index in range(self.axis_list.count()):\n            item = self.axis_list.itemAt(index).widget()\n            if isinstance(item, AxisItem) and item.name == axis_name:\n                return item\n        return None\n\n    def get_last_axis_item(self) -&gt; \"AxisItem\":\n        \"\"\"Get the last AxisItem in the list.\"\"\"\n        if self.axis_list.count() &gt; 1:  # the stretch makes count &gt;= 1\n            return self.axis_list.itemAt(self.axis_list.count() - 2).widget()\n        else:\n            logger.warning(\"No axes available to return the last AxisItem.\")\n            return None\n\n    @QtCore.Slot()\n    def add_curve(self, pv: str = None) -&gt; \"CurveItem\":\n        if pv is None and self.sender():\n            pv = self.sender().text()\n\n        last_axis = self.get_last_axis_item()\n        if not last_axis:\n            last_axis = self.add_empty_axis()\n\n        if pv.startswith(\"f://\"):\n            return last_axis.add_formula_curve(pv)\n        else:\n            return last_axis.add_curve(pv)\n\n    def clear_all(self) -&gt; None:\n        \"\"\"Clear all axes and curves from the plot and control panel.\"\"\"\n        logger.debug(\"Clearing all axes and curves from the plot\")\n        while self.axis_list.count() &gt; 1:  # Keep the stretch at the end\n            self.axis_list.itemAt(0).widget().close()\n        self.plot.redrawPlot()\n\n    def clear_curves(self) -&gt; None:\n        \"\"\"Clear all curves from the plot and control panel.\"\"\"\n        logger.debug(\"Clearing all curves from the plot\")\n        for axis_item in self.axis_list:\n            if isinstance(axis_item, AxisItem):\n                axis_item.clear_curves()\n\n    def set_axes(self, axes: list[dict] = None) -&gt; None:\n        \"\"\"Given a list of dictionaries containing axis data, clear the\n        plot's axes, and set all new axes based on the provided axis data.\n\n        Parameters\n        ----------\n        axes : List[Dict]\n            Axis properties to be set for all new axes on the plot\n        \"\"\"\n        self.clear_all()\n        for axis in axes:\n            self.plot.addAxis(\n                plot_data_item=None,\n                name=axis[\"name\"],\n                orientation=axis.get(\"orientation\", \"left\"),\n                label=axis[\"name\"],\n                log_mode=axis.get(\"logMode\", False),\n            )\n            # Convert axis properties to match BasePlotAxisItem\n            new_axis = self.plot._axes[-1]\n            new_axis.setLabel(axis[\"name\"], color=\"black\")\n\n            new_axis_item = self.add_axis_item(new_axis)\n            if \"minRange\" in axis:\n                new_axis_item.set_min_range(axis[\"minRange\"])\n            if \"maxRange\" in axis:\n                new_axis_item.set_max_range(axis[\"maxRange\"])\n            if \"autoRange\" in axis:\n                new_axis_item.auto_range_checkbox.setChecked(axis[\"autoRange\"])\n\n    def set_curves(self, curves: list[dict] = None) -&gt; None:\n        \"\"\"Given a list of dictionaries containing curve data, clear the\n        plot's curves, and set all new curves based on the provided curve data.\n\n        Parameters\n        ----------\n        curves : List[Dict]\n            Curve properties to be set for all new curves on the plot\n        \"\"\"\n        for curve_dict in curves:\n            try:\n                axis_name = curve_dict.get(\"yAxisName\", \"Y-Axis 0\")\n                axis_item = self.get_axis_item(axis_name)\n            except KeyError:\n                axis_item = self.get_last_axis_item()\n\n            if axis_item is None:\n                axis_item = self.add_empty_axis(axis_name)\n\n            pv_name = curve_dict.get(\"channel\", \"\")\n            del curve_dict[\"channel\"]  # Remove channel key to avoid conflicts with y_channel\n            axis_item.add_curve(pv_name, curve_dict)\n        self.plot.redrawPlot()\n        self.axis_list.itemAt(self.axis_list.count() - 2).widget()\n\n    def closeEvent(self, a0: QtGui.QCloseEvent):\n        for axis_item in range(self.axis_list.count()):\n            axis_item.close()\n        super().closeEvent(a0)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.curve_dict","title":"<code>curve_dict</code>  <code>property</code>","text":"<p>Return dictionary of curves with PV keys</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.add_axis_item","title":"<code>add_axis_item(axis)</code>","text":"<p>Add an existing AxisItem to the plot.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def add_axis_item(self, axis: BasePlotAxisItem) -&gt; \"AxisItem\":\n    \"\"\"Add an existing AxisItem to the plot.\"\"\"\n    self.match_axis_tick_font(axis)\n    axis_item = AxisItem(axis, control_panel=self)\n    axis_item.curves_list_changed.connect(self.curve_list_changed.emit)\n    self.axis_list.insertWidget(self.axis_list.count() - 1, axis_item)\n    logger.debug(f\"Added axis {axis.name} to plot\")\n    self.updateGeometry()\n\n    return axis_item\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.cleanup_duplicate_curves","title":"<code>cleanup_duplicate_curves()</code>","text":"<p>Remove duplicate entries in curve dictionary</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def cleanup_duplicate_curves(self):\n    \"\"\"Remove duplicate entries in curve dictionary\"\"\"\n    seen_curves = {}\n    to_remove = []\n\n    for key, curve in self._curve_dict.items():\n        curve_id = id(curve)\n        if curve_id in seen_curves:\n            to_remove.append(key)\n        else:\n            seen_curves[curve_id] = key\n\n    for key in to_remove:\n        del self._curve_dict[key]\n\n    if to_remove:\n        self.curve_list_changed.emit()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all axes and curves from the plot and control panel.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all axes and curves from the plot and control panel.\"\"\"\n    logger.debug(\"Clearing all axes and curves from the plot\")\n    while self.axis_list.count() &gt; 1:  # Keep the stretch at the end\n        self.axis_list.itemAt(0).widget().close()\n    self.plot.redrawPlot()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.clear_curves","title":"<code>clear_curves()</code>","text":"<p>Clear all curves from the plot and control panel.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def clear_curves(self) -&gt; None:\n    \"\"\"Clear all curves from the plot and control panel.\"\"\"\n    logger.debug(\"Clearing all curves from the plot\")\n    for axis_item in self.axis_list:\n        if isinstance(axis_item, AxisItem):\n            axis_item.clear_curves()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.get_axis_item","title":"<code>get_axis_item(axis_name)</code>","text":"<p>Get an AxisItem by its name.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def get_axis_item(self, axis_name: str) -&gt; \"AxisItem\":\n    \"\"\"Get an AxisItem by its name.\"\"\"\n    for index in range(self.axis_list.count()):\n        item = self.axis_list.itemAt(index).widget()\n        if isinstance(item, AxisItem) and item.name == axis_name:\n            return item\n    return None\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.get_last_axis_item","title":"<code>get_last_axis_item()</code>","text":"<p>Get the last AxisItem in the list.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def get_last_axis_item(self) -&gt; \"AxisItem\":\n    \"\"\"Get the last AxisItem in the list.\"\"\"\n    if self.axis_list.count() &gt; 1:  # the stretch makes count &gt;= 1\n        return self.axis_list.itemAt(self.axis_list.count() - 2).widget()\n    else:\n        logger.warning(\"No axes available to return the last AxisItem.\")\n        return None\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.handle_formula_accepted","title":"<code>handle_formula_accepted(formula)</code>","text":"<p>Handle the formula accepted from the formula dialog.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>@QtCore.Slot(str)\ndef handle_formula_accepted(self, formula: str) -&gt; None:\n    \"\"\"Handle the formula accepted from the formula dialog.\"\"\"\n    self.add_curve(formula)\n    self.cleanup_duplicate_curves()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.match_axis_tick_font","title":"<code>match_axis_tick_font(axis)</code>","text":"<p>Matches the axis' tick font to the X-Axis of the plot. Only necessary if the user has changed the tick font of the plot's axes.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.match_axis_tick_font--parameters","title":"Parameters","text":"<p>axis : BasePlotAxisItem     The axis to match the tick font for.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def match_axis_tick_font(self, axis: BasePlotAxisItem) -&gt; None:\n    \"\"\"Matches the axis' tick font to the X-Axis of the plot. Only necessary\n    if the user has changed the tick font of the plot's axes.\n\n    Parameters\n    ----------\n    axis : BasePlotAxisItem\n        The axis to match the tick font for.\"\"\"\n    x_axis = self.plot.getAxis(\"bottom\")\n    if x_axis is not None:\n        axis.setTickFont(x_axis.style[\"tickFont\"])\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.set_axes","title":"<code>set_axes(axes=None)</code>","text":"<p>Given a list of dictionaries containing axis data, clear the plot's axes, and set all new axes based on the provided axis data.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.set_axes--parameters","title":"Parameters","text":"<p>axes : List[Dict]     Axis properties to be set for all new axes on the plot</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def set_axes(self, axes: list[dict] = None) -&gt; None:\n    \"\"\"Given a list of dictionaries containing axis data, clear the\n    plot's axes, and set all new axes based on the provided axis data.\n\n    Parameters\n    ----------\n    axes : List[Dict]\n        Axis properties to be set for all new axes on the plot\n    \"\"\"\n    self.clear_all()\n    for axis in axes:\n        self.plot.addAxis(\n            plot_data_item=None,\n            name=axis[\"name\"],\n            orientation=axis.get(\"orientation\", \"left\"),\n            label=axis[\"name\"],\n            log_mode=axis.get(\"logMode\", False),\n        )\n        # Convert axis properties to match BasePlotAxisItem\n        new_axis = self.plot._axes[-1]\n        new_axis.setLabel(axis[\"name\"], color=\"black\")\n\n        new_axis_item = self.add_axis_item(new_axis)\n        if \"minRange\" in axis:\n            new_axis_item.set_min_range(axis[\"minRange\"])\n        if \"maxRange\" in axis:\n            new_axis_item.set_max_range(axis[\"maxRange\"])\n        if \"autoRange\" in axis:\n            new_axis_item.auto_range_checkbox.setChecked(axis[\"autoRange\"])\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.set_curves","title":"<code>set_curves(curves=None)</code>","text":"<p>Given a list of dictionaries containing curve data, clear the plot's curves, and set all new curves based on the provided curve data.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.set_curves--parameters","title":"Parameters","text":"<p>curves : List[Dict]     Curve properties to be set for all new curves on the plot</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def set_curves(self, curves: list[dict] = None) -&gt; None:\n    \"\"\"Given a list of dictionaries containing curve data, clear the\n    plot's curves, and set all new curves based on the provided curve data.\n\n    Parameters\n    ----------\n    curves : List[Dict]\n        Curve properties to be set for all new curves on the plot\n    \"\"\"\n    for curve_dict in curves:\n        try:\n            axis_name = curve_dict.get(\"yAxisName\", \"Y-Axis 0\")\n            axis_item = self.get_axis_item(axis_name)\n        except KeyError:\n            axis_item = self.get_last_axis_item()\n\n        if axis_item is None:\n            axis_item = self.add_empty_axis(axis_name)\n\n        pv_name = curve_dict.get(\"channel\", \"\")\n        del curve_dict[\"channel\"]  # Remove channel key to avoid conflicts with y_channel\n        axis_item.add_curve(pv_name, curve_dict)\n    self.plot.redrawPlot()\n    self.axis_list.itemAt(self.axis_list.count() - 2).widget()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.ControlPanel.show_formula_dialog","title":"<code>show_formula_dialog()</code>","text":"<p>Show the formula dialog pop-up.</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def show_formula_dialog(self):\n    \"\"\"Show the formula dialog pop-up.\"\"\"\n    if not hasattr(self, \"formula_dialog\") or not self.formula_dialog.isVisible():\n        self.formula_dialog.show()\n    else:\n        self.formula_dialog.raise_()\n        self.formula_dialog.activateWindow()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem","title":"<code>CurveItem</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>class CurveItem(QtWidgets.QWidget):\n    curve_deleted = QtCore.Signal(object)\n\n    icon_disconnected = qta.icon(\"msc.debug-disconnect\")\n\n    def __init__(self, plot_curve_item: ArchivePlotCurveItem, variable_name: str = None) -&gt; None:\n        super().__init__()\n        self.source = plot_curve_item\n        self.is_formula = self._is_formula_curve()\n        self._variable_name = variable_name\n        self.setLayout(QtWidgets.QHBoxLayout())\n\n        self.handle = DragHandle()\n        self.handle.setFlat(True)\n        self.handle.setIcon(qta.icon(\"ph.dots-six-vertical\", scale_factor=1.5))\n        self.handle.setStyleSheet(\"border: None;\")\n        self.handle.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor))\n        self.layout().addWidget(self.handle)\n\n        self.active_toggle = QtWidgets.QCheckBox(\"Active\")\n        self.active_toggle.setCheckState(QtCore.Qt.Checked if self.source.isVisible() else QtCore.Qt.Unchecked)\n        self.active_toggle.stateChanged.connect(self.set_active)\n        self.layout().addWidget(self.active_toggle)\n\n        second_layout = QtWidgets.QVBoxLayout()\n        self.layout().addLayout(second_layout)\n        pv_settings_layout = QtWidgets.QHBoxLayout()\n        second_layout.addLayout(pv_settings_layout)\n        data_type_layout = QtWidgets.QHBoxLayout()\n        second_layout.addLayout(data_type_layout)\n\n        self.invalid_action = None\n        self.variable_name_label = QtWidgets.QLabel()\n        self.variable_name_label.setMinimumWidth(40)\n        self.variable_name_label.setAlignment(QtCore.Qt.AlignCenter)\n        display_name = variable_name\n        self.variable_name_label.setText(display_name)\n        pv_settings_layout.addWidget(self.variable_name_label)\n        self.variable_name_label.setToolTip(\"Variable name of the curve\")\n\n        self.label = QtWidgets.QLineEdit()\n        self.label.setText(self.source.name())\n        self.label.editingFinished.connect(self.set_curve_pv)\n        self.label.returnPressed.connect(self.label.clearFocus)\n        pv_settings_layout.addWidget(self.label)\n        self.pv_settings_button = QtWidgets.QPushButton()\n        self.pv_settings_button.setIcon(qta.icon(\"msc.settings-gear\"))\n        self.pv_settings_button.setFlat(True)\n        self.pv_settings_modal = None\n        self.pv_settings_button.clicked.connect(self.show_settings_modal)\n        pv_settings_layout.addWidget(self.pv_settings_button)\n\n        self.setup_line_edit()\n\n        self.live_connection_status = QtWidgets.QLabel()\n        self.live_connection_status.setPixmap(self.icon_disconnected.pixmap(16, 16))\n        self.live_connection_status.setToolTip(\"Not connected to live data\")\n        self.source.live_channel_connection.connect(self.update_live_icon)\n        pv_settings_layout.addWidget(self.live_connection_status)\n\n        self.archive_connection_status = QtWidgets.QLabel()\n        self.archive_connection_status.setPixmap(self.icon_disconnected.pixmap(16, 16))\n        self.archive_connection_status.setToolTip(\"Not connected to archive data\")\n        self.source.archive_channel_connection.connect(self.update_archive_icon)\n        pv_settings_layout.addWidget(self.archive_connection_status)\n\n        self.delete_button = QtWidgets.QPushButton()\n        self.delete_button.setIcon(qta.icon(\"msc.trash\"))\n        self.delete_button.setFlat(True)\n        self.delete_button.clicked.connect(self.close)\n        pv_settings_layout.addWidget(self.delete_button)\n\n        data_type_layout.addStretch()\n\n    def update_variable_name(self):\n        \"\"\"Update the variable name label\"\"\"\n        if self._variable_name:\n            self.variable_name_label.setText(self._variable_name)\n\n    def show_invalid_icon(self, show=True):\n        \"\"\"Show or hide the invalid formula icon overlaid on the line edit\"\"\"\n        if not self.is_formula:\n            return\n\n        if show:\n            if self.invalid_action is None:\n                icon = qta.icon(\"fa6s.triangle-exclamation\", color=\"red\")\n                self.invalid_action = self.label.addAction(icon, QtWidgets.QLineEdit.TrailingPosition)\n                self.invalid_action.setToolTip(\"Formula is invalid\")\n\n            self.label.setStyleSheet(\n                \"\"\"\n                QLineEdit {\n                    border: 2px solid #d32f2f;\n                    border-radius: 4px;\n                    padding: 4px;\n                    background-color: white;\n                }\n            \"\"\"\n            )\n        else:\n            if self.invalid_action is not None:\n                self.label.removeAction(self.invalid_action)\n                self.invalid_action = None\n\n            self.label.setStyleSheet(\"\")\n\n    @property\n    def plot(self):\n        return self.parent().plot\n\n    @property\n    def axis_item(self):\n        \"\"\"Get the AxisItem that this CurveItem belongs to.\"\"\"\n        parent = self.parent()\n        while not isinstance(parent, AxisItem):\n            parent = parent.parent()\n        return parent\n\n    def set_active(self, state: QtCore.Qt.CheckState):\n        if state == QtCore.Qt.Unchecked:\n            self.source.hide()\n        else:\n            self.source.show()\n\n    def update_live_icon(self, connected: bool) -&gt; None:\n        self.live_connection_status.setVisible(not connected)\n\n    def update_archive_icon(self, connected: bool) -&gt; None:\n        self.archive_connection_status.setVisible(not connected)\n\n    @QtCore.Slot()\n    def show_settings_modal(self):\n        if self.pv_settings_modal is None:\n            self.pv_settings_modal = CurveSettingsModal(self.pv_settings_button, self.plot, self.source)\n        self.pv_settings_modal.show()\n\n    def mousePressEvent(self, event: QtGui.QMouseEvent):\n        if event.button() == QtCore.Qt.LeftButton and self.handle.geometry().contains(event.position().toPoint()):\n            self.hide()  # hide actual widget so it doesn't conflict with pixmap on cursor\n            drag = QtGui.QDrag(self)\n            drag.setMimeData(QtCore.QMimeData())\n            drag.setPixmap(self.grab())\n            drag.setHotSpot(self.handle.geometry().center())\n            drag.exec()\n            self.show()  # show curve after drag, even if it ended outside of an axis\n\n    def _is_formula_curve(self):\n        \"\"\"Check if this is a formula curve\"\"\"\n        return isinstance(self.source, FormulaCurveItem)\n\n    def setup_line_edit(self):\n        \"\"\"Set up the line edit with appropriate behavior for formula vs regular curves\"\"\"\n        if self.is_formula:\n            if hasattr(self.source, \"formula\"):\n                self.label.setText(self.source.formula)\n            elif hasattr(self.source, \"name\"):\n                self.label.setText(self.source.name())\n\n            self.label.setPlaceholderText(\"Edit formula (f://...)\")\n\n            self.label.editingFinished.disconnect()\n            self.label.returnPressed.disconnect()\n\n            self.label.returnPressed.connect(self.update_formula)\n            self.label.returnPressed.connect(self.label.clearFocus)\n        else:\n            self.label.setText(self.source.name())\n            self.label.setPlaceholderText(\"PV Name\")\n\n            self.label.editingFinished.disconnect()\n            self.label.returnPressed.disconnect()\n\n            self.label.editingFinished.connect(self.set_curve_pv)\n            self.label.returnPressed.connect(self.label.clearFocus)\n\n    def update_formula(self):\n        \"\"\"Handle formula updates when user edits the formula text\"\"\"\n        if hasattr(self, \"_updating_formula\") and self._updating_formula:\n            return\n\n        new_formula = self.label.text().strip()\n\n        if not new_formula.startswith(\"f://\"):\n            QtWidgets.QMessageBox.warning(\n                self, \"Invalid Formula\", \"Formula must start with 'f://'.\\nExample: f://{PV1}+2\"\n            )\n            if hasattr(self.source, \"formula\"):\n                self.label.setText(self.source.formula)\n            return\n\n        current_formula = getattr(self.source, \"formula\", \"\") if hasattr(self.source, \"formula\") else \"\"\n        if new_formula == current_formula:\n            return\n\n        self._updating_formula = True\n\n        try:\n            axis_item = self.get_parent_axis()\n            if not axis_item:\n                raise RuntimeError(\"Could not find parent AxisItem\")\n\n            control_panel = axis_item.control_panel_ref\n            if not control_panel:\n                widget = axis_item\n                while widget and not hasattr(widget, \"_curve_dict\"):\n                    widget = widget.parent()\n                control_panel = widget\n\n            if not control_panel:\n                raise RuntimeError(\"Could not find ControlPanel\")\n\n            var_names = re.findall(r\"{(.+?)}\", new_formula)\n\n            for var_name in var_names:\n                if var_name not in control_panel._curve_dict:\n                    raise ValueError(\n                        f\"Variable '{var_name}' not found. Available: {list(control_panel._curve_dict.keys())}\"\n                    )\n\n            expr_body = new_formula[4:]\n            if var_names:\n                python_expr, allowed = sanitize_for_validation(expr_body)\n                validate_formula(python_expr, allowed_symbols=allowed)\n            else:\n                validate_formula(expr_body, allowed_symbols=set())\n\n            def delayed_update():\n                try:\n                    self._perform_formula_update(new_formula, axis_item, control_panel)\n                except Exception as e:\n                    QtWidgets.QMessageBox.critical(None, \"Formula Update Failed\", f\"Failed to update formula: {str(e)}\")\n                finally:\n                    if hasattr(self, \"_updating_formula\"):\n                        self._updating_formula = False\n\n            QTimer.singleShot(10, delayed_update)\n\n        except Exception as e:\n            self._updating_formula = False\n            QtWidgets.QMessageBox.critical(self, \"Formula Update Failed\", f\"Failed to update formula: {str(e)}\")\n            if hasattr(self.source, \"formula\"):\n                self.label.setText(self.source.formula)\n            self.show_invalid_icon(True)\n\n    def _perform_formula_update(self, new_formula, axis_item, control_panel):\n        \"\"\"Perform the actual formula update - called asynchronously to avoid segfault\"\"\"\n        plot = control_panel.plot\n\n        if self.source in plot._curves:\n            plot._curves.remove(self.source)\n        plot.plotItem.removeItem(self.source)\n\n        old_key = None\n        for key, value in list(control_panel._curve_dict.items()):\n            if value == self.source:\n                old_key = key\n                del control_panel._curve_dict[key]\n                break\n\n        var_names = re.findall(r\"{(.+?)}\", new_formula)\n        var_dict = {}\n        for var_name in var_names:\n            if var_name not in control_panel._curve_dict:\n                raise ValueError(\n                    f\"Variable '{var_name}' not found. Available: {list(control_panel._curve_dict.keys())}\"\n                )\n            var_dict[var_name] = control_panel._curve_dict[var_name]\n\n        index = len(plot._curves)\n        color = ColorButton.index_color(index)\n\n        new_formula_curve = plot.addFormulaChannel(\n            formula=new_formula,\n            name=new_formula,\n            pvs=var_dict,\n            color=color,\n            useArchiveData=True,\n            yAxisName=axis_item.source.name,\n        )\n\n        self.source = new_formula_curve\n        self.is_formula = True\n        self.label.setText(new_formula)\n\n        if old_key and old_key.startswith(\"fx\"):\n            control_panel._curve_dict[old_key] = new_formula_curve\n        else:\n            key = control_panel._generate_pv_key(\"formula\")\n            control_panel._curve_dict[key] = new_formula_curve\n\n        self.update_variable_name()\n\n        self.show_invalid_icon(False)\n\n        axis_item.curves_list_changed.emit()\n\n        if hasattr(self, \"_updating_formula\"):\n            self._updating_formula = False\n\n    def get_parent_axis(self):\n        \"\"\"Find the parent AxisItem by traversing up the widget hierarchy\"\"\"\n        parent = self.parent()\n        while parent:\n            if hasattr(parent, \"add_formula_curve\"):\n                return parent\n            parent = parent.parent()\n        return None\n\n    @QtCore.Slot()\n    def set_curve_pv(self, pv: str = None):\n        if pv is None and self.sender():\n            pv = self.sender().text()\n\n        if self.is_formula:\n            self.update_formula()\n            return\n\n        self.source.address = pv\n\n    def close(self) -&gt; bool:\n        curve = self.source\n        [ch.disconnect() for ch in curve.channels() if ch]\n\n        control_panel = None\n        parent = self.parent()\n        while parent:\n            if hasattr(parent, \"_curve_dict\"):\n                control_panel = parent\n                break\n            parent = parent.parent()\n\n        if not control_panel:\n            logger.warning(\"Could not find ControlPanel\")\n            self.setParent(None)\n            self.deleteLater()\n            return super().close()\n\n        try:\n            control_panel.plot.removeCurve(curve)\n            if hasattr(control_panel.plot, \"set_needs_redraw\"):\n                control_panel.plot.set_needs_redraw()\n\n        except ValueError as e:\n            logger.debug(f\"Warning: Curve already removed: {e}\")\n        except Exception as e:\n            logger.warning(f\"Error removing curve from plot: {e}\")\n\n        for key, value in list(control_panel._curve_dict.items()):\n            if value == curve:\n                del control_panel._curve_dict[key]\n                control_panel.curve_list_changed.emit()\n                break\n\n        self.setParent(None)\n        self.deleteLater()\n\n        if self.parent():\n            self.curve_deleted.emit(curve)\n\n        return super().close()\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.axis_item","title":"<code>axis_item</code>  <code>property</code>","text":"<p>Get the AxisItem that this CurveItem belongs to.</p>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.get_parent_axis","title":"<code>get_parent_axis()</code>","text":"<p>Find the parent AxisItem by traversing up the widget hierarchy</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def get_parent_axis(self):\n    \"\"\"Find the parent AxisItem by traversing up the widget hierarchy\"\"\"\n    parent = self.parent()\n    while parent:\n        if hasattr(parent, \"add_formula_curve\"):\n            return parent\n        parent = parent.parent()\n    return None\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.setup_line_edit","title":"<code>setup_line_edit()</code>","text":"<p>Set up the line edit with appropriate behavior for formula vs regular curves</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def setup_line_edit(self):\n    \"\"\"Set up the line edit with appropriate behavior for formula vs regular curves\"\"\"\n    if self.is_formula:\n        if hasattr(self.source, \"formula\"):\n            self.label.setText(self.source.formula)\n        elif hasattr(self.source, \"name\"):\n            self.label.setText(self.source.name())\n\n        self.label.setPlaceholderText(\"Edit formula (f://...)\")\n\n        self.label.editingFinished.disconnect()\n        self.label.returnPressed.disconnect()\n\n        self.label.returnPressed.connect(self.update_formula)\n        self.label.returnPressed.connect(self.label.clearFocus)\n    else:\n        self.label.setText(self.source.name())\n        self.label.setPlaceholderText(\"PV Name\")\n\n        self.label.editingFinished.disconnect()\n        self.label.returnPressed.disconnect()\n\n        self.label.editingFinished.connect(self.set_curve_pv)\n        self.label.returnPressed.connect(self.label.clearFocus)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.show_invalid_icon","title":"<code>show_invalid_icon(show=True)</code>","text":"<p>Show or hide the invalid formula icon overlaid on the line edit</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def show_invalid_icon(self, show=True):\n    \"\"\"Show or hide the invalid formula icon overlaid on the line edit\"\"\"\n    if not self.is_formula:\n        return\n\n    if show:\n        if self.invalid_action is None:\n            icon = qta.icon(\"fa6s.triangle-exclamation\", color=\"red\")\n            self.invalid_action = self.label.addAction(icon, QtWidgets.QLineEdit.TrailingPosition)\n            self.invalid_action.setToolTip(\"Formula is invalid\")\n\n        self.label.setStyleSheet(\n            \"\"\"\n            QLineEdit {\n                border: 2px solid #d32f2f;\n                border-radius: 4px;\n                padding: 4px;\n                background-color: white;\n            }\n        \"\"\"\n        )\n    else:\n        if self.invalid_action is not None:\n            self.label.removeAction(self.invalid_action)\n            self.invalid_action = None\n\n        self.label.setStyleSheet(\"\")\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.update_formula","title":"<code>update_formula()</code>","text":"<p>Handle formula updates when user edits the formula text</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def update_formula(self):\n    \"\"\"Handle formula updates when user edits the formula text\"\"\"\n    if hasattr(self, \"_updating_formula\") and self._updating_formula:\n        return\n\n    new_formula = self.label.text().strip()\n\n    if not new_formula.startswith(\"f://\"):\n        QtWidgets.QMessageBox.warning(\n            self, \"Invalid Formula\", \"Formula must start with 'f://'.\\nExample: f://{PV1}+2\"\n        )\n        if hasattr(self.source, \"formula\"):\n            self.label.setText(self.source.formula)\n        return\n\n    current_formula = getattr(self.source, \"formula\", \"\") if hasattr(self.source, \"formula\") else \"\"\n    if new_formula == current_formula:\n        return\n\n    self._updating_formula = True\n\n    try:\n        axis_item = self.get_parent_axis()\n        if not axis_item:\n            raise RuntimeError(\"Could not find parent AxisItem\")\n\n        control_panel = axis_item.control_panel_ref\n        if not control_panel:\n            widget = axis_item\n            while widget and not hasattr(widget, \"_curve_dict\"):\n                widget = widget.parent()\n            control_panel = widget\n\n        if not control_panel:\n            raise RuntimeError(\"Could not find ControlPanel\")\n\n        var_names = re.findall(r\"{(.+?)}\", new_formula)\n\n        for var_name in var_names:\n            if var_name not in control_panel._curve_dict:\n                raise ValueError(\n                    f\"Variable '{var_name}' not found. Available: {list(control_panel._curve_dict.keys())}\"\n                )\n\n        expr_body = new_formula[4:]\n        if var_names:\n            python_expr, allowed = sanitize_for_validation(expr_body)\n            validate_formula(python_expr, allowed_symbols=allowed)\n        else:\n            validate_formula(expr_body, allowed_symbols=set())\n\n        def delayed_update():\n            try:\n                self._perform_formula_update(new_formula, axis_item, control_panel)\n            except Exception as e:\n                QtWidgets.QMessageBox.critical(None, \"Formula Update Failed\", f\"Failed to update formula: {str(e)}\")\n            finally:\n                if hasattr(self, \"_updating_formula\"):\n                    self._updating_formula = False\n\n        QTimer.singleShot(10, delayed_update)\n\n    except Exception as e:\n        self._updating_formula = False\n        QtWidgets.QMessageBox.critical(self, \"Formula Update Failed\", f\"Failed to update formula: {str(e)}\")\n        if hasattr(self.source, \"formula\"):\n            self.label.setText(self.source.formula)\n        self.show_invalid_icon(True)\n</code></pre>"},{"location":"reference/widgets/control_panel/#widgets.control_panel.CurveItem.update_variable_name","title":"<code>update_variable_name()</code>","text":"<p>Update the variable name label</p> Source code in <code>trace/widgets/control_panel.py</code> <pre><code>def update_variable_name(self):\n    \"\"\"Update the variable name label\"\"\"\n    if self._variable_name:\n        self.variable_name_label.setText(self._variable_name)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/","title":"Helper Widgets","text":""},{"location":"reference/widgets/helper_widgets/#color-button","title":"Color Button","text":""},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton","title":"<code>ColorButton</code>","text":"<p>               Bases: <code>QPushButton</code></p> <p>Custom button to allow the user to select a color. The default color is a random bright color.</p> <p>Left-clicking opens a color dialog box to choose a color. Right-clicking resets the color to the default.</p>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton--parameters","title":"Parameters","text":"<p>color : QColor or str, optional     Default color for the button to use, by default None index : int, optional     A value used in determining a default color, by default -1</p> Source code in <code>trace/widgets/color_button.py</code> <pre><code>class ColorButton(QPushButton):\n    \"\"\"Custom button to allow the user to select a color. The default\n    color is a random bright color.\n\n    Left-clicking opens a color dialog box to choose a color.\n    Right-clicking resets the color to the default.\n\n    Parameters\n    ----------\n    color : QColor or str, optional\n        Default color for the button to use, by default None\n    index : int, optional\n        A value used in determining a default color, by default -1\n    \"\"\"\n\n    color_changed = Signal(QColor)\n\n    def __init__(self, *args: Any, color: QColor | str = None, index: int = -1, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        if not color:\n            if index &gt;= 0:\n                color = self.index_color(index)\n            else:\n                color = self.random_color()\n        elif not isinstance(color, QColor):\n            color = QColor(color)\n\n        self._color = None\n        self._default = color\n        self.dialog_box = QColorDialog(self)\n        self.dialog_box.setCurrentColor(color)\n\n        self.pressed.connect(self.dialog_box.show)\n        self.dialog_box.colorSelected.connect(lambda c: setattr(self, \"color\", c))\n\n        self.color = self._default\n\n    @property\n    def color(self) -&gt; QColor:\n        \"\"\"Return the current color.\"\"\"\n        return self._color\n\n    @color.setter\n    def color(self, color: QColor) -&gt; None:\n        \"\"\"Set the background color of the button to the selected color.\"\"\"\n        if color == self._color:\n            return\n\n        self._color = color\n        style_str = \"ColorButton {background-color: \" + self._color.name() + \"};\"\n        self.setStyleSheet(style_str)\n\n        self.color_changed.emit(color)\n\n    def mousePressEvent(self, e: QMouseEvent) -&gt; None:\n        \"\"\"Set the color to the default on right-click.\"\"\"\n        if e.button() == Qt.RightButton:\n            self.color = self._default\n            return\n\n        return super().mousePressEvent(e)\n\n    @staticmethod\n    def random_color() -&gt; QColor:\n        \"\"\"Pick a random color for the default color of each PV. This\n        function ensures that the color is bright, since it will be on a\n        black background.\"\"\"\n        hue = int(360 * random())\n        saturation = int(256 * (0.5 + random() / 2.0))\n        lightness = int(256 * (0.4 + random() / 5.0))\n        color = QColor()\n        color.setHsl(hue, saturation, lightness)\n        return color\n\n    @staticmethod\n    def index_color(index: int) -&gt; QColor:\n        \"\"\"Returns the color in the color palette at index.\"\"\"\n        modded_index = index % len(color_palette)\n        color = color_palette[modded_index]\n\n        dark_factor = (index // len(color_palette)) * 35\n        return color.darker(100 + dark_factor)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton.color","title":"<code>color</code>  <code>property</code> <code>writable</code>","text":"<p>Return the current color.</p>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton.index_color","title":"<code>index_color(index)</code>  <code>staticmethod</code>","text":"<p>Returns the color in the color palette at index.</p> Source code in <code>trace/widgets/color_button.py</code> <pre><code>@staticmethod\ndef index_color(index: int) -&gt; QColor:\n    \"\"\"Returns the color in the color palette at index.\"\"\"\n    modded_index = index % len(color_palette)\n    color = color_palette[modded_index]\n\n    dark_factor = (index // len(color_palette)) * 35\n    return color.darker(100 + dark_factor)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton.mousePressEvent","title":"<code>mousePressEvent(e)</code>","text":"<p>Set the color to the default on right-click.</p> Source code in <code>trace/widgets/color_button.py</code> <pre><code>def mousePressEvent(self, e: QMouseEvent) -&gt; None:\n    \"\"\"Set the color to the default on right-click.\"\"\"\n    if e.button() == Qt.RightButton:\n        self.color = self._default\n        return\n\n    return super().mousePressEvent(e)\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#widgets.color_button.ColorButton.random_color","title":"<code>random_color()</code>  <code>staticmethod</code>","text":"<p>Pick a random color for the default color of each PV. This function ensures that the color is bright, since it will be on a black background.</p> Source code in <code>trace/widgets/color_button.py</code> <pre><code>@staticmethod\ndef random_color() -&gt; QColor:\n    \"\"\"Pick a random color for the default color of each PV. This\n    function ensures that the color is bright, since it will be on a\n    black background.\"\"\"\n    hue = int(360 * random())\n    saturation = int(256 * (0.5 + random() / 2.0))\n    lightness = int(256 * (0.4 + random() / 5.0))\n    color = QColor()\n    color.setHsl(hue, saturation, lightness)\n    return color\n</code></pre>"},{"location":"reference/widgets/helper_widgets/#frozen-table-view","title":"Frozen Table View","text":""},{"location":"reference/widgets/helper_widgets/#widgets.frozen_table_view.FrozenTableView","title":"<code>FrozenTableView</code>","text":"<p>               Bases: <code>QTableView</code></p> <p>QTableView with the leftmost column frozen so it always shows while the rest of the table is horizontally scrollable.</p> <p>Python version of Qt FreezeTableWidget example: https://doc.qt.io/qt-6/qtwidgets-itemviews-frozencolumn-example.html</p> Source code in <code>trace/widgets/frozen_table_view.py</code> <pre><code>class FrozenTableView(QTableView):\n    \"\"\"QTableView with the leftmost column frozen so it always shows while the\n    rest of the table is horizontally scrollable.\n\n    Python version of Qt FreezeTableWidget example:\n    https://doc.qt.io/qt-6/qtwidgets-itemviews-frozencolumn-example.html\n    \"\"\"\n\n    def __init__(self, model):\n        super(FrozenTableView, self).__init__()\n        self.setModel(model)\n        self.frozenTableView = QTableView(self)\n        self.init()\n        self.horizontalHeader().sectionResized.connect(self.updateSectionWidth)\n        self.verticalHeader().hide()\n        self.frozenTableView.verticalScrollBar().valueChanged.connect(self.verticalScrollBar().setValue)\n        self.verticalScrollBar().valueChanged.connect(self.frozenTableView.verticalScrollBar().setValue)\n\n    def init(self):\n        self.frozenTableView.setModel(self.model())\n        self.frozenTableView.setFocusPolicy(Qt.NoFocus)\n        self.frozenTableView.verticalHeader().hide()\n        self.frozenTableView.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\n        self.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\n        self.viewport().stackUnder(self.frozenTableView)\n\n        self.setAlternatingRowColors(True)\n        self.frozenTableView.setAlternatingRowColors(True)\n        self.frozenTableView.setStyleSheet(\"QTableView {border: none; border-right: 1px solid lightGray}\")\n\n        self.setSelectionBehavior(QTableView.SelectRows)\n        self.frozenTableView.setSelectionBehavior(QTableView.SelectRows)\n        self.frozenTableView.setSelectionModel(self.selectionModel())\n        for col in range(1, self.model().columnCount()):\n            self.frozenTableView.setColumnHidden(col, True)\n        self.frozenTableView.setColumnWidth(0, self.columnWidth(0))\n        self.frozenTableView.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        self.frozenTableView.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        self.frozenTableView.show()\n        self.updateFrozenTableGeometry()\n        self.setHorizontalScrollMode(self.ScrollPerPixel)\n        self.setVerticalScrollMode(self.ScrollPerPixel)\n        self.frozenTableView.setVerticalScrollMode(self.ScrollPerPixel)\n\n    def updateSectionWidth(self, logicalIndex, oldSize, newSize):\n        if logicalIndex == 0:\n            self.frozenTableView.setColumnWidth(0, newSize)\n            self.updateFrozenTableGeometry()\n\n    def updateSectionHeight(self, logicalIndex, oldSize, newSize):\n        self.frozenTableView.setRowHeight(logicalIndex, newSize)\n\n    def resizeEvent(self, event):\n        super(FrozenTableView, self).resizeEvent(event)\n        self.updateFrozenTableGeometry()\n\n    def moveCursor(self, cursorAction, modifiers):\n        current = super(FrozenTableView, self).moveCursor(cursorAction, modifiers)\n        if (\n            cursorAction == self.MoveLeft\n            and current.column() &gt; 0\n            and self.visualRect(current).topLeft().x() &lt; self.frozenTableView.columnWidth(0)\n        ):\n            newValue = (\n                self.horizontalScrollBar().value()\n                + self.visualRect(current).topLeft().x()\n                - self.frozenTableView.columnWidth(0)\n            )\n            self.horizontalScrollBar().setValue(newValue)\n        return current\n\n    def scrollTo(self, index, hint):\n        if index.column() &gt; 0:\n            super(FrozenTableView, self).scrollTo(index, hint)\n\n    def updateFrozenTableGeometry(self):\n        self.frozenTableView.setGeometry(\n            self.verticalHeader().width() + self.frameWidth(),\n            self.frameWidth(),\n            self.columnWidth(0),\n            self.viewport().height() + self.horizontalHeader().height(),\n        )\n</code></pre>"},{"location":"reference/widgets/settings_popups/","title":"Settings Popups","text":""},{"location":"reference/widgets/settings_popups/#components","title":"Components","text":""},{"location":"reference/widgets/settings_popups/#plot-settings","title":"Plot Settings","text":""},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal","title":"<code>PlotSettingsModal</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>class PlotSettingsModal(QWidget):\n    auto_scroll_interval_change = Signal(int)\n    grid_alpha_change = Signal(int)\n    set_all_y_axis_gridlines = Signal(bool)\n    disable_autoscroll = Signal()\n\n    def __init__(self, parent: QWidget, plot: PyDMArchiverTimePlot):\n        super().__init__(parent)\n        self.setWindowFlag(Qt.Popup)\n\n        self.plot = plot\n        main_layout = QVBoxLayout()\n        self.setLayout(main_layout)\n\n        title_label = SettingsTitle(self, \"Plot Settings\", size=14)\n        main_layout.addWidget(title_label)\n\n        self.plot_title_line_edit = QLineEdit()\n        self.plot_title_line_edit.setPlaceholderText(\"Enter Title\")\n        self.plot_title_line_edit.textChanged.connect(self.plot.setPlotTitle)\n        self.plot.plotItem.titleLabel.anchor((0.5, 0), (0.5, 0))  # Center title\n        plot_title_row = SettingsRowItem(self, \"Title\", self.plot_title_line_edit)\n        main_layout.addLayout(plot_title_row)\n\n        self.legend_checkbox = QCheckBox(self)\n        self.legend_checkbox.stateChanged.connect(lambda check: self.plot.setShowLegend(bool(check)))\n        self.legend_checkbox.setChecked(True)  # legend on by default\n        legend_row = SettingsRowItem(self, \"Show Legend\", self.legend_checkbox)\n        main_layout.addLayout(legend_row)\n\n        self.mouse_mode_combo = QComboBox(self)\n        self.mouse_mode_combo.addItems([\"Rect\", \"Pan\"])\n        self.mouse_mode_combo.currentTextChanged.connect(self.plot.plotItem.changeMouseMode)\n        mouse_mode_row = SettingsRowItem(self, \"Mouse Mode\", self.mouse_mode_combo)\n        main_layout.addLayout(mouse_mode_row)\n\n        self.as_interval_spinbox = QSpinBox(self)\n        self.as_interval_spinbox.setValue(5)\n        self.as_interval_spinbox.setMinimum(1)\n        self.as_interval_spinbox.setMaximum(60)\n        self.as_interval_spinbox.setSuffix(\" s\")\n        self.as_interval_spinbox.valueChanged.connect(self.auto_scroll_interval_change.emit)\n        as_interval_row = SettingsRowItem(self, \"Autoscroll Interval\", self.as_interval_spinbox)\n        main_layout.addLayout(as_interval_row)\n\n        self.start_datetime = QDateTimeEdit(self)\n        self.start_datetime.setDisplayFormat(\"yyyy-MM-dd HH:mm:ss\")\n        self.start_datetime.setCalendarPopup(True)\n        self.start_datetime.dateTimeChanged.connect(lambda qdt: self.set_time_axis_range((qdt, None)))\n        start_dt_row = SettingsRowItem(self, \"Start Time\", self.start_datetime)\n        main_layout.addLayout(start_dt_row)\n\n        self.end_datetime = QDateTimeEdit(self)\n        self.end_datetime.setDisplayFormat(\"yyyy-MM-dd HH:mm:ss\")\n        self.end_datetime.setCalendarPopup(True)\n        self.end_datetime.dateTimeChanged.connect(lambda qdt: self.set_time_axis_range((None, qdt)))\n        end_dt_row = SettingsRowItem(self, \"End Time\", self.end_datetime)\n        main_layout.addLayout(end_dt_row)\n\n        self.crosshair_checkbox = QCheckBox(self)\n        self.crosshair_checkbox.stateChanged.connect(lambda check: self.plot.enableCrosshair(check, 100, 100))\n        crosshair_row = SettingsRowItem(self, \"Show Crosshair\", self.crosshair_checkbox)\n        main_layout.addLayout(crosshair_row)\n\n        appearance_label = SettingsTitle(self, \"Appearance\")\n        main_layout.addWidget(appearance_label)\n\n        self.background_button = ColorButton(parent=self, color=\"white\")\n        self.background_button.color_changed.connect(self.plot.setBackgroundColor)\n        background_row = SettingsRowItem(self, \"  Background Color\", self.background_button)\n        main_layout.addLayout(background_row)\n\n        axis_tick_font_size_spinbox = QSpinBox(self)\n        axis_tick_font_size_spinbox.setValue(12)\n        axis_tick_font_size_spinbox.setSuffix(\" pt\")\n        axis_tick_font_size_spinbox.valueChanged.connect(self.set_axis_tick_font_size)\n        axis_tick_font_size_row = SettingsRowItem(self, \"  Axis Tick Font Size\", axis_tick_font_size_spinbox)\n        main_layout.addLayout(axis_tick_font_size_row)\n\n        self.x_grid_checkbox = QCheckBox(self)\n        self.x_grid_checkbox.stateChanged.connect(self.show_x_grid)\n        x_grid_row = SettingsRowItem(self, \"  X Axis Gridline\", self.x_grid_checkbox)\n        main_layout.addLayout(x_grid_row)\n\n        self.y_grid_checkbox = QCheckBox(self)\n        self.y_grid_checkbox.stateChanged.connect(self.show_y_grid)\n        y_grid_row = SettingsRowItem(self, \"  All Y Axis Gridlines\", self.y_grid_checkbox)\n        main_layout.addLayout(y_grid_row)\n\n        self.grid_opacity_slider = QSlider(self)\n        self.grid_opacity_slider.setOrientation(Qt.Horizontal)\n        self.grid_opacity_slider.setMaximum(255)\n        self.grid_opacity_slider.setValue(127)\n        self.grid_opacity_slider.setSingleStep(32)\n        self.grid_opacity_slider.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n        self.grid_opacity_slider.valueChanged.connect(self.change_gridline_opacity)\n        grid_opacity_row = SettingsRowItem(self, \"  Gridline Opacity\", self.grid_opacity_slider)\n        main_layout.addLayout(grid_opacity_row)\n\n        plot_viewbox = self.plot.plotItem.vb\n        plot_viewbox.sigXRangeChanged.connect(self.set_axis_datetimes)\n        plot_viewbox.sigRangeChangedManually.connect(lambda *_: self.set_axis_datetimes())\n\n    @property\n    def auto_scroll_interval(self):\n        interval = self.as_interval_spinbox.value()\n        interval *= 1000  # Convert to milliseconds\n        return interval\n\n    @property\n    def x_grid_visible(self):\n        return self.x_grid_checkbox.isChecked()\n\n    @property\n    def gridline_opacity(self):\n        opacity = self.grid_opacity_slider.value()\n        return opacity\n\n    def show(self):\n        parent_pos = self.parent().rect().bottomRight()\n        global_pos = self.parent().mapToGlobal(parent_pos)\n        self.move(global_pos)\n        super().show()\n\n    @Slot(int)\n    def set_axis_tick_font_size(self, size: int) -&gt; None:\n        font = QFont()\n        font.setPixelSize(size)\n\n        all_axes = self.plot.plotItem.getAxes()\n        for axis in all_axes:\n            axis.setStyle(tickFont=font)\n\n    @Slot(object)\n    def set_time_axis_range(self, raw_range: tuple[QDateTime, QDateTime] = (None, None)) -&gt; None:\n        \"\"\"PyQT Slot to set the plot's X-Axis range. This slot should be\n        triggered on QDateTimeEdit value change.\n\n        Parameters\n        ----------\n        raw_range : tuple[QDateTime, QDateTime], optional\n            Takes in a tuple of 2 values, where one is a QDateTime and\n            the other is None. The positioning changes either the plot's\n            min or max range value. By default (None, None)\n        \"\"\"\n        # Disable Autoscroll if enabled\n        # self.ui.cursor_scale_btn.click()\n        self.disable_autoscroll.emit()\n\n        proc_range = [None, None]\n        for ind, val in enumerate(raw_range):\n            # Values that are QDateTime are converted to a float timestamp\n            if isinstance(val, QDateTime):\n                proc_range[ind] = val.toSecsSinceEpoch()\n            # Values that are None use the existing range value\n            elif not val:\n                proc_range[ind] = self.plot.getXAxis().range[ind]\n        proc_range.sort()\n\n        logger.debug(f\"Setting plot's X-Axis range to {proc_range}\")\n        self.plot.plotItem.vb.blockSignals(True)\n        self.plot.plotItem.setXRange(*proc_range, padding=0)\n        self.plot.plotItem.vb.blockSignals(False)\n\n    @Slot(object, object)\n    def set_axis_datetimes(self, _: ViewBox = None, time_range: tuple[float, float] = None) -&gt; None:\n        \"\"\"Slot used to update the QDateTimeEdits on the Axis tab. This\n        slot is called when the plot's X-Axis range changes values.\n\n        Parameters\n        ----------\n        _ : ViewBox, optional\n            The ViewBox on which the range is changing. This is unused\n        time_range : Tuple[float, float], optional\n            The new range values for the QDateTimeEdits, by default None\n        \"\"\"\n        if not time_range:\n            time_range = self.plot.getXAxis().range\n        if min(time_range) &lt;= 0:\n            return\n\n        time_range = [datetime.fromtimestamp(f) for f in time_range]\n\n        edits = (self.start_datetime, self.end_datetime)\n        for ind, qdt in enumerate(edits):\n            if qdt.hasFocus():\n                continue\n            qdt.blockSignals(True)\n            qdt.setDateTime(QDateTime(time_range[ind]))\n            qdt.blockSignals(False)\n\n    @Slot(int)\n    def show_x_grid(self, visible: int):\n        \"\"\"Slot to show or hide the X-Axis gridlines.\"\"\"\n        opacity = self.gridline_opacity\n        self.set_plot_gridlines(bool(visible), opacity)\n\n    @Slot(int)\n    def show_y_grid(self, visible: int):\n        visible = bool(visible)\n        self.set_all_y_axis_gridlines.emit(visible)\n\n    @Slot(int)\n    def change_gridline_opacity(self, opacity: int):\n        \"\"\"Slot to change the opacity of the gridlines for both X and Y axes.\"\"\"\n        visible = self.x_grid_visible\n        self.set_plot_gridlines(visible, opacity)\n\n    def set_plot_gridlines(self, visible: bool, opacity: int):\n        \"\"\"Helper function to set the plot's gridlines visibility and opacity. Updates both X and Y axes.\"\"\"\n        normalized_opacity = opacity / 255\n        self.plot.setShowXGrid(visible, normalized_opacity)\n        self.grid_alpha_change.emit(opacity)\n\n    @Slot(dict)\n    def plot_setup(self, config: dict):\n        \"\"\"Read in the full config dictionary. For each config preset, set the widgets to match the value, which will\n        send signals out that will actually cause the plot to change.\"\"\"\n        if \"title\" in config:\n            self.plot_title_line_edit.setText(str(config[\"title\"]))\n        if \"legend\" in config:\n            self.legend_checkbox.setChecked(bool(config[\"legend\"]))\n        if \"mouseMode\" in config:\n            mouse_mode_index = int(config[\"mouseMode\"] / 3)\n            self.mouse_mode_combo.setCurrentIndex(mouse_mode_index)\n        if \"refreshInterval\" in config:\n            self.as_interval_spinbox.setValue(int(config[\"refreshInterval\"] / 1000))\n        if \"crosshair\" in config:\n            self.crosshair_checkbox.setChecked(bool(config[\"crosshair\"]))\n        if \"backgroundColor\" in config:\n            self.background_button.color = QColor(config[\"backgroundColor\"])\n        if \"xGrid\" in config:\n            self.x_grid_checkbox.setChecked(bool(config[\"xGrid\"]))\n        if \"yGrid\" in config:\n            self.y_grid_checkbox.setChecked(bool(config[\"yGrid\"]))\n        if \"gridOpacity\" in config:\n            self.grid_opacity_slider.setValue(int(config[\"gridOpacity\"]))\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.change_gridline_opacity","title":"<code>change_gridline_opacity(opacity)</code>","text":"<p>Slot to change the opacity of the gridlines for both X and Y axes.</p> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(int)\ndef change_gridline_opacity(self, opacity: int):\n    \"\"\"Slot to change the opacity of the gridlines for both X and Y axes.\"\"\"\n    visible = self.x_grid_visible\n    self.set_plot_gridlines(visible, opacity)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.plot_setup","title":"<code>plot_setup(config)</code>","text":"<p>Read in the full config dictionary. For each config preset, set the widgets to match the value, which will send signals out that will actually cause the plot to change.</p> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(dict)\ndef plot_setup(self, config: dict):\n    \"\"\"Read in the full config dictionary. For each config preset, set the widgets to match the value, which will\n    send signals out that will actually cause the plot to change.\"\"\"\n    if \"title\" in config:\n        self.plot_title_line_edit.setText(str(config[\"title\"]))\n    if \"legend\" in config:\n        self.legend_checkbox.setChecked(bool(config[\"legend\"]))\n    if \"mouseMode\" in config:\n        mouse_mode_index = int(config[\"mouseMode\"] / 3)\n        self.mouse_mode_combo.setCurrentIndex(mouse_mode_index)\n    if \"refreshInterval\" in config:\n        self.as_interval_spinbox.setValue(int(config[\"refreshInterval\"] / 1000))\n    if \"crosshair\" in config:\n        self.crosshair_checkbox.setChecked(bool(config[\"crosshair\"]))\n    if \"backgroundColor\" in config:\n        self.background_button.color = QColor(config[\"backgroundColor\"])\n    if \"xGrid\" in config:\n        self.x_grid_checkbox.setChecked(bool(config[\"xGrid\"]))\n    if \"yGrid\" in config:\n        self.y_grid_checkbox.setChecked(bool(config[\"yGrid\"]))\n    if \"gridOpacity\" in config:\n        self.grid_opacity_slider.setValue(int(config[\"gridOpacity\"]))\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_axis_datetimes","title":"<code>set_axis_datetimes(_=None, time_range=None)</code>","text":"<p>Slot used to update the QDateTimeEdits on the Axis tab. This slot is called when the plot's X-Axis range changes values.</p>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_axis_datetimes--parameters","title":"Parameters","text":"<p>_ : ViewBox, optional     The ViewBox on which the range is changing. This is unused time_range : Tuple[float, float], optional     The new range values for the QDateTimeEdits, by default None</p> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(object, object)\ndef set_axis_datetimes(self, _: ViewBox = None, time_range: tuple[float, float] = None) -&gt; None:\n    \"\"\"Slot used to update the QDateTimeEdits on the Axis tab. This\n    slot is called when the plot's X-Axis range changes values.\n\n    Parameters\n    ----------\n    _ : ViewBox, optional\n        The ViewBox on which the range is changing. This is unused\n    time_range : Tuple[float, float], optional\n        The new range values for the QDateTimeEdits, by default None\n    \"\"\"\n    if not time_range:\n        time_range = self.plot.getXAxis().range\n    if min(time_range) &lt;= 0:\n        return\n\n    time_range = [datetime.fromtimestamp(f) for f in time_range]\n\n    edits = (self.start_datetime, self.end_datetime)\n    for ind, qdt in enumerate(edits):\n        if qdt.hasFocus():\n            continue\n        qdt.blockSignals(True)\n        qdt.setDateTime(QDateTime(time_range[ind]))\n        qdt.blockSignals(False)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_plot_gridlines","title":"<code>set_plot_gridlines(visible, opacity)</code>","text":"<p>Helper function to set the plot's gridlines visibility and opacity. Updates both X and Y axes.</p> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>def set_plot_gridlines(self, visible: bool, opacity: int):\n    \"\"\"Helper function to set the plot's gridlines visibility and opacity. Updates both X and Y axes.\"\"\"\n    normalized_opacity = opacity / 255\n    self.plot.setShowXGrid(visible, normalized_opacity)\n    self.grid_alpha_change.emit(opacity)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_time_axis_range","title":"<code>set_time_axis_range(raw_range=(None, None))</code>","text":"<p>PyQT Slot to set the plot's X-Axis range. This slot should be triggered on QDateTimeEdit value change.</p>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.set_time_axis_range--parameters","title":"Parameters","text":"<p>raw_range : tuple[QDateTime, QDateTime], optional     Takes in a tuple of 2 values, where one is a QDateTime and     the other is None. The positioning changes either the plot's     min or max range value. By default (None, None)</p> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(object)\ndef set_time_axis_range(self, raw_range: tuple[QDateTime, QDateTime] = (None, None)) -&gt; None:\n    \"\"\"PyQT Slot to set the plot's X-Axis range. This slot should be\n    triggered on QDateTimeEdit value change.\n\n    Parameters\n    ----------\n    raw_range : tuple[QDateTime, QDateTime], optional\n        Takes in a tuple of 2 values, where one is a QDateTime and\n        the other is None. The positioning changes either the plot's\n        min or max range value. By default (None, None)\n    \"\"\"\n    # Disable Autoscroll if enabled\n    # self.ui.cursor_scale_btn.click()\n    self.disable_autoscroll.emit()\n\n    proc_range = [None, None]\n    for ind, val in enumerate(raw_range):\n        # Values that are QDateTime are converted to a float timestamp\n        if isinstance(val, QDateTime):\n            proc_range[ind] = val.toSecsSinceEpoch()\n        # Values that are None use the existing range value\n        elif not val:\n            proc_range[ind] = self.plot.getXAxis().range[ind]\n    proc_range.sort()\n\n    logger.debug(f\"Setting plot's X-Axis range to {proc_range}\")\n    self.plot.plotItem.vb.blockSignals(True)\n    self.plot.plotItem.setXRange(*proc_range, padding=0)\n    self.plot.plotItem.vb.blockSignals(False)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.plot_settings.PlotSettingsModal.show_x_grid","title":"<code>show_x_grid(visible)</code>","text":"<p>Slot to show or hide the X-Axis gridlines.</p> Source code in <code>trace/widgets/plot_settings.py</code> <pre><code>@Slot(int)\ndef show_x_grid(self, visible: int):\n    \"\"\"Slot to show or hide the X-Axis gridlines.\"\"\"\n    opacity = self.gridline_opacity\n    self.set_plot_gridlines(bool(visible), opacity)\n</code></pre>"},{"location":"reference/widgets/settings_popups/#axis-settings","title":"Axis Settings","text":""},{"location":"reference/widgets/settings_popups/#curve-settings","title":"Curve Settings","text":""},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal","title":"<code>CurveSettingsModal</code>","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>class CurveSettingsModal(QWidget):\n    def __init__(self, parent: QWidget, plot: PyDMArchiverTimePlot, curve: TimePlotCurveItem):\n        super().__init__(parent)\n        self.setWindowFlag(Qt.Popup)\n\n        self.legend = plot._legend\n        self.curve = curve\n        main_layout = QVBoxLayout()\n        self.setLayout(main_layout)\n\n        title_label = SettingsTitle(self, \"Curve Settings\", size=14)\n        main_layout.addWidget(title_label)\n\n        name_edit = QLineEdit(curve.name(), self)\n        name_edit.editingFinished.connect(self.set_curve_name)\n        name_row = SettingsRowItem(self, \"Curve Name\", name_edit)\n        main_layout.addLayout(name_row)\n\n        color_button = ColorButton(parent=self, color=curve.color_string)\n        color_button.color_changed.connect(self.set_curve_color)\n        color_row = SettingsRowItem(self, \"Color\", color_button)\n        main_layout.addLayout(color_row)\n\n        self.bin_count_line_edit = bin_count_line_edit = QLineEdit()\n        bin_count_line_edit.setMaximumWidth(65)\n        bin_count_line_edit.returnPressed.connect(self.set_curve_data_bins)\n        optimized_bin_count = SettingsRowItem(self, \"Optimized bin count\", bin_count_line_edit)\n        bin_count = curve.optimized_data_bins\n        if not bin_count:\n            bin_count = plot.optimized_data_bins\n        bin_count_line_edit.setPlaceholderText(str(bin_count))\n        main_layout.addLayout(optimized_bin_count)\n\n        self.live_toggle = QCheckBox(\"\")\n        self.live_toggle.setCheckState(Qt.Checked if self.curve.liveData else Qt.Unchecked)\n        self.live_toggle.stateChanged.connect(self.set_live_data_connection)\n        live_toggle_row = SettingsRowItem(self, \"Connect to Live\", self.live_toggle)\n        main_layout.addLayout(live_toggle_row)\n\n        self.archive_toggle = QCheckBox(\"\")\n        self.archive_toggle.setCheckState(Qt.Checked if self.curve.use_archive_data else Qt.Unchecked)\n        self.archive_toggle.stateChanged.connect(self.set_archive_data_connection)\n        archive_toggle_row = SettingsRowItem(self, \"Connect to Archive\", self.archive_toggle)\n        main_layout.addLayout(archive_toggle_row)\n\n        line_title_label = SettingsTitle(self, \"Line\")\n        main_layout.addWidget(line_title_label)\n\n        init_curve_type = \"Step\" if curve.stepMode in [\"left\", \"right\", \"center\"] else \"Direct\"\n        type_combo = ComboBoxWrapper(self, {\"Direct\": None, \"Step\": \"right\"}, init_curve_type)\n        type_combo.text_changed.connect(self.set_curve_type)\n        type_row = SettingsRowItem(self, \"  Type\", type_combo)\n        main_layout.addLayout(type_row)\n\n        style_combo = ComboBoxWrapper(self, TimePlotCurveItem.lines, curve.lineStyle)\n        style_combo.text_changed.connect(self.set_curve_style)\n        style_row = SettingsRowItem(self, \"  Style\", style_combo)\n        main_layout.addLayout(style_row)\n\n        width_options = {f\"{i}px\": i for i in range(1, 6)}\n        width_combo = ComboBoxWrapper(self, width_options, curve.lineWidth)\n        width_combo.text_changed.connect(self.set_curve_width)\n        width_row = SettingsRowItem(self, \"  Width\", width_combo)\n        main_layout.addLayout(width_row)\n\n        extention_option = QCheckBox(self)\n        extention_option.stateChanged.connect(lambda check: self.set_extension_option(bool(check)))\n        extention_option_row = SettingsRowItem(self, \"Line Extention\", extention_option)\n        main_layout.addLayout(extention_option_row)\n\n        symbol_title_label = SettingsTitle(self, \"Symbol\")\n        main_layout.addWidget(symbol_title_label)\n\n        shape_combo = ComboBoxWrapper(self, TimePlotCurveItem.symbols, curve.symbol)\n        shape_combo.text_changed.connect(self.set_symbol_shape)\n        shape_row = SettingsRowItem(self, \"  Shape\", shape_combo)\n        main_layout.addLayout(shape_row)\n\n        size_options = {f\"{i}px\": i for i in range(5, 26, 5)}\n        size_combo = ComboBoxWrapper(self, size_options, curve.symbolSize)\n        size_combo.text_changed.connect(self.set_symbol_size)\n        size_row = SettingsRowItem(self, \"  Size\", size_combo)\n        main_layout.addLayout(size_row)\n\n    def set_curve_data_bins(self):\n        n_bins = self.bin_count_line_edit.text()\n        if not n_bins.isdigit() or int(n_bins) &lt; 1:\n            self.bin_count_line_edit.setStyleSheet(\"border: 2px solid #d32f2f\")\n            logger.warning(\"Invalid bin count entered. Please enter a postive integer.\")\n            return\n        else:\n            self.bin_count_line_edit.setStyleSheet(\"\")\n        try:\n            n_bins = int(n_bins)\n            self.curve.setOptimizedDataBins(n_bins)\n            self.bin_count_line_edit.setPlaceholderText(str(n_bins))\n        except (AttributeError, ValueError) as e:\n            logger.warning(f\"Unable to set data bins: {e}\")\n\n    def set_live_data_connection(self, state: Qt.CheckState) -&gt; None:\n        self.curve.liveData = state == Qt.Checked\n\n    def set_archive_data_connection(self, state: Qt.CheckState) -&gt; None:\n        self.curve.use_archive_data = state == Qt.Checked\n\n    def show(self):\n        parent_pos = self.parent().rect().bottomRight()\n        global_pos = self.parent().mapToGlobal(parent_pos)\n        self.move(global_pos)\n        self.bin_count_line_edit.setStyleSheet(\"\")\n        self.bin_count_line_edit.setText(\"\")\n        super().show()\n\n    @Slot()\n    def set_curve_name(self):\n        sender = self.sender()\n        name = sender.text()\n\n        if not name:\n            sender.blockSignals(True)\n            sender.setText(self.curve.name())\n            sender.blockSignals(False)\n        elif name != self.curve.name():\n            legend_label = self.legend.getLabel(self.curve)\n            legend_label.setText(name)\n\n            x, y = self.curve.getData()\n            self.curve.setData(name=name, x=x, y=y)\n\n    @Slot(QColor)\n    def set_curve_color(self, color: QColor):\n        self.curve.color = color\n\n    @Slot(object)\n    def set_curve_type(self, curve_type: str | None = None) -&gt; None:\n        self.curve.stepMode = curve_type\n\n    @Slot(object)\n    def set_curve_style(self, style: int) -&gt; None:\n        self.curve.lineStyle = style\n\n    @Slot(object)\n    def set_curve_width(self, width: int) -&gt; None:\n        self.curve.lineWidth = width\n\n    @Slot(object)\n    def set_symbol_shape(self, shape: str) -&gt; None:\n        self.curve.symbol = shape\n\n    @Slot(object)\n    def set_symbol_size(self, size: int) -&gt; None:\n        self.curve.symbolSize = size\n\n    @Slot(object)\n    def set_extension_option(self, enable: bool) -&gt; None:\n        \"\"\"Set the line extension based on the checkbox state.\"\"\"\n        self.curve.show_extension_line = enable\n        self.curve.getViewBox().addItem(self.curve._extension_line)\n        self.curve.redrawCurve()\n</code></pre>"},{"location":"reference/widgets/settings_popups/#widgets.curve_settings.CurveSettingsModal.set_extension_option","title":"<code>set_extension_option(enable)</code>","text":"<p>Set the line extension based on the checkbox state.</p> Source code in <code>trace/widgets/curve_settings.py</code> <pre><code>@Slot(object)\ndef set_extension_option(self, enable: bool) -&gt; None:\n    \"\"\"Set the line extension based on the checkbox state.\"\"\"\n    self.curve.show_extension_line = enable\n    self.curve.getViewBox().addItem(self.curve._extension_line)\n    self.curve.redrawCurve()\n</code></pre>"},{"location":"tools/data_insight/","title":"Data Insight Tool","text":""},{"location":"tools/elog_entry/","title":"E-Log Entry Tool","text":""},{"location":"tools/file_converter/","title":"CLI File Converter Tool","text":"<p>Included in this application is a tool for converting files from the Archive Viewer's format or StripTool's format into Trace's format.</p> <p>It is located at <code>trace/file_io/trace_file_converter.py</code> and can be called directly from the command-line. This allows users to convert their files without having to open Trace.</p>"},{"location":"tools/file_converter/#help-message","title":"Help Message","text":"<pre><code>trace/file_io/trace_file_convert.py --help\n&gt;  usage: Trace File Converter [-h] [--output_file [OUTPUT_FILE ...]]\n&gt;                              [--overwrite] [--clean]\n&gt;                              [input_file ...]\n&gt;\n&gt;  Convert files used by the Java Archive Viewer or StripTool to a file format\n&gt;  that can be used with Trace.\n&gt;\n&gt;  positional arguments:\n&gt;    input_file            Path to the file(s) to be converted\n&gt;\n&gt;  options:\n&gt;    -h, --help            show this help message and exit\n&gt;    --output_file [OUTPUT_FILE ...], -o [OUTPUT_FILE ...]\n&gt;                          Path to the output file(s) (defaults to input file\n&gt;                          name); The number of output_files must match the\n&gt;                          number of input_files if any are provided\n&gt;    --overwrite, -w       Overwrite the target file if it exists\n&gt;    --clean               Remove the input file after successful conversion\n</code></pre>"},{"location":"tools/file_converter/#positional-arguments","title":"Positional Arguments","text":""},{"location":"tools/file_converter/#input-file","title":"Input File","text":"<pre><code>trace_file_convert.py examples/xml_conversion.xml\n</code></pre> <pre><code>trace_file_convert.py stp_files/*.stp\n</code></pre> <p>The only positional argument is the file to be converted, labeled <code>input_file</code>. This should be provided as a path to the file, either relative or absolute. Users can also provide multiple files to be converted at once.</p> <p>If any file(s) fail the conversion, individual error messages are provided so that users know which to look at. Some causes of failure are:</p> <ul> <li>The file does not exist</li> <li>The file does not use the <code>.xml</code> or <code>.stp</code> file extension</li> <li>The file is incorrectly formatted</li> </ul>"},{"location":"tools/file_converter/#optional-arguments","title":"Optional Arguments","text":""},{"location":"tools/file_converter/#output-file","title":"Output File","text":"<p><code>-o OUTPUT_FILE</code> or <code>--output_file OUTPUT_FILE</code></p> <pre><code>python trace_file_convert.py xml_conversion.xml -o xml_conversion.trc\n</code></pre> <p>Users can use this argument to pass the name and path the converted file should be saved as. If not provided, the converter defaults to the name of the input file with the <code>.trc</code> file extension.</p> <p>Users don't need to include a file extension for the output file name. The conversion fails if the provided output file name has a file extension and it is not <code>.trc</code>.</p> <p>If converting a batch of files, the user can provide multiple output file names to use.</p>"},{"location":"tools/file_converter/#overwrite","title":"Overwrite","text":"<p><code>-w</code> or <code>--overwrite</code></p> <p>The conversion will fail if a file already exists with the new file name (provided or default). Using the overwrite flag ignores the interrupt, allowing the tool to replace the existing file with the new file.</p> <pre><code>python trace_file_convert.py xml_conversion.xml -o xml_conversion.trc\n\n&gt;  [ERROR] - Failed: xml_conversion.xml --&gt; xml_conversion.trc:\n&gt;    Output file exists but overwrite not enabled: /path/to/xml_conversion.trc\n\npython trace_file_convert.py xml_conversion.xml -o xml_conversion.trc -w\n</code></pre>"},{"location":"tools/file_converter/#clean","title":"Clean","text":"<p><code>--clean</code></p> <p>This flag results in the conversion tool removing the input file after the conversion has been made.</p> <pre><code>python trace_file_convert.py examples/FormulaExample.trc --clean\n</code></pre>"},{"location":"tools/formula_maker/","title":"Formula Maker Tool","text":"<p>The Formula Maker Tool can help users construct [formula traces] for their plot. The tool can be opened by clicking the  button in the top of the configuration section.</p> <p>This tool is for ease of use, as users can also create formula traces by creating a trace that's prefixed with <code>f://</code>.</p>"},{"location":"tools/formula_maker/#variable-list","title":"Variable List","text":"<p>The top of the tool consists of a list of traces on the plot that users can use in their formula. The left column contains a variable name for each curve. To use a variable in the formula it should be surrounded by brackets <code>{}</code>.</p> <p><code>Double-clicking</code> a row will add the variable to the formula.</p>"},{"location":"tools/formula_maker/#calculator-like-section","title":"Calculator-like Section","text":"<p>The bottom part of the tool consists of a text box that users can type a formula in as well as buttons that users can use to build their formula.</p> <p>When the user is finished making their formula, they can either hit <code>Enter</code> or click the button labeled \"Add Formula Curve\".</p> <p>Formulas can include all basic arithmetic and binary operations, as well as <code>mean</code> and all functions in Python's standard math library.</p>"},{"location":"tools/search/","title":"PV Search Tool","text":"<p>The PV Search Tool can help users find PVs easier. The button labeled \"Search PV\" at the top of the configuration section opens a PV search tool.</p>"},{"location":"tools/search/#wildcard-characters","title":"Wildcard Characters","text":"<p>Users can make searches using a number of wildcard characters. All wildcards will represent 1+ characters regardless of the wildcard (equivalent of <code>*.</code> in Regular Expression).</p> <p>For example, the picture above shows a search for <code>KLYS:LI22:*:KVAC</code>. The results include all PVs that have that address with any character in the <code>*</code> position.</p>"},{"location":"tools/search/#selecting-pvs","title":"Selecting PVs","text":"<p>Use <code>Ctrl + Click</code> to toggle separate PVs as selected or not, and <code>Shift + Click</code> will select a range of PVs. <code>Double-Click</code> a PV or click the button labeled \"Add PVs\" to add them to Trace. New traces will be added to the last axis of the configuration section.</p>"}]}